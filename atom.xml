<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>N 27°59′′</title>
  
  <subtitle>duyu</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://doooyo.github.io/"/>
  <updated>2018-05-16T01:35:12.000Z</updated>
  <id>https://doooyo.github.io/</id>
  
  <author>
    <name>duyu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>concurrent并发包讲解(二)</title>
    <link href="https://doooyo.github.io/2017/06/30/Concurrent%E5%B9%B6%E5%8F%91%E5%8C%85%E8%AE%B2%E8%A7%A3(%E4%BA%8C)/"/>
    <id>https://doooyo.github.io/2017/06/30/Concurrent并发包讲解(二)/</id>
    <published>2017-06-30T04:08:16.000Z</published>
    <updated>2018-05-16T01:35:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="知识要点">知识要点</h2><p>写此篇只记录一些自己觉得比较重要的知识点, 其余查阅之前的篇幅</p><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:left">知识点</th></tr></thead><tbody><tr><td style="text-align:center"><code>Thread/Runable</code></td><td style="text-align:left"><code>线程状态机</code> <br> <code>join/wait</code> <br> <code>sleep</code> <br> <code>suspend/resume</code> <br> <code>interupt/interrupted/isInterrupted</code> <br> <code>notify/notifyAll</code> <br> <code>yield</code> <br></td></tr><tr><td style="text-align:center"><code>java内存模型</code></td><td style="text-align:left"><code>原子性/CAS</code> <br> <code>有序性/指令重排</code> <br> <code>可见性/volatile(内存屏障)</code> <br> <code>Happen-Before</code></td></tr><tr><td style="text-align:center"><code>Atomic包/CAS</code></td><td style="text-align:left"><code>AtomicInteger</code> <br> <code>AtomicReference</code> <br> <code>AtomicStampedReference</code> <br> <code>AtomicMarkableReference</code> <br> <code>AtomicIntegerArray</code>, <code>AtomicReferenceArray</code>  <br> <code>AtomicIntegerFieldUpdater</code> <br> <code>LockFreeVector</code> <br><code>LongAdder(JDK8)</code> <br> <code>ABA问题</code> <br></td></tr><tr><td style="text-align:center"><code>syncthroized/wait/notify</code></td><td style="text-align:left"><code>常用并发控制</code></td></tr><tr><td style="text-align:center"><code>Concurrent并发包</code></td><td style="text-align:left"><code>ReentrantLock</code><br> <code>Condition</code><br> <code>Semaphore</code><br> <code>ReadWriteLock</code>,<code>ReentrantReadWriteLock</code><br> <code>CountDownLatch</code><br> <code>CyclicBarrier</code><br> <code>CountDownLatch</code><br><code>ForkJoin</code><br><code>AQS</code><br><code>LockSupport</code></td></tr><tr><td style="text-align:center"><code>Amino(并发线程组件)</code></td><td style="text-align:left"><code>Master-Worker模式</code> <br> <code>Map-reduce模式</code> <br> <code>Divide and conquer模式</code> <br> <code>Pipeline模式</code> <br></td></tr><tr><td style="text-align:center"><code>JCTool</code></td><td style="text-align:left"><code>增强型数据结构</code></td></tr><tr><td style="text-align:center"><code>Guava Concurrent</code></td><td style="text-align:left"><code>谷歌并发编程工具包</code></td></tr><tr><td style="text-align:center"><code>Disruptor</code></td><td style="text-align:left"><code>高并发循环事件队列</code></td></tr><tr><td style="text-align:center"><code>Reactor与Proactor</code></td><td style="text-align:left"><code>涉及操作系统IO模型, 同步与异步/阻塞与非阻塞</code></td></tr></tbody></table><h2 id="thread-runnable">Thread/Runnable</h2><p>Thread只能单继承, Runnable可以多继承, 内部都是重写run()方法</p><h3 id="状态机">状态机</h3><p>线程有6种状态, 请查阅<code>java多线程基础（一）</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    NEW,      <span class="comment">//初始态</span></span><br><span class="line">    RUNNABLE, <span class="comment">//就绪态/运行态</span></span><br><span class="line">    BLOCKED,  <span class="comment">//阻塞态</span></span><br><span class="line">    WAITING,  <span class="comment">//等待态</span></span><br><span class="line">    TIMED_WAITING, <span class="comment">//超时等待态</span></span><br><span class="line">    TERMINATED; <span class="comment">//终止态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RUNNABLE</code>状态在jvm里可以认为是运行态, 但对于操作系统来说, <code>RUNNABLE</code>=<code>Runnable</code>+<code>Running</code>; 只有分配到cpu时间片才叫Running, 对于java来说不用关心</p><h3 id="同时线程有三个队列">同时线程有三个队列:</h3><p><code>1. 就绪队列</code>:处于Runnable状态, 随时等待cpu调度; 调用<code>yelid</code>, <code>sleep到期</code>, <code>join等待完毕</code>后即处于此状态;<font color="red">注意:yelid是谦让cpu时间片; sleep和join也不会释放锁, 更不会进入「等待队列」。难理解的地方在于join, 它是由wait实现的, 居然不进入「等待队列」?这是由于join的是当前主线程, 而非调用线程, 主线程等待子线程调用完毕后由内部native方法去notify唤醒</font>参考: <a href="https://segmentfault.com/q/1010000007260477" target="_blank" rel="noopener">Java多线程里面join方法会使被阻塞线程释放对象锁吗？</a><code>2. 锁池队列</code>:处于竞争锁状态, <code>synchorized</code>, <code>Lock</code>, <code>...</code><code>3. 等待队列</code>:wait调用后即进入此队列, 一旦被唤醒则进入<code>锁池队列</code>去竞争锁, 一旦竞争到锁则进入<code>等待队列</code>, 等待被cpu时间片调度</p><blockquote><ol start="3"><li>notify/notifyAll, waitnotify是随机唤醒阻塞在锁(monitor)上的线程, 有可能会出现唤醒的线程竞争不到锁资源(进入临界区)而失败;notifyAll则是唤醒所有阻塞在其上的线程, 也可能出现<code>惊群效应</code>, 可以理解为活锁, 大家都竞争不到锁而往复的释放自己持有的资源</li></ol></blockquote><ul><li>interupt/interrupted/isInterrupted<code>suspend/resume</code>已不推荐使用, <code>stop</code>由于其强杀会导致不一致性问题, 也不推荐使用</li></ul><blockquote><p><code>interrupt()</code>:线程状态被置为&quot;中断&quot;状态<code>interrupted()</code>:静态方法, 内部返回当前执行线程是否中断, 同时清除中断标记<code>isInterrupted()</code> :实例方法, 判断指定线程的中断状态, 但不一定是当前线程, 可以是A线程去调用B线程的isInterrupted()方法; 不会清除中断标记<code>中断线程的两种方式</code>:<code>阻塞的定义是可能在访问磁盘IO,可能访问网络IO(HTTP请求),或者正在访问数据库, 也有可能调用了wait/sleep/join</code></p></blockquote><ol><li>如果子线程不会进入阻塞态, 则使用volatile修饰的布尔变量来控制子线程的退出</li><li>如果有阻塞, 则通过拦截异常进行退出<font color="red">注意如果调用了wait/sleep/join, 一旦再调用interrupt会出现中断异常, 同时JVM会<strong>清除中断标记</strong>, 所以再使用isInterrupted会得到false</font></li></ol><h2 id="java内存模型">Java内存模型</h2><p>这个请查阅之前写的篇幅, 这里只记录大纲</p><blockquote><ol><li><code>可见性</code>: 明白<code>工作内存</code>和<code>主存</code></li><li><code>有序性</code>: CPU指令流水, 为了减少时钟, 出现了指令重排序</li><li><code>原子性</code>: CAS(cmpxchg汇编指令)</li><li><code>Happen-Before</code>, 规约哪些是不能重排序的4.1 顺序原则: 有数据相关性, 重排不能改变语义(<code>as-if-serial</code>)4.2 监视器锁规则: 解锁必须先加锁4.3 volatile域规则: 写了才能读4.4 传递性规则: 通俗讲, 调用线程的join/wait/interrupt, 必须先start线程</li><li><code>java的内在实现</code>: 八条内存屏障指令<code>lock</code>：作用于主内存，把变量标识为线程独占状态。<code>unlock</code>：作用于主内存，解除独占状态。<code>read</code>：作用主内存，把一个变量的值从主内存传输到线程的工作内存。<code>load</code>：作用于工作内存，把read操作传过来的变量值放入工作内存的变量副本中。<code>use</code>：作用工作内存，把工作内存当中的一个变量值传给执行引擎。<code>assign</code>：作用工作内存，把一个从执行引擎接收到的值赋值给工作内存的变量。<code>store</code>：作用于工作内存的变量，把工作内存的一个变量的值传送到主内存中。<code>write</code>：作用于主内存的变量，把store操作传来的变量的值放入主内存的变量中</li><li><code>java的外在体现</code>: volatile, Atomic(CAS)</li><li><code>总结</code></li></ol></blockquote><ol><li>避免死锁的方式: 不要在锁代码块里再获取其他锁, 这是死锁的前提</li><li>synchronized保证了原子性/可见性; 但volatile只保证可见性(内部采用禁止重排序和内存屏障,每次都会读取主存而非寄存器的缓存), 所以volatile不适合getAndSet操作</li><li>1</li></ol><h2 id="atomic包-cas">Atomic包/CAS</h2><ul><li><code>Unsafe</code>它类似直接操作C语言, 可以获取变量在对象中的偏移量并赋值, 类似struct结构体</li><li><code>AtomicInteger</code>从下面可以看出, 主要使用了<code>unsafe.compareAndSwapInt</code>, CAS使用了原子汇编指令<code>cmpxchg</code>, 失败重试机制(乐观锁)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>AtomicIntegerArray</code>保证数组的每个元素操作都是线程安全, 比起<code>Collections.synchronizedList</code>使用<code>syncthorized</code>悲观锁性能要好一些。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndSetInt(array, checkedByteOffset(i), newValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终使用了如下代码</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">byteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * - base为数组在内存的基地址</span></span><br><span class="line"><span class="comment">     * int base = unsafe.arrayBaseOffset(int[].class);</span></span><br><span class="line"><span class="comment">     * - shift为数组每个元素在内存的偏移量bit</span></span><br><span class="line"><span class="comment">     * - scale指Integer的宽度, 4个字节(byte)</span></span><br><span class="line"><span class="comment">     * int scale = unsafe.arrayIndexScale(int[].class);</span></span><br><span class="line"><span class="comment">     * numberOfLeadingZeros计算前导零的个数</span></span><br><span class="line"><span class="comment">     * shift = 31 - Integer.numberOfLeadingZeros(scale);</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">long</span>) i &lt;&lt; shift) + base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>AtomicIntegerFieldUpdater</code>主要用于普通变量的原子操作, 但是它有四点前提:<code>可见且可变的非静态volatile变量</code></li></ul><blockquote><ol><li>可见: 即不能private</li><li>可变: 即不能以final修饰, 因为使用了反射不允许修改final已经初始化的值</li><li>非静态: 即不能使用static, 因为CAS不支持静态堆数据的赋值</li></ol></blockquote><ul><li><code>LongAdder</code>采用了热点分离的思想,采用了Cell[], 将value值分离为一个数组; 结果即数组的累加求和。和ConcurrentHashMap的Segment分段锁很类似;因为CAS是自旋方式, 所以可能会出现经常失败而导致cpu白白浪费(‘空转’)</li></ul><blockquote><ol><li>用long类型的base字段存储值</li><li>casBase()方法进行CAS递增</li><li>如果CAS失败,不会自旋, 会立即创建Cell[]</li><li>单个Cell上面出现了cell更新冲突，那么会尝试创建新的Cell, 当Cell[]数组不够了, 则扩容</li><li>AtomicLong效率比较, 在线程1000,10000次循环递增,大概差距在100+ms; 当1000线程,100w次大循环递增, 差距大致6倍<a href="https://blog.csdn.net/f641385712/article/details/84934085" target="_blank" rel="noopener">JDK8-LongAdder代替AtomicLong</a></li></ol></blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">      Cell[] as; <span class="keyword">long</span> b, v; <span class="keyword">int</span> m; Cell a;</span><br><span class="line">      <span class="comment">// 2. 对base字段进行CAS</span></span><br><span class="line">      <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">          <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">              (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">              <span class="comment">// 单个Cell上CAS失败, 新建Cell或者扩容数组</span></span><br><span class="line">              !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">              <span class="comment">// 初始化Cell[]数组/新建Cell/扩容数组</span></span><br><span class="line">              longAccumulate(x, <span class="keyword">null</span>, uncontended);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="/Users/apple/Desktop/test/LongAdder.png" alt="热点分离"></p><ul><li><p><code>ThreadLocalRandom</code>解决了Random类在多线程下多个线程竞争内部唯一的原子性种子变量而导致大量线程自旋重试的不足;如下代码所示, 虽然采用了<code>AtomicLong</code>, 解决了多线程计算出相同新种子的问题(获取了相同的随机数), 但是新种子是CAS运算, 线程堆积后则可能出现大量自旋;ThreadLocalRandom重写了nextInt, 利用ThreadLocal, 初始化Thread线程实例里的``threadLocalRandomSeed<code>变量</code>ThreadLocalRandom.current()`就是在初始化线程里的种子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Random的nextInt方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">(<span class="keyword">int</span> bound)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 检查区间是否负数</span></span><br><span class="line">    <span class="keyword">if</span> (bound &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(BadBound);</span><br><span class="line">    <span class="comment">// 2.计算新种子</span></span><br><span class="line">    <span class="comment">// 此处在多线程下可能会产生多个一样的种子</span></span><br><span class="line">    <span class="comment">// 所以seed采用了CAS原子类AtomicLong</span></span><br><span class="line">    <span class="keyword">int</span> r = next(<span class="number">31</span>);</span><br><span class="line">    <span class="keyword">int</span> m = bound - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 3.开始生成'随机数', seed=f(seed), 所以概率相等, 分布均匀</span></span><br><span class="line">    <span class="keyword">if</span> ((bound &amp; m) == <span class="number">0</span>)  <span class="comment">// i.e., bound is a power of 2</span></span><br><span class="line">        r = (<span class="keyword">int</span>)((bound * (<span class="keyword">long</span>)r) &gt;&gt; <span class="number">31</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = r;</span><br><span class="line">             u - (r = u % bound) + m &lt; <span class="number">0</span>;</span><br><span class="line">             u = next(<span class="number">31</span>))</span><br><span class="line">            ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>Random类的实现原理如下:</p><blockquote><ol><li>构造函数带种子或不带种子默认采用系统当前纳秒时间,因为代码执行速度在<code>[几百纳秒, 几十毫秒]</code>这个区间,整体递增, 所以精准(<code>this(seedUniquifier() ^ System.nanoTime())</code>)</li><li>种子的意义随机的起源数字, 目的就是为了足够&quot;随机&quot;</li><li>nextInt(100)返回<code>[0,100)</code>左闭右开内的一个随机数, 注意数字是一个线性函数生成出来的, 所以数字是均匀分布, 等概率事件这在数学上不能称之为随机, 所以我们称为<code>伪随机数</code></li><li>Math.random 生成[0,1)之间的double类型随机数, 它是Random的实例</li></ol></blockquote><ul><li><code>LockFreeVector</code>由Amino并发库实现, 大部分为无锁CAS设计;其存储结构为一个<code>AtomicReferenceArray</code>二维数组结构, 首个数组容量为8, 一共30个数组, 每次扩容都是前一个的2倍, 所以最大容量固定为<code>8*(2^30-1)</code>目的是避免扩容时修改之前的数据其数据形状很类似<code>九九乘法表</code>, 高度30, 长度为前一个元素2倍</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReferenceArray&lt;AtomicReferenceArray&lt;E&gt;&gt; buckets = <span class="keyword">new</span> AtomicReferenceArray(<span class="number">30</span>);</span><br></pre></td></tr></table></figure><blockquote><p><code>1.存储结构</code>定义为了CAS的二维数组<code>AtomicReferenceArray&lt;AtomicReferenceArray&lt;E&gt;&gt;</code>一共30个数组, 首个数组长度为8, 数组往后成倍递增, 8&lt;&lt;1, 8&lt;&lt;2 … 8&lt;&lt;29; 最大容量为<code>8*(2^30-1)</code><code>2.Descriptor静态内部类</code>目的是为了更好的有序读写数组, 是一个内部辅助类<code>3.总结</code>为何存储定义为二维数组, 由于一维数组必定会进行扩容, 扩容必定不是原子操作, 所以为了避开扩容来符合CAS, 所以如此设计。第一个数组装满, 则往第二个数组追加, 此时的重点就在于<code>计算二维坐标</code></p></blockquote><p>我们来看一下最重要的方法, 主要是计算二维坐标</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    Descriptor&lt;E&gt; desc;</span><br><span class="line">    Descriptor&lt;E&gt; newd;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        desc = descriptor.get();</span><br><span class="line">        <span class="comment">//预防上一个线程在设置完descriptor后(while语句块), 还没来得及执行最后一句话completeWrite, 预防性的措施</span></span><br><span class="line">        desc.completeWrite();</span><br><span class="line">        <span class="comment">//desc.size   Vector 本身的大小</span></span><br><span class="line">        <span class="comment">//FIRST_BUCKET_SIZE  第一个一位数组的大小</span></span><br><span class="line">        <span class="keyword">int</span> pos = desc.size + FIRST_BUCKET_SIZE;</span><br><span class="line">        <span class="keyword">int</span> zeroNumPos = Integer.numberOfLeadingZeros(pos);  <span class="comment">// 取出pos 的前导零</span></span><br><span class="line">        <span class="comment">//zeroNumFirst  为FIRST_BUCKET_SIZE 的前导零</span></span><br><span class="line">        <span class="keyword">int</span> bucketInd = zeroNumFirst - zeroNumPos;  <span class="comment">//哪个一位数组</span></span><br><span class="line">        <span class="comment">//判断这个一维数组是否已经启用</span></span><br><span class="line">        <span class="keyword">if</span> (buckets.get(bucketInd) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//newLen  一维数组的长度</span></span><br><span class="line">            <span class="keyword">int</span> newLen = <span class="number">2</span> * buckets.get(bucketInd - <span class="number">1</span>).length();</span><br><span class="line">            <span class="keyword">if</span> (debug)</span><br><span class="line">                System.out.println(<span class="string">"New Length is:"</span> + newLen);</span><br><span class="line">            buckets.compareAndSet(bucketInd, <span class="keyword">null</span>,</span><br><span class="line">                    <span class="keyword">new</span> AtomicReferenceArray&lt;E&gt;(newLen));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> idx = (<span class="number">0x80000000</span>&gt;&gt;&gt;zeroNumPos) ^ pos;   <span class="comment">//在这个一位数组中，我在哪个位置</span></span><br><span class="line">        newd = <span class="keyword">new</span> Descriptor&lt;E&gt;(desc.size + <span class="number">1</span>, <span class="keyword">new</span> WriteDescriptor&lt;E&gt;(</span><br><span class="line">                buckets.get(bucketInd), idx, <span class="keyword">null</span>, e));</span><br><span class="line">    &#125; <span class="keyword">while</span> (!descriptor.compareAndSet(desc, newd));</span><br><span class="line">    descriptor.get().completeWrite();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码难点分析:</p><blockquote><ol><li><code>desc.completeWrite()</code>预防上一个线程在设置完descriptor后(while语句块里), 还没来得及执行最后一句话completeWrite(保存真正的值), 所以在do里预先执行一次, 预防出现没保存值的情况</li><li><code>计算第一维索引bucketIndex</code>即计算进位后前导零位数差值来作为bucketIndex; 当第一个组数(长度为8), 则pos = 8+8 = 16, 会导致进位, 通过前导零差值则可计算出第一维的索引下标</li><li><code>计算第二维索引iIndex</code><code>(0x80000000&gt;&gt;&gt;zeroNumPos) ^ pos</code>;<font color="orange">这个比较难理解, 我们看如下分析:</font></li></ol></blockquote>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">0x80000000 32位如下:</span><br><span class="line">1000 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">无符号右移动zeroNumPos位(pos的前导零个数)</span><br><span class="line">比如pos=17,代表第二个数组的第一位,坐标为(1,0)</span><br><span class="line">17已进位,则前导零个数为27,无符号右移27位,高位补27个零:</span><br><span class="line">0000 0000 0000 0000 0000 0000 0001 0000</span><br><span class="line">^异或pos (相等为0, 不等为1):</span><br><span class="line">0000 0000 0000 0000 0000 0000 0001 0001</span><br><span class="line">结果为:</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line">表明可以存入的索引为1 (注意索引从0开始, 即第二位)</span><br><span class="line">=======================================</span><br><span class="line">比如pos=13, 代表第一个数组第五位, 坐标为(0,4)</span><br><span class="line">前导零个数为28,无符号右移28位,高位补28个零:</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 1000</span><br><span class="line">^异或pos</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 1101</span><br><span class="line">结果为:</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0101</span><br><span class="line">表明可以存入的索引为5 (注意索引从0开始, 即第六位)</span><br><span class="line">=======================================</span><br><span class="line">比如pos=15, 代表第一个数组第七位, 坐标为(0,6)</span><br><span class="line">前导零个数为28,无符号右移28位,高位补28个零:</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 1000</span><br><span class="line">^异或pos</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 1111</span><br><span class="line">结果为:</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0111</span><br><span class="line">表明可以存入的索引为7 (注意索引从0开始, 即第八位)</span><br></pre></td></tr></table></figure><p><font color="red">为何这样设计? 这个需要对二进制数据结构比较敏感, 可能10进制已经固化到思维, 二进制反而很不直观, 采用二进制进位和前导零的关系, 可以直接映射坐标</font></p><blockquote><ol start="4"><li>每次会判断数组是否存在, 不存在表示前一个数组已满, 需要<code>扩容(创建后一个新数组)</code>, 长度为前一个的2倍</li></ol></blockquote><ul><li><code>ABA问题</code>CAS无法解决ABA问题, 即A线程讲i改为2, 然后又恢复原值, 造成B线程无法得知其中的过程;如果是值类型可能没有问题, 但是某些业务可能出现问题, 比如充值, 所以提出了<code>带时间戳的CAS</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReferenceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; money =</span><br><span class="line">            <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">19</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 3个充值线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> timestamp = money.getStamp();</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    Integer m = money.getReference();</span><br><span class="line">                    <span class="keyword">if</span> (m &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (money.compareAndSet(m, m + <span class="number">20</span>, timestamp, timestamp + <span class="number">1</span>)) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"余额小于20元,充值成功,余额:"</span> + money.getReference() + <span class="string">"元"</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"余额大于20,无需充值"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1个模拟消费线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> timestap = money.getStamp();</span><br><span class="line">                        Integer m = money.getReference();</span><br><span class="line">                        <span class="keyword">if</span> (m &gt; <span class="number">10</span>) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"金额大于10元"</span>);</span><br><span class="line">                            <span class="keyword">if</span> (money.compareAndSet(m, m - <span class="number">10</span>, timestap, timestap + <span class="number">1</span>)) &#123;</span><br><span class="line">                                System.out.println(<span class="string">"成功消费10元,余额:"</span> + money.getReference() + <span class="string">"元"</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">"没有足够的金额"</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>AtomicMarkableReference</code>适合只修改一次, 因为它的stamp是boolean布尔, 所以只有「未标记」/「已标记」两种状态</li></ul><h2 id="concurrent并发包">Concurrent并发包</h2><ul><li><p><code>ReentrantLock</code><font color="orange">这里重点讲一下锁的可重入：ReentrantLock和synchronized都是可重入的, 意思是同一个获得锁的线程, 不管进入临界区几次, 都是允许进入的；可重入机制: 每一个锁(monitor)关联一个线程持有者和计数器，当计数器为 0 时表示该锁没有被任何线程持有，那么任何线程都可能获得该锁而调用相应的方法；当某一线程请求成功后，JVM会记下锁的持有线程，并且将计数器置为 1；此时其它线程请求该锁，则必须等待；而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增；当线程退出同步代码块时，计数器会递减，如果计数器为 0，则释放该锁。</font></p><p>我们来模拟不可重入锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 不可重入锁 (使用CAS实现)</span><br><span class="line"> * 同一线程, 当两次调用lock, 而不调用unlock时, 会产生死锁</span><br><span class="line"> * 原因是第二次lock会永远更新不成功, 则永远在死循环</span><br><span class="line"> */</span><br><span class="line">public class UnreentrantLockByCAS &#123;</span><br><span class="line">      private AtomicReference&lt;Thread&gt; owner = new AtomicReference&lt;&gt;();</span><br><span class="line">      //AtomicInteger</span><br><span class="line"></span><br><span class="line">      public void lock() &#123;</span><br><span class="line">          Thread current = Thread.currentThread();</span><br><span class="line">          //这句是很经典的“自旋”语法</span><br><span class="line">          for (; ; ) &#123;</span><br><span class="line">              if (owner.compareAndSet(null, current)) &#123;</span><br><span class="line">                  return;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public void unlock() &#123;</span><br><span class="line">          Thread current = Thread.currentThread();</span><br><span class="line">          owner.compareAndSet(current, null);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不可重入锁 (使用CAS实现)</span></span><br><span class="line"><span class="comment"> * 同一线程, 当两次调用lock, 而不调用unlock时, 会产生死锁</span></span><br><span class="line"><span class="comment"> * 原因是第二次lock会永远更新不成功, 则永远在死循环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnreentrantLockByCAS</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> AtomicReference&lt;Thread&gt; owner = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">        <span class="comment">//AtomicInteger</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="comment">//这句是很经典的“自旋”语法</span></span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (owner.compareAndSet(<span class="keyword">null</span>, current)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            owner.compareAndSet(current, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然我们改动一下, 增加Thread判断, 同时增加计数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可重入 (synchronized实现)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockBySync</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</span><br><span class="line">      Thread lockedBy = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">int</span> lockedCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">          Thread thread = Thread.currentThread();</span><br><span class="line">          <span class="keyword">while</span> (isLocked &amp;&amp; lockedBy != thread) &#123;</span><br><span class="line">              wait();</span><br><span class="line">          &#125;</span><br><span class="line">          isLocked = <span class="keyword">true</span>;</span><br><span class="line">          lockedCount++;</span><br><span class="line">          lockedBy = thread;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (Thread.currentThread() == <span class="keyword">this</span>.lockedBy) &#123;</span><br><span class="line">              lockedCount--;</span><br><span class="line">              <span class="keyword">if</span> (lockedCount == <span class="number">0</span>) &#123;</span><br><span class="line">                  isLocked = <span class="keyword">false</span>;</span><br><span class="line">                  notify();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可重入 (使用CAS实现)</span></span><br><span class="line"><span class="comment"> * 两要素: 若是当前线程, 重入时state计数器加1, 释放时减1</span></span><br><span class="line"><span class="comment"> *  1.持有当前线程</span></span><br><span class="line"><span class="comment"> *  2.计数器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockByCAS</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> AtomicReference&lt;Thread&gt; owner = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">if</span> (current == owner.get()) &#123;</span><br><span class="line">                state++;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这句是很经典的“自旋”语法</span></span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (owner.compareAndSet(<span class="keyword">null</span>, current)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">if</span> (current == owner.get()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (state != <span class="number">0</span>) &#123;</span><br><span class="line">                    state--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    owner.compareAndSet(current, <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>总结:</p></li></ul><blockquote><p><code>可重入</code>:同一线程, 加几次锁, 就要释放几次<code>可中断</code>:<code>lock.lockInterruptibly();</code>只有声明为可中断加锁, 则线程是可以发起中断<code>thread.interrupt()</code><code>可限时</code>:意思是超时后若还未获得锁(monitor),则放弃锁竞争<code>lock.tryLock(5, TimeUnit.SECONDS)</code><code>公平锁</code>:<code>new ReentrantLock(true)</code>默认是非公平锁, 所谓公平即先来则先获得锁; 但是公平锁会维持队列, 且没有优先级的概念,非公平锁具有更高的吞吐量</p></blockquote><ul><li><code>Condition</code></li></ul><p><font color="red">Condition(await/singnal/singnalAll)和ReentrantLock的关系</font>就好比<font color="red">Object(wait/notify/notifyAll)与synchonized的关系</font>它提供了一个<code>awaitUninterruptibly</code>, 和wait一样, 但是不会响应中断, 即会一直等待signal唤醒具体就不细说,看一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock(); <span class="comment">// 类似synchronized</span></span><br><span class="line">            condition.await(); <span class="comment">// 类似obj.wait(); 注意await和object.wait一样是会释放锁的</span></span><br><span class="line">            <span class="comment">// 注意如果唤醒的是多个线程, 这里也会如同notifyAll一样, 出现锁竞争</span></span><br><span class="line">            System.out.println(<span class="string">"thread is going on"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ConditionTest r = <span class="keyword">new</span> ConditionTest();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line"></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始唤醒await的线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">"begin signal thread"</span>);</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Semaphore信号量</code></li></ul><p>[ˈseməfɔ:®] 信号量, 也可以称呼为共享锁它可以允许多个线程进入临界区, 但是一旦许可耗尽, 则其他线程也需要等待许可的释放,即退化为Lock锁;Semaphore和Lock的区别:</p><blockquote><ol><li>锁只允许一个线程进入临界区, 信号量允许多个线程进入临界区, 类似广义的独享锁</li><li>信号量会指定许可permission的数量, 一旦许可耗尽则退化为独享锁</li><li>一般一个线程只会持有一个permission许可, 但也可以一个线程持有多个许可</li></ol></blockquote><p>我们来看一个例子:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 获取一个permission许可(可以多个, 但消费一个则少一个)</span></span><br><span class="line">              semaphore.acquire();</span><br><span class="line"></span><br><span class="line">              <span class="comment">//模拟2s耗时操作</span></span><br><span class="line">              Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">              System.out.println(<span class="string">"Thread_"</span> + Thread.currentThread().getId() + <span class="string">" done!"</span>);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">              semaphore.release();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 创建容量固定为20的线程池</span></span><br><span class="line">          ExecutorService excutorService = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">final</span> SemaphoreTest semaphoreTask = <span class="keyword">new</span> SemaphoreTest();</span><br><span class="line"></span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">           * 20个线程任务立马提交完毕, 但是任务里有2s耗时操作, 所以一次最多允许执行5个线程, 2s后再执行5个线程, 依次之</span></span><br><span class="line"><span class="comment">           * 注意: execute 和 submit 区别</span></span><br><span class="line"><span class="comment">           *      1. submit有三个重载</span></span><br><span class="line"><span class="comment">           *         &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</span></span><br><span class="line"><span class="comment">           *         &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)</span></span><br><span class="line"><span class="comment">           *         Future&lt;?&gt; submit(Runnable task)</span></span><br><span class="line"><span class="comment">           *      2. submit有返回值, 但execute没有</span></span><br><span class="line"><span class="comment">           *      3. submit可以处理Exception异常, 捕获Future.get()即可</span></span><br><span class="line"><span class="comment">           *</span></span><br><span class="line"><span class="comment">           *</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)&#123;</span><br><span class="line">              excutorService.<span class="comment">/*execute*/</span>submit(semaphoreTask);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><code>ReentrantReadWriteLock读写锁</code></li></ul><p>它要解决的是<code>synchronized</code>在「读读」互斥串行的情况</p><blockquote><ol><li>读写锁是可重入的</li><li><code>读-读</code>: 不互斥, 是共享锁, 内部使用了AQS<code>写-写</code>: 互斥, 类似Lock<code>读-写</code>: 互斥, 同上; 即不支持<code>锁升级</code><code>写-读</code>: 互斥, 但是支持<code>锁降级</code>, 即线程获取写锁, 在不释放写锁的情况下, <strong>当前线程</strong>还可以获取读锁; 然后释放写锁后, 此时还剩下读锁, 则称为<code>锁降级</code></li><li>内部有<code>WriteLock</code>和<code>ReadLock</code>, 采用了<code>AQS(实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架)</code></li></ol></blockquote><p>来看一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读写互斥 (测试锁降级)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结论: ReentrantReadWriteLock支持锁降级, 但不支持锁升级</span></span><br><span class="line"><span class="comment"> *    1. 写锁降级为读锁, 但是不会释放当前线程获得的写锁; 仍需要手动释放写锁, 否则其他线程永远无法获得写锁</span></span><br><span class="line"><span class="comment"> *    2. 首先读写锁是互斥的;</span></span><br><span class="line"><span class="comment"> *       2.1 获取读锁 -&gt; 获取写锁</span></span><br><span class="line"><span class="comment"> *           发现无法获取写锁了, 这表明读写锁互斥, 且不支持锁升级 (即读锁升级为写锁)</span></span><br><span class="line"><span class="comment"> *       2.2 获取写锁 -&gt; 获取读锁</span></span><br><span class="line"><span class="comment"> *           发现写锁加锁后还能获取读锁, 这表明互斥情况下, 支持锁降级 (写锁降级为读锁)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *       2.3 当有读锁时，写锁就不能获得；而当有写锁时，除了获得写锁的这个线程可以获得读锁外，其他线程不能获得读锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockDownTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ReentrantReadWriteLock rwLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 先获取写锁, 在不释放写锁的前提下, 再获取读锁, 发现可以成功; 表明支持锁降级</span></span><br><span class="line"><span class="comment">         * 先获取读锁, 发现不能再获取写锁, 证明不支持锁升级</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rwLock.writeLock().lock();</span><br><span class="line">        System.out.println(<span class="string">"Thread_"</span> + Thread.currentThread().getId() +<span class="string">" get writeLock"</span>);</span><br><span class="line"></span><br><span class="line">        rwLock.readLock().lock();</span><br><span class="line">        System.out.println(<span class="string">"Thread_"</span> + Thread.currentThread().getId() +<span class="string">" get readLock"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放写锁, 完成锁降级为读锁</span></span><br><span class="line">        rwLock.writeLock().unlock();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后释放降级的读锁</span></span><br><span class="line">        rwLock.readLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        LockDownTest r = <span class="keyword">new</span> LockDownTest();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"FINISH"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>CountDownLatch</code> 倒数计时器(闭锁)闭锁, 类似一个门最初是关闭的, 比如等到10人(线程)到齐了才会开门, 所有人(线程)才可通过, 但是门打开之后就不能再关上, 所以不能重复利用</li></ul><blockquote><ol><li>它允许一个或多个线程一直等待, 直到其他线程的操作执行完后再执行, 类似join的功能</li><li>和Semaphore信号量一样, 提供一个count计数, 且只能初始化一次,不能修改; 当计数为0则唤醒阻塞的线程</li><li>CountDownLatch 和 join的区别其实两者的功能完成一样,都是阻塞线程等待其他线程执行完毕,然后继续执行; 但是join只能等待其他线程任务整体完成, 而CountDownLatch则是通过计数器count来作为标准, 所以粒度更细, 所以控制力更强</li><li>总结在需要等待的线程里调用<code>countDownLatch.countDown();</code>在受控主线程调用<code>countDownLatch.await();</code>直到内部count耗尽为0, 则会继续执行受控主线程</li><li>适用场景一般用于启动服务/任务前, 等待其他预检测线程反馈OK, 然后再继续启动很适合做Master/Worker, MapReduce等架构模式</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟随机耗时任务</span></span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>) * <span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">"Thread_"</span> + Thread.currentThread().getId() + <span class="string">" complete."</span>);</span><br><span class="line">            <span class="comment">// 每次都会count-1,直到为零,就会notify/signal唤醒主线程</span></span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        CountDownLatchTest1 test = <span class="keyword">new</span> CountDownLatchTest1();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            service.submit(test);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意不是调用Object的wait(), 这里很容易手误</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">"Main Thread Finish."</span>);</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>CyclicBarrier</code> 循环屏障(闭锁)</li></ul><p>它可以实现让一组线程等待至某个状态之后再全部同时执行</p><blockquote><ol><li>getNumberWaiting() 有几个线程已经到达屏障点getParties()取得parties个数reset() 将屏障重置为其初始状态isBroken() 查询此屏障是否处于损坏状态, 即查询阻塞的线程是否被中断</li><li>和CountDownlatch区别CountDownlatch是使用countDown进行count-1操作, 再使用await阻塞主线程, 直到count为零再唤醒继续执行;CyclicBarrier是利用await进行count+1, 当count==parties时则表明都到达屏障点</li><li>特点3.1如果在线程处于等待状态时barrier被reset()或者在调用await()时 barrier 被损坏，将抛出BrokenBarrierException异常3.2如果当前线程在进入此方法时已经设置了该线程的中断状态或者在等待时被中断，将抛出InterruptedException，并且清除当前线程的已中断状态3.3如果任何线程在等待时被中断，则其他所有等待线程都将抛出 BrokenBarrierException 异常，并将 barrier 置于损坏状态。3.4如果当前线程是最后一个将要到达的线程，并且构造方法中提供了一个非空的屏障操作(barrierAction), 那么在允许其他线程继续运行之前，当前线程将运行该操作。如果在执行屏障操作过程中发生异常，则该异常将传播到当前线程中, 并将 barrier 置于损坏状态(即Commander发生了异常, 则会将barrier置于损坏状态, 同时将异常抛出到主线程)</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Commander</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是集合还是完成任务</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag;</span><br><span class="line">        <span class="comment">// 人数</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Commander</span><span class="params">(<span class="keyword">boolean</span> flag, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.flag = flag;</span><br><span class="line">            <span class="keyword">this</span>.count = count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                System.out.println(<span class="string">"指挥官接到消息:[士兵"</span> + count + <span class="string">"个, 任务完成!]"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"指挥官接到消息:[士兵"</span> + count + <span class="string">"个, 集合完毕!]"</span>);</span><br><span class="line">                System.out.println(<span class="string">"指挥官发布执行任务命令... ..."</span>);</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Soldier</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String soldier;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier barrier;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Soldier</span><span class="params">(String soldier, CyclicBarrier barrier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.soldier = soldier;</span><br><span class="line">            <span class="keyword">this</span>.barrier = barrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// ------------ 等待所有士兵集合 ------------</span></span><br><span class="line">                <span class="keyword">int</span> waitCount = barrier.getParties() - barrier.getNumberWaiting() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (waitCount == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(soldier + <span class="string">", 所有士兵已集合完毕, 开始通知指挥官..."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                barrier.await();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// ------------ 集合完毕后开始各自执行任务 ------------</span></span><br><span class="line">                doWork();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// ------------ 等待所有士兵完成任务 ------------</span></span><br><span class="line">                waitCount = barrier.getParties() - barrier.getNumberWaiting() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (waitCount == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(soldier + <span class="string">"已完成, 所有士兵已完成任务, 开始通知指挥官..."</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    System.out.println(soldier + <span class="string">"已完成, 开始等待其他"</span> + waitCount + <span class="string">"人完成任务"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                barrier.await();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//Math.abs(new Random().nextInt() % 10000);</span></span><br><span class="line">                Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">        Thread[] solders = <span class="keyword">new</span> Thread[count];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(count, <span class="keyword">new</span> Commander(flag, count));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"队伍开始集合!"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"士兵"</span> + i + <span class="string">"报到"</span>);</span><br><span class="line">            solders[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Soldier(<span class="string">"士兵"</span> + i, barrier));</span><br><span class="line">            solders[i].start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">5</span>)&#123;</span><br><span class="line">                <span class="comment">//solders[0].interrupt();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>LockSupport</code> 锁支持源语</li></ul><p>之前讲过, suspend/resume已经被淘汰, 因为可能导致死锁wait/notify(notifyAll)则比前者更进一步, 解决了死锁问题, 但还是有一个问题存留, <code>先notify, 后wait</code>,虽然不会导致死锁, 但是会导致wait的线程一直hang在那</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">这里再备注一下suspend/resume的缺陷</span></span><br><span class="line"><span class="string">suspend和sleep很像,</span> <span class="string">也和wait很像,</span> <span class="string">但也有不同:</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> <span class="string">suspend也会持有监视器(锁),</span> <span class="string">和sleep很像,</span> <span class="string">但是sleep可以被中断,</span> <span class="string">也可以过期策略,</span> <span class="string">所以不会死锁</span></span><br><span class="line"><span class="number">2.</span> <span class="string">suspend也可以通过resume唤醒,</span> <span class="string">和wait/notify很像,</span> <span class="string">但是wait是释放了监视器(锁)的,</span> <span class="string">只是需要等待唤醒而已,</span> <span class="string">所以不会死锁</span></span><br><span class="line"><span class="number">3.</span> <span class="string">suspend一没有释放锁,</span> <span class="string">二没有中断机制,</span> <span class="string">三没有过期策略,</span> <span class="string">所以只能被resume唤醒</span></span><br><span class="line">   <span class="string">如果resume被先调用,</span> <span class="string">suspend后执行,</span> <span class="string">则会导致锁一直不被释放,</span> <span class="string">从而死锁</span></span><br></pre></td></tr></table></figure><blockquote><ol><li><code>LockSupport可以解决两大问题</code>1.1 解决suspend/resume的死锁问题1.2 解决wait/notify(notifyAll)的线程悬挂阻塞问题(虽然不会导致死锁了)</li><li><code>LockSupport两大优势</code>2.1 LockSupport不需要在同步代码块里;所以线程间也不需要维护一个共享的同步对象了，实现了线程间的解耦2.2 unpark函数可以先于park调用，所以不需要担心线程间的执行的先后顺序<strong>unpark将许可permit置为1, park将permit置为0</strong><strong>unpark-&gt;park; 会导致线程不会被阻塞</strong><strong>park-&gt;unpark; 线程阻塞后被唤醒</strong><strong>多次调用unpark, 由于只是重置为1,所以不影响</strong><strong>多次调用park, 由于LockSuport是不可重入锁, 所以会死锁</strong></li><li><code>广泛的应用</code><code>ThreadPoolExecutor内部使用LockSupport</code><code>阻塞</code>:典型的 future.get() 同步阻塞等待线程池的执行结果; submit提交Callable任务后会返回FutureTask, 此方法会有get方法, 继而调用awaitDone进行阻塞, 内部实则调用了LockSupport.park()<code>唤醒</code>:Callable被包装成了FutureTask, 内部会c.call()执行任务, 继而调用set方法, 内部调用finishCompletion, 而finishCompletion会通过CAS取出所有等待的线程, 循环唤醒 LockSupport.unpark(t)</li><li><code>注意事项</code></li></ol></blockquote><ul><li>ThreadLocal</li></ul><p>线程本地变量</p><blockquote><ol><li>ThreadLocal不是用来解决对象共享访问问题的; 反其道而行, 解决某个对象需要一直跟随某线程(同生共死), 从而解决对象如何传递的问题</li><li>典型的<code>Session会话管理</code>,多线程需要避免Session的调用混乱2.1 首先不加锁, 铁定出现多线程问题(openSession多次/正在写入数据库却被其他线程关闭close)2.2 加独享锁, 显然问题能解决, 但是一个操作正在进行,则其他操作必须等待, 性能有问题3.3 在DAO层做如下操作:<code>openSession() -&gt; 数据库操作 -&gt; close()</code>也能解决问题, 但是session频繁的打开关闭这也是性能问题</li><li>ThreadLocal正好利用线程的生命周期, 将需要使用的副本对象附加其上, 这样session对象的调用就不会错乱</li><li>ThreadLocalMap总结:4.1 ThreadLocalMap解决hash采用了线性探测(开发地址法), 如果冲突则加1; 这种算法比起链地址法效率低很多, 所以建议一个线程只保存一个变量(即一个ThreadLocal)4.2 ThreadLocalMap的key是弱引用, 而Value是强引用; 这导致ThreadLocal在没有外部对象强引用时，发生GC时弱引用Key会被回收, 而Value不会回收; 如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露; 但线程结束时总会释放掉;但如果线程是使用的线程池, 由于线程池里的线程结束是不会销毁的, 这时候就发生了真正意义上的内存泄漏</li></ol></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/7432604-ad2ff581127ba8cc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/806/format/webp" alt="ThreadLocal示意图"></p><p>ThreadLocal使用场景为 用来解决 数据库连接、Session管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal &lt; Connection &gt; connectionHolder = <span class="keyword">new</span> ThreadLocal &lt; Connection &gt; () &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(DB_URL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> connectionHolder.get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal threadSession = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException </span>&#123;</span><br><span class="line">    Session s = (Session) threadSession.get();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">            s = getSessionFactory().openSession();</span><br><span class="line">            threadSession.set(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (HibernateException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InfrastructureException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20181209234109898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Y2NDEzODU3MTI=,size_16,color_FFFFFF,t_70" alt></p><ul><li>ForkJoin</li></ul><p>JDK原生的单机版的MapReduce归并计算, Amino里也有类似的MasterWorker模式的实现</p><p><strong>主要思想:</strong><img src="http://dl.iteye.com/upload/attachment/234119/4f7cd1b0-9f58-306f-9590-87499929861d.jpg" alt></p><p><strong>对比MapReduce1.0原理</strong><img src="https://upload-images.jianshu.io/upload_images/14019352-0c530b046636edd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt></p><blockquote><ol><li></li></ol></blockquote><p><strong>类图:</strong><img src="http://dl.iteye.com/upload/attachment/234124/8703a34a-9f05-37a5-bb08-c135bb5bffc8.jpg" alt></p><blockquote><p><strong>一 特性:</strong></p><ol><li>计算资源共享</li><li>高性能队列</li><li>避免伪共享 (Disruptor也有类似的实现, 采用补位对齐缓存行)它的实现是使用了<code>@sun.misc.Contended</code>jdk8的注解</li><li>工作窃取机制 (特有)<strong>二 对比ThreadPoolExecutor</strong></li><li>线程池ThreadPoolExecutor公用任务队列, ForkJoinPool则每个线程单独一个任务队列</li><li>线程池支持Runnable/Callable两种类型的任务, 同理ForkJoinPool也支持带返回值/不带返回值的任务<code>RecursiveTask(带返回值) / RecursiveAction(不带返回值)</code><strong>三 对应关系</strong></li><li><code>ThreadPoolExecutor --&gt; Thread --&gt; Runnable/Callable</code></li><li><code>ForkJoinPool --&gt; ForkJoinWorkerThread --&gt; RecursiveAction/RecursiveTask</code>注意不是为了替代ExecutorService, 而仅仅作为补充, 比如补充了<code>work-stealing</code>逻辑<strong>四 工作窃取(work stealing)</strong><font color="red">1. 因为任务队列是进行了拆分 (拆到什么粒度需要我们指定拆分的临界值), 即线程会各自独享一个子任务队列;</font></li></ol></blockquote><ol start="2"><li>当其中线程A先执行完毕, 线程B还未执行完, 则A会从B偷取一个任务;</li><li>如何偷? 拆分的线程子任务队列是一个线程安全的双端队列, 被窃取线程永远从头部取, 窃取线程永远从队尾取, 避免并发导致的竞争, 但是只有一个任务的极端情况还是无法避免竞争</li></ol><blockquote><p><strong>五 优缺点</strong>优点: 类似单机版本的MapReduce归并计算, 比线程池更加充分利用CPU资源缺点: 编码复杂, 而且需要大量队列, 线程…的创建与销毁, 导致效率无法明显的提升, 貌似Netty5.0就是基于此原因之一放弃发布<strong>六 注意事项</strong><font color="red">1. ForkJoinPool 也有submit, execute, 同时多了一个invoke<strong>非阻塞:</strong>execute不带返回值, submit带返回值, 这和ThreadPoolExecutor类似submit返回了Future的子类ForkJoinTask, 调用task.get()才会阻塞<strong>阻塞:</strong>invoke会阻塞调用线程 (主线程), 直到有结果并返回</font></p></blockquote><ol start="2"><li>fork是分配任务<code>leftTask.fork(); rightTask.fork();</code>替换为<code>invokeAll(leftTask, rightTask);</code>使用fork, 假如程数量固定, 当前线程会将leftTask/rightTask分配下去,自身并不会做任何事情, 会浪费一个线程</li></ol><p>示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinCalcTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long start;<span class="comment">//起始值</span></span><br><span class="line">    <span class="keyword">private</span> Long end;<span class="comment">//结束值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Long critical = <span class="number">100000L</span>;<span class="comment">//临界值10w (即划分的区间段大小)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinCalcTask</span><span class="params">(Long start, Long end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否是拆分完毕</span></span><br><span class="line">        Long lenth = end - start;</span><br><span class="line">        <span class="keyword">if</span> (lenth &lt;= critical) &#123;</span><br><span class="line">            <span class="comment">//如果拆分完毕就相加</span></span><br><span class="line">            Long sum = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span> (Long i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//没有拆分完毕就开始拆分 (递归拆分的意思)</span></span><br><span class="line">            Long middle = (end + start) / <span class="number">2</span>;<span class="comment">//计算的两个值的中间值</span></span><br><span class="line">            ForkJoinCalcTask leftTask = <span class="keyword">new</span> ForkJoinCalcTask(start, middle);</span><br><span class="line">            ForkJoinCalcTask rightTask = <span class="keyword">new</span> ForkJoinCalcTask(middle + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 方式1</span></span><br><span class="line">            <span class="comment">//right.fork();//拆分，压入线程队列</span></span><br><span class="line">            <span class="comment">//left.fork();//拆分，压入线程队列</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 方式2 更好的做法</span></span><br><span class="line">            <span class="comment">// 方式1的缺点是: 假如程数量固定, 当前线程会将leftTask/rightTask分配下去,</span></span><br><span class="line">            <span class="comment">// 自身并不会做任何事情, 会浪费一个线程</span></span><br><span class="line">            invokeAll(leftTask, rightTask);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待任务执行结束合并其结果</span></span><br><span class="line">            <span class="keyword">return</span> leftTask.join() + rightTask.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ForkJoin实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();<span class="comment">//实现ForkJoin 就必须有ForkJoinPool的支持</span></span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> ForkJoinCalcTask(<span class="number">0L</span>, <span class="number">10000000000L</span>);<span class="comment">//参数为起始值与结束值 (100亿)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意invoke是阻塞方法</span></span><br><span class="line">        <span class="comment">// submit和execute是非阻塞方法, submit是异步的, 返回了ForkJoinTask(继承了Future),</span></span><br><span class="line">        <span class="comment">// 通过Future接口的get可以阻塞获取结果</span></span><br><span class="line">        Long invoke = forkJoinPool.invoke(task); <span class="comment">//压入线程队列</span></span><br><span class="line">        <span class="keyword">long</span> l1 = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"invoke = "</span> + invoke + <span class="string">"  time: "</span> + (l1 - l));</span><br><span class="line">        <span class="comment">//invoke = -5340232216128654848  time: 4661</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通线程实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Long x = <span class="number">0L</span>;</span><br><span class="line">        Long y = <span class="number">10000000000L</span>;</span><br><span class="line">        <span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line">        Long i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0L</span>; i &lt;= y; i++) &#123;</span><br><span class="line">            x += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> l1 = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"invoke = "</span> + x + <span class="string">"  time: "</span> + (l1 - l));</span><br><span class="line">        <span class="comment">//invoke = -5340232216128654848  time: 75901</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Java 8 并行流的实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> reduce = LongStream.rangeClosed(<span class="number">0</span>, <span class="number">10000000000L</span>).parallel().reduce(<span class="number">0</span>, Long::sum);</span><br><span class="line">        <span class="keyword">long</span> l1 = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"invoke = "</span> + reduce + <span class="string">"  time: "</span> + (l1 - l));</span><br><span class="line">        <span class="comment">//invoke = -5340232216128654848  time: 4366</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//test1();</span></span><br><span class="line">        <span class="comment">//test2();</span></span><br><span class="line">        test3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>源码分析</strong>待续…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;知识要点&quot;&gt;知识要点&lt;/h2&gt;
&lt;p&gt;写此篇只记录一些自己觉得比较重要的知识点, 其余查阅之前的篇幅&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;分类&lt;/th&gt;
&lt;th style=&quot;text-al
      
    
    </summary>
    
      <category term="concurrent" scheme="https://doooyo.github.io/categories/concurrent/"/>
    
    
      <category term="锁" scheme="https://doooyo.github.io/tags/%E9%94%81/"/>
    
      <category term="队列" scheme="https://doooyo.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="线程池" scheme="https://doooyo.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
</feed>
