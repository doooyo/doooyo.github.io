<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>N 27°59′′</title>
  
  <subtitle>duyu</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://doooyo.github.io/"/>
  <updated>2019-04-21T16:36:16.321Z</updated>
  <id>https://doooyo.github.io/</id>
  
  <author>
    <name>duyu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线程池</title>
    <link href="https://doooyo.github.io/2019/04/22/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://doooyo.github.io/2019/04/22/线程池/</id>
    <published>2019-04-21T16:36:16.321Z</published>
    <updated>2019-04-21T16:36:16.321Z</updated>
    
    <content type="html"><![CDATA[<p>类图结构<img src="https://upload-images.jianshu.io/upload_images/5401975-04f3cf53fcf41296.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/734/format/webp" alt></p><h2 id="线程池的工作原理">线程池的工作原理</h2><p><img src="http://www.uml.org.cn/j2ee/images/2012121931.jpg" alt></p><p>原理:</p><blockquote><ol><li>判断核心线程(core)是否已满, 没满则创建新线程, 满则步骤2</li><li>判断队列是否已满, 没满则入队, 满则步骤3</li><li>判断线程池(max)是否已满, 没满则继续创建线程, 满则步骤4</li><li>按照拒绝策略拒绝任务</li></ol></blockquote><p>线程池工作具体示意图:<img src="https://pic4.zhimg.com/v2-885830dd498528ca7e277f9d930fcac3_b.jpg" alt></p><hr><h2 id="synchronousqueue队列-补充">SynchronousQueue队列(补充)</h2><p>此队列实现比较复杂, 先看类继承结构和数据结构:<img src="https://upload-images.jianshu.io/upload_images/6050820-5bc09993fe75642d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/698/format/webp" alt></p><blockquote><ol><li>不存储元素的队列, 每一个put操作必须等待一个take操作, 否则不能继续添加元素</li><li>支持公平策略(双重队列-先进先出), 也支持非公平策略(双重栈–先进后出), 默认非公平策略<font color="red">双重Queue/Stack内部实现是单链表</font></li></ol></blockquote><hr><h2 id="线程池的4种类型">线程池的4种类型</h2><ul><li>使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 固定线程数为5的线程池</span></span><br><span class="line">Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 带时间策略调度的线程池</span></span><br><span class="line">Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 线程可缓存的线程池</span></span><br><span class="line">Executors.newCachedThreadPool();</span><br><span class="line"><span class="comment">// 单个线程的线程池</span></span><br><span class="line">Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure><ul><li>内部如何构造</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 固定线程池: 默认线程数为5的线程池, 任务队列无界</span></span><br><span class="line"><span class="comment">// 由于队列无界, 永远不会创建第六个线程, 所以不会触发keepAliveTime</span></span><br><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>,</span><br><span class="line">                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带时间调度的线程池: 由于队列是可扩容二叉堆(数组), 所以无界</span></span><br><span class="line"><span class="comment">// 同理, keepAliveTime是无效的</span></span><br><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>,  Integer.MAX_VALUE,</span><br><span class="line">                <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">                <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个线程池: 线程池只会有一个线程, 其他线程入队等待, 队列默认是无界的</span></span><br><span class="line"><span class="comment">// 如果队列无界, 则同理keepAliveTime是无效</span></span><br><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure><ul><li>四种线程池的概念</li></ul><ol><li><p><code>固定线程池 - Executors.newFixedThreadPool(5)</code>核心线程数 与 最大线程数相等, 同时使用了LinkedBlockingQueue无界队列(默认无界), 所以任务永远不会被拒绝, 同理就永远不会创建多余线程;所以**<font color="red">maximumPoolSize和keepAliveTime将无效, 适合任务并发量少且稳定的情况</font>**</p></li><li><p><code>延时/定时线程池 - Executors.newScheduledThreadPool(5)</code>DelayQueue是基于二叉堆(数组)的可扩容队列(内部封装了一个PriorityQueue), 是基于时间先后排序的, 若time相同则根据sequenceNumber排序; 也即无界队列;<strong><font color="pink">执行效果是: 从队列取已到期的任务去执行, 完毕后重新设置任务到期时间, 再次放回DelayQueue</font></strong>由于队列无界, <strong><font color="red">同理maximumPoolSize和keepAliveTime是无效的, 适合定时或周期性任务, 可用以替代Timer(基于单线程且有并发缺陷)</font></strong></p></li><li><p><code>线程可缓存的线程池 - Executors.newCachedThreadPool()</code>这个比较难以理解, 由于使用了SynchronousQueue同步等待队列, 它没有存储空间, 意味着请求到来就必须找到线程处理, 若没有空闲线程就新创建;注意:3.1 <font color="pink">corePoolSize为0，maximumPoolSize为无限大，意味着线程数量可以无限大</font>3.2 <font color="pink">keepAliveTime为60S，意味着线程空闲时间超过60S就会被杀死; 这里核心线程为0, 意味着所有线程一旦从空闲算起,超时了都会被杀掉</font>3.3 <font color="pink">这是一个理论上可无限扩大的线程池, 没空闲线程就创建, 有则复用, 所以叫可缓存的线程池; 但空闲超时也会销毁, 提高效率 </font>3.4 <font color="orange">SynchronousQueue队列类似一个通道, A线程添加任务, 线程池里的子线程B获取任务执行;(1).若线程池没有可用线程, 则会立刻启动一个线程来执行, 同时生产者线程必须同步等待子线程的创建</font>3.5 <font color="red">它适合耗时小的任务, 因为一旦任务耗时长, 而且任务并发量大(或波峰期)的话会创建大量线程, 任务并发波谷期会频繁GC空闲线程</font></p></li><li><p><code>单线程池 - Executors.newSingleThreadExecutor()</code>只会创建一个核心线程, 同时队列使用了LinkedBlockingQueue无界队列(不填容量默认无界),所以**<font color="red">maximumPoolSize和keepAliveTime将无效; 适合任务量极少的情况, 且由于单线程, 所以没有并发问题注意: Executors.newFixedThreadPool(1) 和 Executors.newSingleThreadExecutor()是等价的</font>**</p></li></ol><p>使用一张图来示意线程池:<img src="https://pic4.zhimg.com/v2-885830dd498528ca7e277f9d930fcac3_b.jpg" alt>参考: <a href="https://www.zhihu.com/question/23212914" target="_blank" rel="noopener">线程池的使用</a></p><hr><h2 id="线程池的重要内容">线程池的重要内容</h2><ul><li><p><code>空闲过期时间 keepAliveTime</code>这个上面已经讲述过, 这个和使用的队列有界无界息息相关队列无界, 则无效队列有界, 则和最大线程数maximumPoolSize有关</p></li><li><p><code>线程组 ThreadGroup</code>多线程机制是由java虚拟机支持的, 目的是通过组的概念批量管理线程;它是树形结构:所以创建线程可以继承父线程组的优先级, 是否Daemon守护线程, 有唯一根节点祖先线程组; 数组初始化为4, 2倍速扩容本质目的是为了方便管理<img src="https://img-blog.csdn.net/20181012162426786?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hzaHFpYW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p></li><li><p><code>线程工厂接口 ThreadFactory</code>位于Executors工具类</p></li></ul><ol><li>DefaultThreadFactory(默认线程工厂)线程名遵循<code>pool-{index}-thread-</code>不继承父线程组的daemon, priority属性, 即默认创建非守护线程,同时优先级为普通</li><li>PrivilegedThreadFactory<font color="red">通过这种方式创建出来的线程，将与创建privilegedThreadFactory的线程拥有相同的访问权限、 AccessControlContext、ContextClassLoader。如果不使用privilegedThreadFactory， 线程池创建的线程将从在需要新线程时调用execute或submit的客户程序中继承访问权限</font></li><li>可以自己实现ThreadFactory接口来定制自己的线程工厂方法这里可以自定义线程池如何创建线程, 比如自定义的Thread类甚至可以在线程里加入业务逻辑, 比如日志统计</li></ol><ul><li><strong>拒绝策略</strong>都继承自<code>RejectedExecutionHandler</code>接口</li></ul><blockquote><ol><li><code>AbortPolicy</code>: 直接抛出异常, 这是JDK默认策略</li><li><code>CallerRunsPolicy</code>: 如果线程池没有Shutdown, 则由提交任务的线程主动执行这个任务;<font color="pink">意味着这是同步阻塞执行的;意味着阻(延)塞(缓)新任务的提交意味着不想丢弃任何一个任务</font></li></ol></blockquote><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">        r.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><blockquote><ol start="3"><li><code>DiscardPolicy</code>: 是一个空实现, 意思是丢弃当前任务</li><li><code>DiscardOldestPolicy</code>: 丢弃队头的任务(最老/旧)<font color="pink">这种拒绝策略要非常小心, 因为一旦任务提交过快, 会连续的丢掉最早(旧)的任务, 如果任务无关紧要则无所谓</font></li></ol></blockquote><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!e.isShutdown()) &#123; <span class="comment">// 如果线程池没有Shutdown</span></span><br><span class="line">        e.getQueue().poll(); <span class="comment">// 出(丢)队(弃)</span></span><br><span class="line">        e.execute(r); <span class="comment">// 提交当前任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li>继承重写ThreadPoolExecutor类的beforeExecute, afterExecute, terminated等钩子方法这个主要用于日志统计, 运行时间之类的, 比如netty内部重写线程池</li></ul><blockquote><ol><li>beforeExecute:任务执行前 (抛出运行时异常, afterExecute不会被执行)</li><li>afterExecute任务执行后</li><li>terminated当线程池在关闭的时候<font color="pink">注意重写钩子方法后, 里面的参数必须是ThreadLocal或者同步的, 毕竟每个线程的变量不能互相影响</font></li></ol></blockquote><ul><li>如何设置核心线程数, 最大线程数</li></ul><blockquote><ol><li>通常情况下, corePoolSize设置为CPU核数的1倍, maximumPoolSize设置为CPU核数的两倍</li><li>理论上的计算可以根据下面几个维度来衡量2.1 每秒任务数量2.2 每个任务执行时间2.3 容忍每个任务从提交到开始执行的最大响应时间从上面的维度可以很容易算出<code>核心线程数, 最大线程数, 队列容量</code>参考: <a href="https://www.cnblogs.com/waytobestcoder/p/5323130.html" target="_blank" rel="noopener">ThreadPoolExecutor线程池参数设置技巧</a></li></ol></blockquote><hr><h2 id="future-callable">Future/Callable</h2><p>通过下面的接口概览, 可以看出Future和Callable是配对使用的本质是将主调线程阻塞, 等待子任务执行完毕得到结果</p><ul><li>Callable</li></ul><p>下面接口预览可以看到call()是带返回值的</p><ul><li>FutureTask概念</li></ul><p>它是Future接口的唯一实现, 同时它还实现了Runnable接口再来看构造函数:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><font color="pink">第一个构造函数是对Callable的包装第二个构造函数是为了兼容之前的Runnable, 使用适配器模式使之拥有Future的特性 (可以查阅<code>Executors</code>内部的<code>RunnableAdapter</code>适配器类)</font></p><ul><li>Future接口解析</li></ul><p>重点说明一下cancel, isCancelled, isDone, 其余请查阅下面的接口概览</p><blockquote><ol><li><code>cancel(mayInterruptIfRunning)</code>如果任务执行完毕, 则肯定是返回false;如果还未执行, 则肯定是返回true如果正在执行中则和参数有关系, 参数是true则返回true, 是false则返回false(注意cancel只是发出了中断, 无法确保线程真正退出)</li><li><code>isCancelled</code>CANCELLED, INTERRUPTING, INTERRUPTED都认为是取消状态</li><li><code>isDone</code>state != NEW, 即任务执行后的任意状态都认为是已完成</li></ol></blockquote><ul><li>FutureTask源码解析</li></ul><p>1.state状态机:内部维护了Task的任务四种状态迁移, 初始状态为NEW</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; NORMAL 正常的状态转移</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL 异常</span></span><br><span class="line"><span class="comment"> * NEW -&gt; CANCELLED 取消</span></span><br><span class="line"><span class="comment"> * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED 中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>2.run</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果当前不是new状态，或者当前cas设置当前线程失败则返回，只有一个线程可以成功。</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//当前状态为new 则调用任务的call方法执行任务</span></span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                setException(ex);完成NEW -&gt; COMPLETING -&gt; EXCEPTIONAL 状态转移</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//执行任务成功则保存结果更新状态，unpark所有等待线程</span></span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//状态从new-&gt;COMPLETING</span></span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = v;</span><br><span class="line">        <span class="comment">//状态从COMPLETING-》NORMAL</span></span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line">        <span class="comment">//unpark所有等待线程。</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = t;</span><br><span class="line">        <span class="comment">//设置为异常状态</span></span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, EXCEPTIONAL);</span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.cancel只有NEW才可取消, 这里比较难以理解; 因为一旦为其他状态, 则是正在执行中, 或者已完毕(异常/中断/已取消);“只有NEW才可取消”这句话表示未执行的任务永远返回true已完成的则永远返回false(异常/中断/已取消)<font color="red">注意: 状态机的状态是终态, 它无法表示过程COMPLETING在这里只是瞬态, 可以直接认为: NEW-&gt;NORMAL, NEW-&gt;EXCEPTIONALrun方法没有一进入就设置为COMPLETING, 而是真正完成后作为一个瞬态出现</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//只有任务是new的才能取消</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   <span class="comment">//运行时允许中断</span></span><br><span class="line">    <span class="keyword">if</span> (mayInterruptIfRunning) &#123;</span><br><span class="line">       <span class="comment">//完成new-&gt;INTERRUPTING</span></span><br><span class="line">        <span class="keyword">if</span> (!UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, INTERRUPTING))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Thread t = runner;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">            t.interrupt();</span><br><span class="line">        <span class="comment">//完成INTERRUPTING-&gt;INTERRUPTED</span></span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, INTERRUPTED); <span class="comment">// final state</span></span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//不允许中断则直接new-&gt;CANCELLED</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, CANCELLED))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    finishCompletion();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考: <a href="https://www.jianshu.com/p/49541d720d5b" target="_blank" rel="noopener">FutureTask 原理</a></p><hr><h2 id="threadpoolexecutor源码解析">ThreadPoolExecutor源码解析</h2><p>参考: <a href="https://www.zhihu.com/search?type=content&amp;q=PrivilegedThreadFactory" target="_blank" rel="noopener">ThreadPoolExecutor源码解析</a></p><ul><li>池</li></ul><hr><h2 id="接口概览">接口概览</h2><p><strong><code>Runable任务接口, 无返回值的任务</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>Callable任务接口, 可携带返回值的任务</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>Future接口</code></strong><font color="pink">对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function">V <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">     <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里进行接口说明</p><blockquote><ol><li><code>boolean cancel(boolean mayInterruptIfRunning)</code>cancel取消任务; 取消成功返回true, 失败返回false;mayInterruptIfRunning 表示是否取消正在执行中的任务<font color="pink">意思是如果任务执行完毕(取消/异常都算完成), 则肯定是返回false;如果还未执行, 则肯定是返回true如果正在执行中则和参数有关系, 参数是true则返回true, 是false则返回false</font><font color="red">注意: 正在执行的任务就算允许被取消, 返回了true, 只是保证发送了中断信号(thread.interrupt), 但是发送了中断信号却不一定能触发线程的中断异常 (因为只有在线程处于阻塞态才会触发中断异常, 即wait/join/sleep/远程或本地IO(也即数据库,文件,RPC…));<strong>所以cancle(true)正在执行的线程, 线程不保证一定能退出(参考线程优雅退出的两种方式)</strong></font></li><li><code>boolean isCancelled()</code>表示任务是否被取消成功<font color="red">和上面一样, 返回true不保证线程真正退出</font></li><li><code>boolean isDone()</code>表示任务是否已经完成<font color="red">包括正常完毕/执行异常/任务取消, 都认为完成; 同上一样, cancle取消的任务不一定真正的退出了</font></li><li><code>V get()</code>用于获取执行结果, 但会阻塞主调方线程(一般是主线程), 直到任务执行完毕并得到结果返回后才会唤醒主线程(暂且认为是主线程, 方便理解)<font color="red">当前状态是new或者COMPLETING则等待, 其他状态甚至异常状态都认为结束, 且只有NORMAL/EXCEPTIONAL两种可以获取值, 其他都会抛出异常</font></li><li><code>V get(long timeout, TimeUnit unit)</code>同上, 只是指定了过期时间, 过期还未拿到结果就返回null</li></ol></blockquote><p><strong><code>1. Executor接口, 运行无返回值的新任务</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>2. ExecutorService接口</code></strong>增加了管理「执行器生命周期」,「任务生命周期」的方法</p><blockquote><ol><li><code>shutdown/shutdownNow/awaitTermination</code><code>shutdown</code>: 置为SHUTDOWN; 停止接收外部commit的任务; 直到队列里任务执行完毕才停止<code>shutdownNow</code>: 同上, 只是不再接收任务, 而且还会尝试中断正在执行的线程 (但是如果线程未被sleep/wait/join…阻塞,则不会产生中断异常), 所以也有可能不会立即停止, 最后返回未执行的任务列表<code>awaitTermination</code>: 阻塞主线程, 超时后会检测线程池是否<code>Terminated</code>状态, 如果不是则返回false</li><li><code>isShutdown/isTerminated</code><code>Shutdown</code>是主动关闭后都是此状态;<code>Terminated</code>是等所有任务都执行完毕后才是此状态</li><li><code>submit/execute</code>submit: 允许提交Runnable/Callable任务execute: 实现于Executor接口, 只能提交Runnable任务</li><li><code>Callable/Runnable</code>Callable允许返回结果, 且可抛出异常;Runnable更像沙箱, 内部错误无法向外抛, 无返回值;Callable若要获得返回值, 调用<code>FutureTask.get()</code>, 此方法会阻塞主线程直到任务结束并返回结果</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池执行器相关的管理接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//线程池状态SHUTDOWN,停止接收外部commit的任务;直到队列里任务执行完毕, 停止所有线程(优雅停止)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//同上;只是会忽略队列里等待的任务, 甚至会interrupt尝试中断正在执行的线程(但是如果线程未被sleep/wait/join...阻塞,则不会产生中断异常),则必须等待当前正在执行的任务执行完毕, 也可能不会立即停止; 最后返回未执行的任务列表 (尝试强制停止)</span></span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 阻塞主线程指定时间, 超时后检测线程池是否Terminated(即所有任务执行完毕), 并返回布尔值 (一般用于检查是否执行完任务)</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">// shutdown标记(主动shutdown/shutdownNow都会为true)</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 任务全部执行完毕才会Terminated=true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单任务的提交, 可提交Runnable/Callable, 即是否有返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">    <span class="comment">// 如果想要返回值, 则必须是FutureTask(实现了RunableFuture两个接口的功能)</span></span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量任务的提交, 只支持Callable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="keyword">long</span> timeout, TimeUnit unit) <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>3. ScheduledExecutorService接口</code></strong>支持了<code>Future</code>和定时器</p><blockquote><ol><li>支持指定时延后执行任务, 可以是Runnable/Callable</li><li>支持指定时间间隔定期执行任务;  定时器是在一个子线程执行任务, 此处是线程池执行, 可以避免并发问题</li><li>回顾定时器</li></ol></blockquote><blockquote><ol start="4"><li>注意事项:</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ScheduledExecutorService</span> <span class="keyword">extends</span> <span class="title">ExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="keyword">long</span> delay, TimeUnit unit);</span><br><span class="line">    <span class="keyword">public</span> &lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable, <span class="keyword">long</span> delay, TimeUnit unit)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period, TimeUnit unit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> delay, TimeUnit unit);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;类图结构
&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5401975-04f3cf53fcf41296.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>线程安全集合，数据结构</title>
    <link href="https://doooyo.github.io/2019/04/22/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://doooyo.github.io/2019/04/22/线程安全集合，数据结构/</id>
    <published>2019-04-21T16:36:16.317Z</published>
    <updated>2019-04-21T16:36:16.317Z</updated>
    
    <content type="html"><![CDATA[<p>因为讲数据集合容器就必须涉及数据结构, 以及查找算法, 排序算法; 所以这里就一起讲述了。</p><blockquote><ol><li><strong><code>HashMap/ConcurrentHashMap</code></strong>链表与红黑树的转化, Segment分段锁(和LongAdder类似)</li><li><strong><code>CopyOnWriteArrayList/CopyOnWriteMap/CopyOnWriteArraySet</code></strong>2.1 fail-fast机制的解决方案; 某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常2.2 适用场景为多读少写的集合, 且能容忍脏读(无业务影响); 比如黑白名单,注册中心,商品类目2.3 由于每次add都会进行一次数组复制并扩容一位, 所以尽量避免使用addAll</li><li><strong>阻塞队列</strong><font color="pink">生产消费模型的典型场景就是线程池add/remove: 是Collection接口的方法 (队列已空/满会抛异常)offer/poll : 是Queue接口方法 (队列已空/满会返回false)put/take: 是BlockingQueue接口方法, 空/满会各自阻塞</font><code>ArrayBlockingQueue</code>: 由数组支持的有界队列(单锁), 类似循环队列, 与Buffer或者ByteBuf类似<code>LinkedBlockingQueue</code>: 由链接节点支持的可选有界队列(双锁)<code>PriorityBlockingQueue</code>: 带优先级的无界有序阻塞队列, 由数组二叉排序树(堆)支持的无界优先级队列(完全二叉树)<code>DelayQueue</code>: 由优先级二叉排序树(堆)支持的、基于时间的调度队列(延期阻塞无界队列), 时间到了就会移动到队头并唤醒阻塞的线程来执行任务; 由于它是可扩容的, 所以无界添加或删除需要排序, siftUp(插入排序)/siftDown(删除排序)<code>SynchronousQueue</code>: 并发同步队列, 类似管道pipeline; 这是最复杂的队列, 它不存储数据参考: <a href="https://www.jianshu.com/p/587901245c95" target="_blank" rel="noopener">DelayedWorkQueue原理分析</a></li><li><strong>跳表</strong>本质是一个链表, 使用&quot;<code>先大步查找确定范围，再逐渐缩小迫近</code>&quot;的思想, 效率和二叉排序树(红黑树/VAL)差不多, 和B+树一样, 有Level个索引层级<a href="https://www.cnblogs.com/a8457013/p/8251967.html" target="_blank" rel="noopener">SkipList跳表基本原理</a><font color="pink">完全二叉树: HashMap使用数组+单链表, 索引位置通过hash取模得到, 所以无序; 我们通常将TreeMap/ConcurrentHashMap/ConcurrentSkipListMap三者进行比较;ConcurrentHashMap: 无序,且TreeMap: 使用红黑树,所以有序(可指定排序器), 但线程不安全ConcurrentSkipListMap: 使用跳表(本质是链表,使用跳跃式查找,空间换时间O(logn))</font><code>ConcurrentSkipListMap</code><code>ConcurrentSkipListSet</code></li><li><strong><font color="orange">Amino无锁并行框架</font></strong>提供免锁集合,基于CAS<code>LockFreeVector</code><code>LockFreeList</code>/<code>LockFreeOrderedList</code>/<code>LockFreeSet</code><code>LockFreeBlockQueue</code>/<code>LockFreeDeque</code>/<code>LockFreePriorityQueue</code><code>LockFreeDictionary</code><code>树 / 图</code>同时提供并行计算模式<code>Master-Worker</code>、<code>Map-reduce</code>、<code>Divide and conquer</code>, <code>Pipeline</code></li><li><strong><font color="orange">JCTools map/queue增强</font></strong>主要提供了map以及queue的增强数据结构;原来netty还是自己写的MpscLinkedQueueNode, 后来新版本就换成使用JCTools的增强并发队列6.1 增强Map:<code>ConcurrentAutoTable(后面几个map/set结构的基础)</code><code>NonBlockingHashMap</code><code>NonBlockingHashMapLong</code><code>NonBlockingHashSet</code><code>NonBlockingIdentityHashMap</code><code>NonBlockingSetInt</code>6.2 增强队列:SPSC - 单生产者/单消费者 (Wait Free, bounded and unbounded)MPSC - 多生产者/单消费者 (Lock less, bounded and unbounded)SPMC - 单生产者/多消费者 (Lock less, bounded)MPMC - 多生产者/多消费者 (Lock less, bounded)</li><li><strong>TreeMap</strong><font color="pink">由于链表LinkedList是基于链表,是乱序的, TreeMap使用堆(完全二叉树), 但是添加节点有rebalance操作, 对高并发效率很低, 同时没选择VAL也是折中的表现, 后面会对比; 所以才有上面的跳表出现;java的实现类似链表, 只是Entry&lt;K,V&gt;内部有三个引用 (parent/left/right), 操作有: 着色/左旋/右旋</font><font color="#FF2400">7.1 满二叉树:<code>度为2, 且达到最满</code>7.2 完全二叉树:<code>比完全二叉树'弱'一点, 允许最后一层不满, 且左边一定连续集中; 它是一种效率很高的数据结构, 迪杰斯特拉,普里姆算法,二叉排序树等 都使用了此结构; 堆就是一种完全二叉树, 但不是二叉排序树</code>7.3 二叉排序树:<code>所有节点遵循左中右依次增大, 且没有键值相等的节点 中序遍历即可得到有序数列, 高度决定查找效率O(logn) 在有序(中序遍历)情况下会退化为链表O(n)</code>7.4 平衡二叉树-VAL:<code>二叉排序树删除节点会导致树向左偏沉, 破坏类完全二叉树的平衡性; 所以引出平衡二叉树(自旋)</code>7.5 平衡二叉树-红黑树:<code>类似VAL平衡二叉排序树, 但它不是严格的高度平衡树; VAL查询更稳定, 红黑树插入/删除更稳定;</code>7.6 2-3树/2-3-4树/B树/B+树/B*树:<code>和平衡二叉树不一样, 它们度允许大于2, 可称之为多路查找树 2-3树要么有2个子节点, 要么有3个子节点, 2-3-4树同理; 多路查找树可以在常数次找到目标(依赖树高度), 比如对于10亿个节点的2-3树，树的高度为18-30之间; 问题在于查找到后的插入和删除会导致自平衡的代价极高, 所以才有红黑树来折中 B+树,因为比较'规整', 非叶子节点为稀疏索引, 叶子节点存储值, 叶子节点有链表指针, 非常适合文件索引系统 B*树为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3, 其实就是节省空间</code><a href="https://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html" target="_blank" rel="noopener">平衡查找树之2-3树</a><a href="https://www.cnblogs.com/vincently/p/4526560.html" target="_blank" rel="noopener">B树与B+树</a><a href="https://blog.csdn.net/u013411246/article/details/81088914" target="_blank" rel="noopener">B树、B-树、B+树、B*树之间的关系</a><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a>7.7 字典树(Trie):7.6 哈夫曼树: 带权路径长度最短的树(最优)7.7 深度遍历(前序/中序/后序):<code>树的定义本身就是递归定义,所以使用递归算法实现更易于理解 前序遍历：根结点 ---&gt; 左子树 ---&gt; 右子树 中序遍历：左子树---&gt; 根结点 ---&gt; 右子树 (二叉排序树) 后序遍历：左子树 ---&gt; 右子树 ---&gt; 根结点</code>7.8 广度遍历(层次遍历):<code>从上往下, 从左到右</code>7.9 堆<code>堆是完全二叉树, 但不是二叉排序树; 因为它不遵循左&lt;父&lt;右 它遵循的是左&lt;父, 父&gt;右, 所以小值在下, 大值在上, 查找效率低(因为不知道从左节点开始查找还是从右节点开始) 一般使用数组来实现, 由于是完全二叉树, 所以不存在数组空间的浪费</code>7.10 应用<code>d</code></font></li></ol></blockquote><hr><h2 id="tree-查找算法-排序算法概念">Tree, 查找算法, 排序算法概念</h2><h3 id="二叉堆">二叉堆</h3><ul><li>特性</li></ul><blockquote><ol><li>是完全二叉树, 即除了最后一层节点不是满的, 其他层节点都是满的</li><li>它不是二叉搜索树, 它要求父节点的值不能小于子节点的值, 所以堆遍历和查找都比较低效, 平均O(n)</li><li>它可以实现快速的插入和删除, 效率都在(logN)左右; 所以它可以实现优先级队列</li><li><font color="pink">堆是为了排序而设计的数据结构 [查找:<strong>O(n)</strong>, 插入删除:<strong>O(logN)</strong>]二叉排序树是面向动态查找的数据结构 [查找:<strong>O(logN)</strong>, 插入删除: <strong>需要额外的旋转进行自平衡</strong>]</font></li></ol></blockquote><ul><li>堆的操作</li></ul><p>堆主要就是插入和删除, 前提是:</p><ol><li>是完全二叉树</li><li>父节点的值不能小于子节点的值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于n位置的节点来说：</span></span><br><span class="line"><span class="keyword">int</span> left = <span class="number">2</span> * n + <span class="number">1</span>; <span class="comment">// 左子节点</span></span><br><span class="line"><span class="keyword">int</span> right = <span class="number">2</span> * n + <span class="number">2</span>; <span class="comment">// 右子节点</span></span><br><span class="line"><span class="keyword">int</span> parent = (n - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 父节点，当然n要大于0，根节点是没有父节点的</span></span><br></pre></td></tr></table></figure><p>插入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 第一步将插入的值，直接放在最后一个位置。并将长度加一</span></span><br><span class="line">     store[size++] = value;</span><br><span class="line">     <span class="comment">// 得到新插入值所在位置。</span></span><br><span class="line">     <span class="keyword">int</span> index = size - <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">while</span>(index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// 它的父节点位置坐标(index - 1) / 2</span></span><br><span class="line">         <span class="keyword">int</span> parentIndex = (index - <span class="number">1</span>)&gt;&gt;&gt;<span class="number">2</span>;</span><br><span class="line">         <span class="comment">// 如果父节点的值小于子节点的值，你不满足堆的条件，那么就交换值</span></span><br><span class="line">         <span class="keyword">if</span> (store[index] &gt; store[parentIndex]) &#123;</span><br><span class="line">             swap(store, index, parentIndex);</span><br><span class="line">             index = parentIndex;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">// 否则表示这条路径上的值已经满足降序，跳出循环</span></span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 将根的值记录，最后返回</span></span><br><span class="line">      <span class="keyword">int</span> result = store[<span class="number">0</span>];</span><br><span class="line">      <span class="comment">// 将最后位置的值放到根节点位置</span></span><br><span class="line">      store[<span class="number">0</span>] = store[--size];</span><br><span class="line">      <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 通过循环，保证父节点的值不能小于子节点。</span></span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">          <span class="keyword">int</span> leftIndex = index&lt;&lt;<span class="number">1</span> + <span class="number">1</span>; <span class="comment">// 左子节点</span></span><br><span class="line">          <span class="keyword">int</span> rightIndex = index&lt;&lt;<span class="number">1</span> + <span class="number">2</span>; <span class="comment">// 右子节点</span></span><br><span class="line">          <span class="comment">// leftIndex &gt;= size 表示这个子节点还没有值。</span></span><br><span class="line">          <span class="keyword">if</span> (leftIndex &gt;= size) <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">int</span> maxIndex = leftIndex;</span><br><span class="line">          <span class="keyword">if</span> (store[leftIndex] &lt; store[rightIndex]) maxIndex = rightIndex;</span><br><span class="line">          <span class="keyword">if</span> (store[index] &lt; store[maxIndex]) &#123;</span><br><span class="line">              swap(store, index, maxIndex);</span><br><span class="line">              index = maxIndex;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="skiplist跳表">SkipList跳表</h3><p>其实RB-tree的性能和SkipList相差无几, 但是在并发环境就不同了;红黑树有一个自平衡(rebalance)过程, 涉及节点较多, 所以竞争锁的代价较高(当然还是比VAL要好, 因为删除节点波及的范围可能会更大);<strong>skiplist的操作显然更加局部性一些，锁需要盯住的节点更少</strong></p><p>核心思想如下图:主要是思想就是提取一些节点作为索引, <strong>“先大步查找确定范围，再逐渐缩小迫近”</strong><img src="http://s14.sinaimg.cn/middle/72995dcc07ad698ab8d8d&amp;690" alt>从上图可以看出, 跳表具有如下性质:</p><blockquote><ol><li>由很多层结构组成</li><li>每一层都是一个有序的链表</li><li>最底层(Level 1)的链表包含所有元素</li><li>如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现。</li><li>每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。</li></ol></blockquote><p>来看看查找过程:<img src="http://s9.sinaimg.cn/middle/72995dcc4cc61f6bff808&amp;690" alt></p><p>插入很简单, 主要是要决定元素要占据的(索引)层K, 需要完全随机采用丢硬币的形式，这里就不讲述, 可参考: <a href="https://www.cnblogs.com/a8457013/p/8251967.html" target="_blank" rel="noopener">SkipList跳表基本原理</a></p><h3 id="二叉排序树">二叉排序树</h3><p>它不是完全二叉树, 但它满足中序遍历(<code>左-&gt;根-&gt;右</code>)结果是排好序的</p><blockquote><p><font color="purple">插入:插入顺序不同, 树结构是不一样的, 但中序遍历结果一样</font></p></blockquote><ol><li>树为空, 则插入root根节点</li><li>小于根节点, 则插入左子树</li><li>大于根节点, 则插入右子树</li></ol><blockquote><p><font color="purple">删除: </font></p></blockquote><ol><li>为叶子节点, 直接删除</li><li>为单支节点, 和单链表类似, parent.next = node.next; 即node的父节点指向node的子节点, 同时断开node的引用并删除</li><li>左右子节点均不空, 将中序遍历的后继节点移动并覆盖掉需要被移除的节点, 因为其特性导致后继节点肯定没有左子树, 所以移动后继节点后可参考步骤2; 如下图</li></ol><blockquote><p><font color="purple">特点:</font></p></blockquote><ol><li>因为删除操作移动右子树, 右节点减少从而导致树偏左沉, 使之成为非完全二叉树(平衡性被破坏), 引出了平衡二叉树VAL(自平衡-旋转)</li><li>二叉排序树查找的时间复杂度为O(log2n), 极端情况下, 比如是插入是有序的(中序), 则会退化为链表O(n), 也即树高度为n, 需要递归查询n次;  所以通常随机化建立二叉树排序树</li></ol><p>二叉排序树删除节点 (左右子节点不为空)<img src="http://jbcdn2.b0.upaiyun.com/2017/07/2c51f44d9bfb87f38f9bf040552b6b31.png" alt></p><p>参考:<a href="http://blog.jobbole.com/111680/" target="_blank" rel="noopener">数据结构中各种树</a></p><h3 id="平衡二叉树-val">平衡二叉树-VAL</h3><p>查找效率: O(1) &gt; O(logn) &gt; O(n) &gt; O(n^2)</p><p><font color="purple">1. 首先, 平衡二叉树类似完全二叉树, 只是不一定满足叶子节点左边连续, 但是高度差最大还是1; 所以叫高度平衡树</font></p><ol start="2"><li>其次, VAL和红黑树添加时都至多2次旋转, 但是删除则不同。 VAL在极端情况下需要维护从被删node到root这条路径上所有node的平衡性, 因此需要旋转的量级O(logN), 即树高; 红黑树至多3次旋转</li><li>再者, 红黑树不是绝对的高度相差1, 但保证基本是高度平衡树, 所以查询效率可能略低于VAL, 但几乎可以忽略不计</li><li>最后, VAL是高度平衡树, 插入删除更易引起自平衡rebalance, 所以红黑树适合增删频繁, VAL更适合不变的数据查询。但是查询的那点效率损耗和频繁插入删除比起来不在一个量级, 所以计算机领域基本都使用红黑树作为数据结构</li></ol><blockquote><ol><li>优点:二叉排序树每次增删节点都会进行自旋进行重新平衡, 所以O(n)退化为链表的极端情况永远不会发生</li><li>缺点:频繁的自平衡(旋转)会浪费一定时间, VAL是高度平衡树</li></ol></blockquote><p>一. 旋转操作, 首先需要知道不平衡的四种姿态</p><blockquote><ol><li>左左/右右: 进行单旋转 (LL / RR)</li><li>左右/右左: 进行双旋转 (RR-&gt;LL / LL-&gt;RR)</li></ol></blockquote><p><img src="http://jbcdn2.b0.upaiyun.com/2017/07/bbc1d195a4adf1a9cc10bb85b0f1c2c6.jpg" alt></p><p>二. LL单旋转操作(RR单旋转同理)只需要旋转一次, 可以用一种平衡玩具来联想<img src="http://jbcdn2.b0.upaiyun.com/2017/07/61ee0c83b3783cb05eac2ed3528eae3b.jpg" alt></p><p>三. LR双旋转操作(RL双旋转同理)<font color="purple">即需要把子树先给&quot;掰&quot;成向一个方向&quot;沉&quot;, 统一方向后再向另外一个方向整体&quot;掰&quot;先左子树K1进行RR旋转, 再K2进行LL旋转</font></p><p><img src="http://jbcdn2.b0.upaiyun.com/2017/07/2ad609dadbff982036a8e32c792436d7.jpg" alt></p><h3 id="平衡二叉树-红黑树">平衡二叉树-红黑树</h3><p><font color="purple">它是计算机科学中用到的一种数据结构, 和VAL树一样保证最坏都是O(logn), 上面已经讲述了VAL和红黑树的对比</font></p><blockquote><ol><li>节点是红色或黑色</li><li>根是黑色</li><li>所有叶子都是黑色</li><li>每个红色节点必须有两个黑色的子节点</li><li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点 (保证最长路径不超过最短路径的2倍, 而且每条路径的黑色个数&gt; h/2)</li></ol></blockquote><p><strong>插入步骤</strong></p><blockquote><ol><li>将红黑树当作一颗二叉查找树, 将节点插入</li><li>将插入节点着色为红色<font color="pink">注意插入节点必须为红色, 为黑色会违背性质5; 但是添加红色节点后，可能会导致出现两个连续红色节点的冲突, 那么可以通过颜色调换（color flips）和树旋转来调整</font></li><li>通过旋转和重新着色等方法来修正该树,旋转分为左旋/右旋</li></ol><blockquote><ol><li>空树; 则插入的是根节点, 直接涂为黑色</li><li>被插入节点父节点为黑色; 符合红黑树</li><li>被插入节点父节点与叔父节点为红色, 违反性质4; 此时需要递归变色, 但无须旋转</li><li>被插入节点父节点红色, 叔父节点黑色(或缺少), 且是其父节点的左子节点, 而父节点又是其祖父节点的左子节点; 此时需要旋转;</li><li>被插入节点父节点红色, 叔父节点黑色(或缺少), 且是其父节点的右子节点, 而父节点又是其祖父节点的左子节点</li></ol></blockquote></blockquote><p>插入-情形3<img src="http://jbcdn2.b0.upaiyun.com/2017/07/dc3747336812e9055f958c56ade89eb8.png" alt>插入-情形4<img src="http://jbcdn2.b0.upaiyun.com/2017/07/4986c959603100e41cba2669d9e3ce0c.png" alt>插入-情形5<img src="http://jbcdn2.b0.upaiyun.com/2017/07/9cfbf62dfdefe5891347de95a976758f.png" alt></p><p><strong>旋转步骤</strong>参考:<a href="http://blog.jobbole.com/111680" target="_blank" rel="noopener">数据结构中各种树</a><a href="https://www.cnblogs.com/chenssy/p/3746600.html" target="_blank" rel="noopener">TreeMap</a></p><h3 id="b树">B树</h3><p>待续</p><h3 id="b-树">B+树</h3><p>待续</p><h3 id="b-树-v2">B*树</h3><p>待续</p><h3 id="tire字典树">Tire字典树</h3><h3 id="哈夫曼树">哈夫曼树</h3><hr><h2 id="数据容器的实现">数据容器的实现</h2><h3 id="hashmap">HashMap</h3><p>主要采用拉链法, 每个数组元素为Entry单链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始容量为16, 即数组长度为16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 数组最大长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 填充因子, 因为数组不允许装满, 否则冲突概率很大, 0.75是实验出来的最好填充因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 链表长度过大, 会造成查找链表节点效率低下, 所以限制链表长度为8, 超过则转化为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 链表长度低于6, 红黑树又退化为链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// 转为红黑树前的第二重判断条件, 同时键值对数量超过64才允许转化红黑树, 避免hash函数不合理造成初期就会转化为树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure><h3 id="concurrenthashmap">ConcurrentHashMap</h3><p>待续…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为讲数据集合容器就必须涉及数据结构, 以及查找算法, 排序算法; 所以这里就一起讲述了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;HashMap/ConcurrentHashMap&lt;/code&gt;&lt;/strong&gt;
链表与红黑树的转化
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>字节码</title>
    <link href="https://doooyo.github.io/2019/04/22/%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    <id>https://doooyo.github.io/2019/04/22/字节码/</id>
    <published>2019-04-21T16:35:38.484Z</published>
    <updated>2019-04-21T16:35:38.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-字节码概要">一 字节码概要</h2><p><code>java</code>编译后形成<code>.class</code>文件, 我们称之为<code>字节码</code>文件, 它可以被JIT(即时编译器)直接解释执行字节码技术被广泛应用, 比如<code>Lombok</code>, <code>cglib</code>, <code>Javassist</code>, <code>ASM</code>, <code>AspectJ</code></p><p><code>Spring AOP</code>还扩展了两个概念: <code>Advice增强 (织入的代码)</code>, <code>Advisor切面(指定给什么类什么方法增强)</code>, 这个和<code>AspectJ</code>的理念一样</p><table><thead><tr><th style="text-align:center">- AOP类型</th><th style="text-align:left">- 代理形式</th><th style="text-align:left">- 特点</th></tr></thead><tbody><tr><td style="text-align:center"><code>jdk1.3动态代理</code></td><td style="text-align:left">动态</td><td style="text-align:left">jdk内置实现(<code>InvocationHandler</code>,<code>Proxy</code>), 它是基于接口方式反射实现代理类(<code>代理模式</code>), 所以要使用则必须实现接口, 由于使用反射, <strong>性能最差</strong></td></tr><tr><td style="text-align:center"><code>ASM</code></td><td style="text-align:left">动态</td><td style="text-align:left">低级的字节码生成工具, 近乎在于使用Javabytecode编程, 短小精悍, <strong>性能最高</strong>, 但可读性很差, 对使用者要求过高; , 同时<code>Kryo字节码序列化</code>也是使用<code>ASM</code></td></tr><tr><td style="text-align:center"><code>CGLIB</code></td><td style="text-align:left">动态</td><td style="text-align:left">基于<code>ASM</code>的高级实现, 抽象出方便使用的api, 本质是对类的代理, 通过字节码实现子类并重写方法并织入新功能, 所以final类无法代理; 且生成类比较耗时, 尽量是单例对象; 运行时性能是<code>jdk动态代理</code>2倍 (接口和类均可代理)</td></tr><tr><td style="text-align:center"><code>Javassist</code></td><td style="text-align:left">动态</td><td style="text-align:left">和<code>CGLIB</code>类似, 只不过<code>CGLIB</code>考虑了很多因素, 以及继承或包装了自己的一些类, 所以生成的字节码非常大; 而<code>Javassist</code>则是手工生成的字节码 (相对小很多), 相对比<code>CGLIB</code>快;  <code>Spring框架</code>目前使用的<code>CGLIB</code>,<code>Hibernate</code>已经使用<code>Javassist</code>代替了<code>CGLIB</code>; 不支持jdk5的新语法, 比如: <code>范型,枚举, 注解, 内部类/匿名类, continue/break, 继承</code>(接口和类均可代理)</td></tr><tr><td style="text-align:center"><code>AspectJ</code></td><td style="text-align:left">静态</td><td style="text-align:left">也是使用字节码技术, 但它是基于静态代理, 因为它采用的是编译器植入; 需要写相应的xml, 定义切面, 织入点等, 然后由aspectj的编译器来编译出新的字节码文件 (即编译期就已经生成好字节码<code>.class</code>文件)</td></tr></tbody></table><p>java自带序列化字节码遵循如下规范图1<img src="https://upload-images.jianshu.io/upload_images/1986868-5b44e95ff7e30847.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/690/format/webp" alt></p><p>参考:<a href="https://www.jianshu.com/p/252f381a6bc4" target="_blank" rel="noopener">一文让你明白Java字节码</a></p><p>参考: <a href="https://yq.aliyun.com/articles/135955" target="_blank" rel="noopener">动态代理解释-JDK,CGLIB,JAVASSIST,ASM</a></p><h3 id="1-bean拷贝复制">(1) Bean拷贝复制</h3><p>一般Apache的效果最差, 其次是Spring的工具类, 效果最好的是cglib的BeanCopier</p><table><thead><tr><th style="text-align:center">- 拷贝方式</th><th style="text-align:left">- 特点</th></tr></thead><tbody><tr><td style="text-align:center"><code>Apache BeanUtil.copyProperties</code></td><td style="text-align:left">效率最差</td></tr><tr><td style="text-align:center"><code>Apache PropertyUtils.copyProperties</code></td><td style="text-align:left">效率比<code>BeanUtil</code>好, 10个对象拷贝大概相差10倍, 1万个对象相差3倍</td></tr><tr><td style="text-align:center"><code>Spring BeanUtils.copyProperties</code></td><td style="text-align:left">1万个对象拷贝比<code>PropertyUtils</code>还低一半</td></tr><tr><td style="text-align:center"><code>CGLIB BeanCopier.create</code></td><td style="text-align:left">效率最高, 使用了<code>ASM</code>字节码技术, 比<code>Apache BeanUtil</code>低200倍</td></tr></tbody></table><p>执行效率对比</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">############### 性能测试10个对象拷贝 ###############</span><br><span class="line"> Apache [BeanUtil.copyProperties]开始进行测试</span><br><span class="line"> Apache [BeanUtil.copyProperties] 耗时<span class="number">173</span>毫秒</span><br><span class="line"> --------------------------------------------</span><br><span class="line"> Apache [PropertyUtils.copyProperties]开始进行测试</span><br><span class="line"> Apache [PropertyUtils.copyProperties] 耗时<span class="number">17</span>毫秒</span><br><span class="line"> --------------------------------------------</span><br><span class="line"> springframework [BeanUtils.copyProperties]开始进行测试</span><br><span class="line"> springframework [BeanUtils.copyProperties] 耗时<span class="number">276</span>毫秒</span><br><span class="line"> --------------------------------------------</span><br><span class="line"> CGLIB [BeanCopier.create]开始进行测试</span><br><span class="line"> CGLIB [BeanCopier.create] 耗时<span class="number">0</span>毫秒</span><br><span class="line"></span><br><span class="line"> ############### 性能测试10000个对象拷贝 ###############</span><br><span class="line"> Apache [BeanUtil.copyProperties]开始进行测试</span><br><span class="line"> Apache [BeanUtil.copyProperties] 耗时<span class="number">399</span>毫秒</span><br><span class="line"> --------------------------------------------</span><br><span class="line"> Apache [PropertyUtils.copyProperties]开始进行测试</span><br><span class="line"> Apache [PropertyUtils.copyProperties] 耗时<span class="number">122</span>毫秒</span><br><span class="line"> --------------------------------------------</span><br><span class="line"> springframework [BeanUtils.copyProperties]开始进行测试</span><br><span class="line"> springframework [BeanUtils.copyProperties] 耗时<span class="number">60</span>毫秒</span><br><span class="line"> --------------------------------------------</span><br><span class="line"> CGLIB [BeanCopier.create]开始进行测试</span><br><span class="line"> CGLIB [BeanCopier.create] 耗时<span class="number">2</span>毫秒</span><br></pre></td></tr></table></figure><h3 id="2-java序列化">(2) java序列化</h3><p>序列化框架很多, 有使用字节码的, 也有使用json的, 有的跨平台, 有的局限于java</p><blockquote><ol><li>针对java语言<code>Kryo</code>,<code>FST</code>, <code>基于JSON的三种</code></li><li>跨语言<code>ProtoBuf</code>,<code>Thrift</code>,<code>Hessian</code>,<code>Avro</code>,<code>Protostuff</code>,<code>MsgPack</code></li></ol></blockquote><p>下面对比下各种序列化框架的优缺点:</p><table><thead><tr><th style="text-align:center">- 序列化方式</th><th style="text-align:left">- 优点</th><th style="text-align:left">- 缺点</th></tr></thead><tbody><tr><td style="text-align:center"><code>java序列化</code></td><td style="text-align:left">没啥优点, 除了无须引用额外的三方包, 全是缺点</td><td style="text-align:left"><font color="orange">1.无法跨语言(内部私有协议); <br>2.序列化码流太大, 很多无用信息(序列化前后5倍差距); <br>3.性能太低</font></td></tr><tr><td style="text-align:center"><code>Protobuf (谷歌)</code></td><td style="text-align:left"><font color="orange">1.结构化数据存储格式(xml,json等)<br>2.高性能编解码技术<br>3.语言和平台无关, 扩展性好<br>4.支持<code>java,c++,python</code>三种语言</font></td><td style="text-align:left">需要编写Protobuf文件生成三方代码, 用以屏蔽协议问题, 导致使用稍难</td></tr><tr><td style="text-align:center"><code>Thrift (脸书)</code></td><td style="text-align:left"><font color="orange">1.主流语言基本都支持<br>2.很适合内部大型数据交换, 比如RPC; 对于Json和xml在性能有很大提升<br>3.支持三种典型的编码方式(<em>通用二进制编码,压缩二进制编码,优化的可选字段压缩编解码</em>)</font></td><td style="text-align:left">同<code>Protobuf</code>一样, 需要编写<code>thrift</code>文件, 导致使用稍难</td></tr><tr><td style="text-align:center"><code>kryo</code></td><td style="text-align:left">使用了<code>ASM</code>, 速度快, 序列化后体积小 (变长存储特性)</td><td style="text-align:left">跨语言很复杂, 不支持缓存功能(如果class增删字段则会反序列化报错), 后面进行了兼容 <a href="https://blog.csdn.net/fanjunjaden/article/details/72823866" target="_blank" rel="noopener">Kryo官方文档-中文翻译</a></td></tr><tr><td style="text-align:center"><code>hessian</code></td><td style="text-align:left">支持跨语言</td><td style="text-align:left">较慢</td></tr><tr><td style="text-align:center"><code>fst</code></td><td style="text-align:left">完全兼容JDK序列化协议, 序列化速度大概是JDK的4-10倍，大小是JDK大小的1/3左右</td><td style="text-align:left"></td></tr><tr><td style="text-align:center"><code>Jackson</code>, <code>Gson(谷歌)</code>, <code>FastJson(阿里)</code></td><td style="text-align:left"><code>Jackson</code>不建议使用, <code>Gson</code>功能最全面且无可挑剔,性能上稍弱于阿里的<code>FastJson</code>; <font color="orange"><br>若同时对性能和正确性都有要求, 建议Bean-&gt;JSON使用<code>Gson</code>, JSON-&gt;Bean使用<code>FastJson</code></font></td><td style="text-align:left"><font color="orange">1.<code>Jackson</code>对于复杂集合如Map,List会出现问题, 复杂类型转换JSON也非标准格式<br>2.<code>Gson</code>目前功能最全, 且无可挑剔, 性能上稍弱于<code>FastJson</code><br>3.<code>FastJson</code>复杂类型的Bean转换Json上会出现一些问题, 可能会出现引用的类型, 导致Json转换出错, 需要制定引用; 但是<code>parse</code>的速度是最高的</font></td></tr></tbody></table><h2 id="二-jit与aot">二 JIT与AOT</h2><table><thead><tr><th style="text-align:center">- 编译方式</th><th style="text-align:left">- 优缺点</th></tr></thead><tbody><tr><td style="text-align:center"><strong><code>AOT静态编译</code></strong></td><td style="text-align:left"><font color="orange">C, C++采用静态编译为机器码, cpu可以直接执行</font></td></tr><tr><td style="text-align:center"><strong><code>JIT动态编译</code></strong></td><td style="text-align:left"><font color="orange">java号称&quot;一次编写，随处运行&quot;, 但本地静态编译是特定于平台的, 需要考虑一种能兼顾<code>跨平台+高性能</code>的编译方式; </font></td></tr></tbody></table><p>JIT特性</p><blockquote><ol><li>编译线程与应用线程分离互不影响</li><li>编译过程在程序执行时, 且以方法为单位进行编译; 所以可以保证平台无关性 (不同平台编译出来也会有所不同, 但差异已经封装在了动态编译中)</li><li>通过周期性地对线程取样找出频繁执行的方法, 用来存储程序的此次执行中可能不会改变的动态值 (前期可能会慢一些, 长时间运行则会很快)</li><li>运行时编译会非常耗时, 因为编译代码耗时将计入程序执行时间, 所以通常只是集中编译少量的热方法</li></ol></blockquote><p>参考:<a href="https://blog.csdn.net/hsuxu/article/details/9320699" target="_blank" rel="noopener">JIT（动态编译）和AOT（静态编译）编译技术比较</a></p><h2 id="三-javassist与cglib">三 Javassist与CGLIB</h2><h3 id="1-javassist手工实现动态代理">(1) Javassist手工实现动态代理</h3><p>有两种实现方式</p><blockquote><ol><li>使用<code>javassist</code>内部的<code>ProxyFactory</code>, 此种方式可以代理<em>接口</em>和<em>类</em></li><li>手工实现类似<code>JDK动态接口代理</code></li></ol></blockquote><p>方式1 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理工厂方式创建动态代理 (代理的是class, interface的方法也可以代理)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavassistProxyFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JavassistProxyFactory</span><span class="params">(T target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getProxy</span><span class="params">()</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 代理工厂</span></span><br><span class="line">        ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">        <span class="comment">// 设置需要创建子类的父类</span></span><br><span class="line">        proxyFactory.setSuperclass(target.getClass());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 定义一个拦截器。在调用目标方法时，Javassist会回调MethodHandler接口方法拦截，</span></span><br><span class="line"><span class="comment">         * 来实现你自己的代理逻辑，</span></span><br><span class="line"><span class="comment">         * 类似于JDK中的InvocationHandler接口。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        proxyFactory.setHandler(<span class="keyword">new</span> MethodHandler() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> self        self为由Javassist动态生成的代理类实例，</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> thisMethod  thisMethod为当前要调用的方法</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> proceed     proceed 为生成的代理类对方法的代理引用。</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> args        Object[]为参数值列表，</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span>            从代理实例的方法调用返回的值。</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 其中，proceed.invoke(self, args);</span></span><br><span class="line"><span class="comment">             * 调用代理类实例上的代理方法的父类方法（即实体类ConcreteClassNoInterface中对应的方法）</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object self, Method thisMethod, Method proceed, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"--------------------------------"</span>);</span><br><span class="line">                System.out.println(<span class="string">"代理类全路径限定名"</span> + self.getClass());</span><br><span class="line">                <span class="comment">//class com.javassist.demo.A_$$_javassist_0</span></span><br><span class="line">                System.out.println(<span class="string">"要调用的方法名: "</span> + thisMethod.getName());</span><br><span class="line">                System.out.println(<span class="string">"代理类方法名: "</span> + proceed.getName());</span><br><span class="line">                System.out.println(<span class="string">"开启事务(统一织入钩子)-------"</span>);</span><br><span class="line"></span><br><span class="line">                Object result = proceed.invoke(self, args);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//下面的代码效果与上面的相同, 本质是一个是目标对象本身invoke, 一个是代理对象invoke, 效果一样</span></span><br><span class="line">                <span class="comment">//Object result = thisMethod.invoke(target, args);</span></span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"执行结果为: "</span> + JSON.toJSONString(result));</span><br><span class="line">                System.out.println(<span class="string">"提交事务(统一织入钩子)-------"</span>);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过字节码技术动态创建子类实例</span></span><br><span class="line">        <span class="keyword">return</span> (T) proxyFactory.createClass().newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式2 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IProxyFactory</span> </span>&#123;</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Object target, InvocationHandler handler)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 定义工厂实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">implements</span> <span class="title">IProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Object target, InvocationHandler handler)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) ProxyGenerator.newProxyInstance(Thread.currentThread().getContextClassLoader(),</span><br><span class="line">                target.getClass(), handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProxyGenerator生成字节码文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. 生成字节码文件的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger counter = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;Class&lt;?&gt;, Object&gt; proxyInstanceCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader classLoader, Class&lt;?&gt; targetClass, InvocationHandler invocationHandler)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (proxyInstanceCache.containsKey(targetClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> proxyInstanceCache.get(targetClass);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成代理类的全限定名</span></span><br><span class="line">        String qualifiedName = generateClassName(targetClass);</span><br><span class="line">        <span class="comment">// 创建代理类</span></span><br><span class="line">        CtClass proxy = pool.makeClass(qualifiedName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接口方法列表</span></span><br><span class="line">        CtField mf = CtField.make(<span class="string">"public static java.lang.reflect.Method[] methods;"</span>, proxy);</span><br><span class="line">        proxy.addField(mf);</span><br><span class="line"></span><br><span class="line">        CtField hf = CtField.make(<span class="string">"private "</span> + InvocationHandler.class.getName() + <span class="string">" handler;"</span>, proxy);</span><br><span class="line">        proxy.addField(hf);</span><br><span class="line"></span><br><span class="line">        CtConstructor constructor = <span class="keyword">new</span> CtConstructor(<span class="keyword">new</span> CtClass[]&#123;pool.get(InvocationHandler.class.getName())&#125;, proxy);</span><br><span class="line">        constructor.setBody(<span class="string">"this.handler=$1;"</span>);</span><br><span class="line">        constructor.setModifiers(Modifier.PUBLIC);</span><br><span class="line">        proxy.addConstructor(constructor);</span><br><span class="line"></span><br><span class="line">        proxy.addConstructor(CtNewConstructor.defaultConstructor(proxy));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取被代理类的所有接口</span></span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; interfaces = ClassUtils.getAllInterfaces(targetClass);</span><br><span class="line"></span><br><span class="line">        List&lt;Method&gt; methods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Class cls : interfaces) &#123;</span><br><span class="line">            CtClass ctClass = pool.get(cls.getName());</span><br><span class="line">            proxy.addInterface(ctClass);</span><br><span class="line"></span><br><span class="line">            Method[] arr = cls.getDeclaredMethods();</span><br><span class="line">            <span class="keyword">for</span> (Method method : arr) &#123;</span><br><span class="line">                <span class="keyword">int</span> ix = methods.size();</span><br><span class="line">                Class&lt;?&gt; rt = method.getReturnType();</span><br><span class="line">                Class&lt;?&gt;[] pts = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">                StringBuilder code = <span class="keyword">new</span> StringBuilder(<span class="string">"Object[] args = new Object["</span>).append(pts.length).append(<span class="string">"];"</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pts.length; j++) &#123;</span><br><span class="line">                    code.append(<span class="string">" args["</span>).append(j).append(<span class="string">"] = ($w)$"</span>).append(j + <span class="number">1</span>).append(<span class="string">";"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                code.append(<span class="string">" Object ret = handler.invoke(this, methods["</span> + ix + <span class="string">"], args);"</span>);</span><br><span class="line">                <span class="keyword">if</span> (!Void.TYPE.equals(rt))</span><br><span class="line">                    code.append(<span class="string">" return "</span>).append(asArgument(rt, <span class="string">"ret"</span>)).append(<span class="string">";"</span>);</span><br><span class="line"></span><br><span class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">1024</span>);</span><br><span class="line">                sb.append(modifier(method.getModifiers())).append(<span class="string">' '</span>).append(getParameterType(rt)).append(<span class="string">' '</span>).append(method.getName());</span><br><span class="line">                sb.append(<span class="string">'('</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pts.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">                        sb.append(<span class="string">','</span>);</span><br><span class="line">                    sb.append(getParameterType(pts[i]));</span><br><span class="line">                    sb.append(<span class="string">" arg"</span>).append(i);</span><br><span class="line">                &#125;</span><br><span class="line">                sb.append(<span class="string">')'</span>);</span><br><span class="line"></span><br><span class="line">                Class&lt;?&gt;[] ets = method.getExceptionTypes();    <span class="comment">//方法抛出异常</span></span><br><span class="line">                <span class="keyword">if</span> (ets != <span class="keyword">null</span> &amp;&amp; ets.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    sb.append(<span class="string">" throws "</span>);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ets.length; i++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">                            sb.append(<span class="string">','</span>);</span><br><span class="line">                        sb.append(getParameterType(ets[i]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                sb.append(<span class="string">'&#123;'</span>).append(code.toString()).append(<span class="string">'&#125;'</span>);</span><br><span class="line"></span><br><span class="line">                CtMethod ctMethod = CtMethod.make(sb.toString(), proxy);</span><br><span class="line">                proxy.addMethod(ctMethod);</span><br><span class="line"></span><br><span class="line">                methods.add(method);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        proxy.setModifiers(Modifier.PUBLIC);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; proxyClass = proxy.toClass(classLoader, <span class="keyword">null</span>);</span><br><span class="line">        proxyClass.getField(<span class="string">"methods"</span>).set(<span class="keyword">null</span>, methods.toArray(<span class="keyword">new</span> Method[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 持久化class到硬盘</span></span><br><span class="line">        proxy.writeFile(<span class="string">"/Users/apple/idea/doyo-learn/src/main/java/com/doyo/learn/proxy/javassist/three_jdk_way"</span>);</span><br><span class="line"></span><br><span class="line">        Object instance = proxyClass.getConstructor(InvocationHandler.class).newInstance(invocationHandler);</span><br><span class="line">        Object old = proxyInstanceCache.putIfAbsent(targetClass, instance);</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = old;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">modifier</span><span class="params">(<span class="keyword">int</span> mod)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Modifier.isPublic(mod)) <span class="keyword">return</span> <span class="string">"public"</span>;</span><br><span class="line">        <span class="keyword">if</span> (Modifier.isProtected(mod)) <span class="keyword">return</span> <span class="string">"protected"</span>;</span><br><span class="line">        <span class="keyword">if</span> (Modifier.isPrivate(mod)) <span class="keyword">return</span> <span class="string">"private"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组类型返回 String[]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getParameterType</span><span class="params">(Class&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c.isArray()) &#123;   <span class="comment">//数组类型</span></span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                sb.append(<span class="string">"[]"</span>);</span><br><span class="line">                c = c.getComponentType();</span><br><span class="line">            &#125; <span class="keyword">while</span> (c.isArray());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> c.getName() + sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">asArgument</span><span class="params">(Class&lt;?&gt; cl, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cl.isPrimitive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TYPE == cl)</span><br><span class="line">                <span class="keyword">return</span> name + <span class="string">"==null?false:((Boolean)"</span> + name + <span class="string">").booleanValue()"</span>;</span><br><span class="line">            <span class="keyword">if</span> (Byte.TYPE == cl)</span><br><span class="line">                <span class="keyword">return</span> name + <span class="string">"==null?(byte)0:((Byte)"</span> + name + <span class="string">").byteValue()"</span>;</span><br><span class="line">            <span class="keyword">if</span> (Character.TYPE == cl)</span><br><span class="line">                <span class="keyword">return</span> name + <span class="string">"==null?(char)0:((Character)"</span> + name + <span class="string">").charValue()"</span>;</span><br><span class="line">            <span class="keyword">if</span> (Double.TYPE == cl)</span><br><span class="line">                <span class="keyword">return</span> name + <span class="string">"==null?(double)0:((Double)"</span> + name + <span class="string">").doubleValue()"</span>;</span><br><span class="line">            <span class="keyword">if</span> (Float.TYPE == cl)</span><br><span class="line">                <span class="keyword">return</span> name + <span class="string">"==null?(float)0:((Float)"</span> + name + <span class="string">").floatValue()"</span>;</span><br><span class="line">            <span class="keyword">if</span> (Integer.TYPE == cl)</span><br><span class="line">                <span class="keyword">return</span> name + <span class="string">"==null?(int)0:((Integer)"</span> + name + <span class="string">").intValue()"</span>;</span><br><span class="line">            <span class="keyword">if</span> (Long.TYPE == cl)</span><br><span class="line">                <span class="keyword">return</span> name + <span class="string">"==null?(long)0:((Long)"</span> + name + <span class="string">").longValue()"</span>;</span><br><span class="line">            <span class="keyword">if</span> (Short.TYPE == cl)</span><br><span class="line">                <span class="keyword">return</span> name + <span class="string">"==null?(short)0:((Short)"</span> + name + <span class="string">").shortValue()"</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(name + <span class="string">" is unknown primitive type."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"("</span> + getParameterType(cl) + <span class="string">")"</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">generateClassName</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"%s$Proxy%d"</span>, type.getName(), counter.getAndIncrement());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-cglib动态代理使用">(2) CGLIB动态代理使用</h3><p>代理的是class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line"><span class="comment">//设置为哪个类产生代理(子类)</span></span><br><span class="line">enhancer.setSuperclass(clazz);</span><br><span class="line">enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对接口</span></span><br><span class="line"><span class="comment">//enhancer.setInterfaces(new Class[]&#123;IDBQuery.class&#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> enhancer.create();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * object 目标类实例</span></span><br><span class="line"><span class="comment"> * method 目标方法反射对象</span></span><br><span class="line"><span class="comment"> * args   方法参数</span></span><br><span class="line"><span class="comment"> * proxy  代理类实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object object, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"日志开始..."</span>);</span><br><span class="line">Object result = proxy.invokeSuper(object, args);</span><br><span class="line">System.out.println(<span class="string">"日志结束..."</span>);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">CglibProxy proxy = <span class="keyword">new</span> CglibProxy();</span><br><span class="line"><span class="comment">// Train为需要代理的类, 随意定义即可</span></span><br><span class="line">Train train = (Train)proxy.getProxy(Train.class);</span><br><span class="line">train.move();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四-classloader">四 ClassLoader</h2><p><img src="https://upload-images.jianshu.io/upload_images/11805791-2972fffeca85c0df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt></p><blockquote><ol><li>首先通过java源码编译器, 通过<code>词法分析/语法分析/语义分析</code>形成抽象语法树, 最后通过<code>字节码生成器</code>生成<code>.class字节码</code>文件</li><li>载入是通过<code>ClassLoader</code>或<code>Class.forName()</code>将字节码文件加载到jvm</li><li>链接 (分为三步)3.1 验证 :主要验证字节码是否符合java语言规范和jvm规范, 比较耗时 (文件格式验证, 元数据验证, 字节码验证, 符号引用验证)3.2 准备 :<strong><font color="red">正式为类变量分配内存并设置类变量初始值的阶段, 都将在方法区中进行分配; 注意方法区内存分配的仅包括类变量(static 修饰的变量),而不包括实例变量; 初始值“通常情况”下是数据类型的零值, 比如<code>static int value = 12</code>, 初始化时为0, 但是特殊情况下如: <code>static final int value = 12</code>, 编译时javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value设置为12</font></strong>3.3 解析 :把类常量池中所有的符号引用转为直接引用</li><li>初始化<strong><font color="red"><code>(1).&lt;clinit&gt;</code>所有的类变量初始化语句和类型的静态初始化器意味着只能是static静态的才会被初始化, 如上面在<code>准备</code>阶段初始化为零值, 这里则会被初始化为12; 触发的时机:<em>1.创建某个类的新实例时<code>new, 反射, 克隆 或 反序列化;</code></em><em>2.调用某个类的静态方法时;</em><em>3.使用某个类或接口的静态字段或对该字段(final 字段除外)赋值时</em><em>4.调用java的某些反射方法时</em><em>5.初始化某个类的子类时</em><em>6.在虚拟机启动时某个含有 main() 方法的那个启动类</em>也并非所有类都会拥有一个<clinit>方法 (没有静态初始化语句, 声明了类变量但没有初始化, 仅仅有final的类变量且是字面量常量 )<code>(2).&lt;init&gt;</code>是对象的初始化器<code>1.new,2.反射,3.克隆,4.反序列化</code>四种情况会实例化类</clinit></font></strong></li></ol></blockquote><h3 id="1-类加载机制与初始化">(1) 类加载机制与初始化</h3><p><img src="https://img-blog.csdn.net/20131106003500328?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveF9wYW5kYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p><p>这里特别需要说明类初始化的顺序 (其实通过上面<code>&lt;clinit&gt;</code>, <code>&lt;init&gt;</code>的讲解已经能推导)</p><p><font color="red">类变量或静态变量(代码块)首先会初始化, 其次是<code>&lt;init&gt;</code>实例化</font></p><blockquote><p><strong>无父类(继承关系)</strong></p></blockquote><ol><li>静态变量初始化</li><li>静态代码块</li><li>非静态变量初始化</li><li>非静态代码块</li><li>构造器</li></ol><blockquote><p><strong>有继承关系</strong></p></blockquote><ol><li>父类静态变量</li><li>父类静态代码块</li><li>子类静态变量</li><li>子类静态代码块</li><li>父类非静态变量</li><li>父类非静态代码块</li><li>父类构造器</li><li>子类非静态变量</li><li>子类非静态代码块</li><li>子类构造器</li></ol><p>注意:</p><ol><li>非法前置引用 (Illegal forward reference)变量必须定义在代码块前</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationOrderTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">        System.out.println(a); <span class="comment">// 非法前置引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        a++;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@PostConstruct</strong>它是jdk5增加了两个影响Servlet生命周期的注解它用于解决<code>@Autowred</code>, <code>@Resource</code>注入发生在构造函数之后如果想在对象构造时初始化某些操作, 由于服务未注入导致无法完成, <code>@PostConstruct</code>则保证在注入之后, <code>init</code>之前如下图 :<img src="https://upload-images.jianshu.io/upload_images/7987747-143d3cc59a925d87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/228/format/webp" alt></p><ol start="2"><li>后置定义变量可能造成意外</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationOrderTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        a++;</span><br><span class="line">        System.out.println(a); <span class="comment">// 值不是3, 而是1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-classloader与class-forname-区别">(2) ClassLoader与Class.forName()区别</h3><ul><li><code>Class.forName(&quot;className&quot;)</code></li></ul><p>实际上调用的是<code>forName0(className, true, ClassLoader.getClassLoader(caller), caller);</code>意味着 <font color="red"><strong>需要初始化</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个native本地方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@name</span>       需要加载的类的全路径限定名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@initialize</span> 是否初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@loader</span>     对应的类加载器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@caller</span>     调用者类, caller = Reflection.getCallerClass();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class.forName0(name, initialize, loader, caller)</span><br></pre></td></tr></table></figure><ul><li><code>ClassLoader.laodClass(&quot;className&quot;)</code></li></ul><p>实际调用的是<code>ClassLoader.loadClass(name, false);</code>意味着 <font color="red"><strong>无需link链接 (验证,准备,解析), 仅仅加载到jvm, 更别提下一步的初始化</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@name</span>    需要加载的类的全路径限定名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@resolve</span> 否进行链接(验证,准备,解析)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ClassLoader.loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br></pre></td></tr></table></figure><h3 id="3-java安全模型">(3) java安全模型</h3><p>在 Java 中将执行程序分成本地和远程两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的 Java 实现中，安全依赖于沙箱 (Sandbox) 机制。</p><p>(1). 远程代码沙箱(SandBox)模式<img src="https://www.ibm.com/developerworks/cn/java/j-lo-javasecurity/image003.gif" alt></p><p>(2). 远程代码带安全策略的沙箱(SandBox)模式<img src="https://www.ibm.com/developerworks/cn/java/j-lo-javasecurity/image005.gif" alt></p><p>(3). 本地代码也带安全策略的沙箱(SandBox)模式<img src="https://www.ibm.com/developerworks/cn/java/j-lo-javasecurity/image007.gif" alt></p><p>(4). 引入了域 (Domain)<img src="https://www.ibm.com/developerworks/cn/java/j-lo-javasecurity/image009.gif" alt></p><p>(5). 如何安全控制</p><blockquote><ol><li>调用链 : <code>MethodA-&gt;MethodB-&gt;MethodC</code></li><li>如果<code>doPrivileged</code>在<code>MethodB</code>中, 会跳过<code>MethodC</code>的权限检查</li><li>如果<code>doPrivileged</code>在<code>MethodA</code>中, 会跳过<code>MethodB</code>和<code>MethodC</code>的权限检查</li></ol></blockquote><p>java栈如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个线程会创建一个Stack, 栈元素称为栈帧, 其实就是方法</span></span><br><span class="line"><span class="comment">// 权限检查是和调用链相反的, 即从栈顶开始</span></span><br><span class="line"><span class="comment">// 如果[MethodB]带有doPrivileged, 则[MethodC]跳过检查</span></span><br><span class="line"><span class="comment">// 如果[MethodA]带有doPrivileged, 则[MethodB], [MethodC]跳过检查</span></span><br><span class="line">-----------</span><br><span class="line">| MethodC |  <span class="comment">// 栈顶</span></span><br><span class="line">-----------</span><br><span class="line">| MethodB |  <span class="comment">// doPrivileged, 表明[MethodC]跳过检查</span></span><br><span class="line">-----------</span><br><span class="line">| MethodA |  <span class="comment">// doPrivileged, 表明[MethodB], [MethodC]跳过检查</span></span><br><span class="line">-----------</span><br><span class="line">| ... ... |</span><br></pre></td></tr></table></figure><p>(6). 特殊情况</p><blockquote><ol><li><strong>访问控制上下文的继承问题</strong>总之, 要保证让子线程自动继承父线程的安全性上下文，这样子线程中的后续 AccessController.checkPermission 调用就会考虑所继承的父线程的安全特性</li><li><strong>安全检查横跨不同上下文</strong>使用<code>AccessControlContext acc = AccessController.getContext();</code></li><li><strong>反射生成代码提升代码权限漏洞</strong><font color="red">对象A -&gt; 反射1次(A’) -&gt; 反射2次(A’’)注意反射相关类权限很高, 反射两次导致A’'看到的是A’的权限 (权限已经变得很高);<code>@CallerSensitive</code>注解是为了解决上面的问题, 以前反射只检查<strong>固定</strong>深度的调用者的类, 看它有没有特权; 现在是只要标记了<code>@CallerSensitive</code>注解就会忽略中间多次反射出来的类, 最终找到<code>对象A</code>为Caller</font></li></ol></blockquote><h3 id="4-reflection-getcallerclass-与-callersensitive">(4) <code>Reflection.getCallerClass()</code>与<code>@CallerSensitive</code></h3><p>首先来看一段代码, 里面涉及两个重要的东西1.<code>@CallerSensitive</code>2.<code>Class&lt;?&gt; caller = Reflection.getCallerClass()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br><span class="line">            <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 先通过反射，获取调用进来的类信息，从而获取当前的 classLoader</span></span><br><span class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">    <span class="comment">// 调用native方法进行获取class信息</span></span><br><span class="line">    <span class="keyword">return</span> forName0(className, <span class="keyword">true</span>, ClassLoader.getClassLoader(caller), caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red"></font></p><blockquote><ol><li><strong>Reflection.getCallerClass()</strong><font color="red">获取其最终调用者的类(因为有可能是反射行为)若是反射行为, 配合@CallSensitive用来找到真正发起反射请求的类, 用以避免双重反射权限提供漏洞注意 : 只有<code>BootStrapClassLoader</code>, <code>ExtentionClassLoader</code>加载的类才允许调用此方法, 意味着用户自定义的一些类中无法调用此方法</font></li><li><strong>Reflection.getCallerClass(int i)</strong>若为&lt;0, 返回Reflection自身若为1, 返回调用者类…<font color="red">此方法<strong>已过时</strong>, 因为查找固定深度的调用者会产生双重反射提升权限的漏洞, 可配合<code>@CallerSensitive</code>来解决</font></li></ol></blockquote><h2 id="五-热部署与热加载">五 热部署与热加载</h2><p>都是通过ClassLoader特性来加载</p><table><thead><tr><th style="text-align:center">- 方式</th><th style="text-align:left">- 特点</th></tr></thead><tbody><tr><td style="text-align:center"><code>热加载</code></td><td style="text-align:left"><font color="orrange">1.在容器启动的时候起一条后台线程, 定时的检测类文件的时间戳变化<br>2.如果变化了则重新加载此类, 不会全部加载, 也不会清空内存整个应用重启<br>3.一般没有应用, 因为直接修改jvm中字节码的方式是难以监控的, 同时对注重安全的应用这种方式是不会使用的, 这好比给飞行中的飞机更换发动机</font></td></tr><tr><td style="text-align:center"><code>热部署</code></td><td style="text-align:left">使用也很少, springboot中<code>spring-boot-devtools</code>和<code>springloaded</code>就是其中的应用, 虽然只是加载变化的类(使用了两个ClassLoader), 但是应用是需要重启的</td></tr></tbody></table><p><img src="http://images2015.cnblogs.com/blog/961610/201706/961610-20170618175048821-1042115166.png" alt></p><h3 id="什么是双亲委派机制">什么是双亲委派机制?</h3><blockquote><p><strong>双亲委托机制</strong>, 当jvm要加载Test.class的时候</p></blockquote><ol><li>首先到<code>CustomClassLoader</code>自定义加载器查找, 若已加载过则返回字节码</li><li>若没有加载过，则询问上一层加载器(<code>AppClassLoader</code>)是否已经加载过Test.class</li><li>若没有, 则询问上一层加载器(<code>ExtClassLoader</code>)是否已经加载过</li><li>若没有, 则询问上一层加载器(<code>BoopStrapClassLoader</code>)是否已经加载过</li><li>若都没有加载, 则到自己指定类加载路径下(“sun.boot.class.path”)查看是否有Test.class字节码, 有则返回, 没有则通知下一层加载器ExtClassLoader到自己指定的类加载路径下(java.ext.dirs)查看</li><li>依次类推, 直到<code>CustomClassLoader</code>自定义类加载器指定<code>classpath</code>下还未找到<code>Test.class</code>, 则抛出异常<code>ClassNotFoundException</code></li></ol><h3 id="双亲委派优势是什么">双亲委派优势是什么?</h3><blockquote><ol><li>加载的类随着各自的类加载器一起具备了优先级的层次关系, 可以避免重复加载相同的类</li><li>可以防止外部篡改内部核心类, 比如外部想加载自己的<code>java.lang.Integer</code>, 经过层层委派发现已有, 则直接返回;如果在类路径下没找到, 则层层通知下一级加载器在各自类路径下进行查找, 最后都没找到则抛出异常<code>ClassNotFoundException</code></li></ol></blockquote><h3 id="四个重要的方法-loadclass-findclass-defineclass-resolveclass">四个重要的方法(loadClass/findClass/defineClass/resolveClass)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 首先, 查看类是否已被加载</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果找不到, 则委托给父类加载器去加载</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果没有父类, 则委托给启动加载器去加载</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果都没有找到，则通过自定义实现的findClass去查找并加载 (需要自己重写findClass方法)</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line"> sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是否需要在加载时进行解析 (链接的第三阶段)</span></span><br><span class="line">        <span class="comment">// 否则就只能在实例化对象时进行解析和初始化</span></span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在jdk1.2之后建议重写<code>findClass</code>而非<code>loadClass</code><font color="orange">findClass()方法是在loadClass()方法中被调用的, 当loadClass()方法中父加载器加载失败后, 则会调用自己的findClass()方法来完成类加载, 这样就可以保证自定义的类加载器也符合双亲委托模式;需要注意的是findClass()默认是抛出<code>ClassNotFoundException</code>异常, 需要重写自己的逻辑, 一般是配合<code>defineClass</code>一起使用</font></p><p>一个重写<code>findClass</code>简单例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">      <span class="comment">// 获取类的字节数组, 这个需要自己实现</span></span><br><span class="line">      <span class="comment">// 除非自定义ClassLoader继承于URLClassLoader(通过URLClassPath类负责找到要加载的字节码, 再读取成字节流, 默认已实现好了)</span></span><br><span class="line">      <span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line">      <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//使用defineClass生成class对象</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面代码示例, 可以看出如果继承于抽象类<code>ClassLoader</code>, 在重写<code>findClass</code>时, 需要自己手工实现类的字节码流获取, 所以经常我们重写<code>ClassLoader</code>是继承于<code>URLClassLoader</code>, 这些工作它已经帮我们做好了;</p><p>在<code>sun.misc.Launcher</code>类里, 除了C++代码写的<code>BootStrapClassLoader</code>, 其他两个jdk自带的类加载器<code>ExtClassLoader</code>, <code>AppClassLoader</code>都继承于<code>URLClassLoader</code>, 并且最终都是调用<code>ClassLoader</code>的<code>loadClass</code>;  这表明它们都遵循<code>双亲委托模型</code></p><h3 id="class对象相等的两个必要条件">class对象相等的两个必要条件</h3><blockquote><ol><li>类的完整类名必须一致，包括包名</li><li><em>加载这个类的ClassLoader(指ClassLoader实例对象)必须相同</em></li></ol></blockquote><p><font color="red">由于不同的ClassLoader实例对象都拥有不同的独立的类名称空间，所以加载的class对象也会存在不同的类名空间中；一般我们不会重写也不建议重写<code>loadClass</code>，而<code>loadClass</code>会检查所有类加载器的缓存，同类名则会阻止再次加载，所以不会出现第二个条件的限制，一般只要类全路径限定名相同，默认认为是同一个类实例</font></p><h3 id="自定义类加载器">自定义类加载器</h3><blockquote><ol><li>继承于<code>ClassLoader</code>抽象类需要自己实现<code>findClass</code>的加载逻辑, 以及class文件加载转换成字节码流的代码</li><li>继承于<code>URLClassLoader</code>可以免去上面的步骤, 因为内置实现好了</li></ol></blockquote><p>意义与应用场景</p><blockquote><ol><li>当class文件不在ClassPath路径下，默认系统类加载器无法找到该class文件</li><li>当一个class文件是通过网络传输并且可能会进行相应的加密操作时，需要先对class文件进行相应的解密后再加载到JVM内存中</li><li>当需要实现热部署功能时(一个class文件通过不同的类加载器产生不同class对象从而实现热部署功能)</li></ol></blockquote><h3 id="双亲委派模型的破坏者-线程上下文类加载器">双亲委派模型的破坏者-线程上下文类加载器</h3><p><font color="red">SPI(服务提供者接口), 类似一种<code>门面模式</code>, 由jdk提供统一服务接口, 具体实现则由第三方公司提供具体服务实现, 比如 :<code>JDBC, JNDI, Slf4j(这个只能算门面模式)</code>问题在于服务接口在rt.jar中, 由<code>BootstrapClassLoader</code>加载, 但第三方公司的实现导致其他类加载器都无法加载 (classpath问题), 所以出现了<code>contextClassLoader</code>上下文类加载器它默认情况下是<code>AppClassLoader</code>, 可通过<code>ClassLoader.getSystemClassLoader()</code>得到, 但是在不同环境, 比如javaweb容器<code>tomcat,jetty...</code>或者C/S模式的EJB容器<code>JBoss</code>, 它们的线程上下文类加载器并非默认的<code>AppClassLoader</code>,所以很少直接使用<code>ClassLoader.getSystemClassLoader()</code>, 可以认为不同容器使用的默认类加载器可能是不同的</font></p><p><code>contextClassLoader</code>永远取得的是当前系统默认的类加载器, jdk默认是<code>AppClassLoader</code>, 但是不同容器可能会使用自定义的类加载器作为默认加载器;所以尽量不使用<code>ClassLoader.getSystemClassLoader()</code></p><p>同时上下文加载器的加载方式破坏了“双亲委派模型”, 如下图：<img src="https://img-blog.csdn.net/20170625143404387?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p><h3 id="总结">总结</h3><blockquote><p><strong>关键类</strong><code>ClassLoader</code> 下面三个jdk自带类加载器的顶级父类<code>URLClassLoader</code> 它默认实现了类的字节码流获取<code>ExtClassLoader</code> 继承于URLClassLoader, 且未重写loadClass<code>AppClassLoader</code> 同ExtClassLoader<code>Launcher</code> 是定义ExtClassLoader, AppClassLoader的地方<strong>自定义类加载器几个关键方法</strong><code>loadClass</code> 无需重写, 意味着必须遵循<code>双亲委托模型</code><code>findClass</code> 需要重写, 自定义类加载器的重点方法<code>defineClass</code> 位于ClassLoader, 创建类的方法, 调用了native代码<code>resolveClass</code> 位于ClassLoader, 表示是否解析(链接第三阶段)<strong>jdk类加载器关系</strong><code>启动类加载器</code>，由C++实现，没有父类<code>拓展类加载器(ExtClassLoader)</code>，由Java语言实现，父类加载器为null<code>系统类加载器(AppClassLoader)</code>，由Java语言实现，父类加载器为ExtClassLoader<code>自定义类加载器</code>，父类加载器肯定为AppClassLoader<code>contextClassLoader</code> 线程上下文类加载器, 默认是AppClassLoader, 但不同容器可能使用的默认类加载器不一定相同, 可能是自己实现的, 所以尽量不使用<code>ClassLoader.getSystemClassLoader()</code>, 避免不必要的问题</p></blockquote><h3 id="附加说明">附加说明</h3><ul><li><strong>EJB</strong></li></ul><p>这是C/S模式, 客户端软件通过RMI这种远程调用方式直接调用服务端代码, 它是基于<code>RMI</code>远程调用</p><p>现代的服务通信模型基本经历了<code>RMI</code>, <code>WebService</code>, <code>RPC</code>, <code>JMS</code>的历程, 现在的对外服务基本上基于RESTful接口(基于Http), 内部微服务之间使用RPC通信(JSON/Byte)</p><ul><li><strong>远程调用</strong></li></ul><p>1.RMI(EJB的通信基础)</p><p>它是<code>基于面向对象的java-rpc</code>, 只支持java, 本质上传递的是对象, 通过生成的代理类可以进行编译期检查</p><blockquote><ol><li>tcp协议</li><li>传递可序列化java对象</li><li>由于是对象, 所以可以通过代理类进行静态检查</li><li>缺陷<font color="red">只支持java, 无法跨平台; 对象传输太大, 效率不高</font></li></ol></blockquote><p>2.WebService它是基于Http的, 只不过消息传递方式是基于XML结构</p><blockquote><ol><li>Http协议</li><li>传递XML格式数据</li><li>封装SOAP协议</li><li>WSDL描述</li><li>缺陷<font color="red">基于XML格式, 包装与解析太过繁琐, 效率低下</font></li></ol></blockquote><p>3.JMS它是基于消息的异步通知模型, 不是同步应答模型它是java接口规范, 和JMX, SPI等是一个级别的概念比如第三方的消息队列ActiveMQ, 就是根据JMS规范写的实现</p><p>4.RPC</p><blockquote><ol><li>TCP协议, 也有使用Http/2协议的</li><li>传递byte字节码数据, 也有基于JSON格式字符串数据的</li><li>跨平台, 数据传输小, 数据发送与解析也比较高效所以现代RPC基本取代了RMI, Restful基本取代了WebService</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-字节码概要&quot;&gt;一 字节码概要&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;java&lt;/code&gt;编译后形成&lt;code&gt;.class&lt;/code&gt;文件, 我们称之为&lt;code&gt;字节码&lt;/code&gt;文件, 它可以被JIT(即时编译器)直接解释执行
字节码技术被广泛应用, 比如&lt;c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分布式一致性概览</title>
    <link href="https://doooyo.github.io/2019/04/22/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E6%A6%82%E8%A7%88/"/>
    <id>https://doooyo.github.io/2019/04/22/分布式一致性概览/</id>
    <published>2019-04-21T16:35:08.081Z</published>
    <updated>2019-04-21T16:35:08.081Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cap与base">CAP与BASE</h2><h3 id="cap">CAP</h3><p><img src="http://www.wangbase.com/blogimg/asset/201807/bg2018071607.jpg" alt></p><blockquote><ol><li><code>Consistency（一致性, 默认指强一致性）</code>所有节点在同一时间具有相同的数据, 和<code>A.可用性</code>相悖</li><li><code>Availability（可用性）</code>保证每个请求不管成功或者失败都有响应, 一旦要求强一致则必须让其他节点先同步数据后再提供服务, 和<code>C.一致性</code>相悖</li><li><code>Partition tolerance（分区容错性）</code>分布式系统由于网络或硬件因素导致部分服务不可用, 但剩余的服务可完成完整的业务(只是负载会变高),</li></ol></blockquote><p><font color="brown">在现代技术条件下, CAP是无法同时满足, 只能选择其二;而且在分布式系统, <code>P.分区</code>是一定存在的, 如果说满足<code>CA</code>则一定是单点部署, 则存在单点故障;</font></p><h3 id="base">BASE</h3><p>BASE理论是对<code>CAP</code>中<code>CA</code>的权衡（因为分布式系统<code>P</code>肯定存在）, 比如<code>购票系统</code> : 购买时需要知道是否还有票, <em>需要保证强一致性</em><code>银行转账系统</code> : 提示半小时后到账, <em>需要保证最终一致性</em><code>购物车购物</code> : 库存可以不是一致性(不实时一致), 但是在提交订单时则必须是一致性的数据(延迟的一致)</p><blockquote><ol><li><code>Basically Available（基本可用）</code></li><li><code>Soft state（软状态）</code></li><li><code>Eventually consistent（最终一致性）</code></li></ol></blockquote><ul><li>应用场景</li></ul><blockquote><p><code>CA</code> : 特指<code>单点系统</code>, 因为分布式系统必存在分区<code>CP</code> : 适合<code>购票系统</code>, 就算无法保证可用性也必须保证数据一致<code>AP</code> : 这是大部分分布式系统的首选, 只要保证<code>BASE</code>中的<code>最终一致性</code>即可;比如CDN更新网站内容, 比如跨行转账保证最终一致性, 允许时延; 比如NoSQL集群</p></blockquote><h2 id="一致性算法raft-zab与paxos">一致性算法Raft/Zab与Paxos</h2><h3 id="raft-replicated-and-fault-tolerant">Raft (Replicated And Fault Tolerant)</h3><p><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">Raft分布式一致性算法动画</a></p><p><code>复制容错一致性算法</code><font color="red"><code>Raft</code>是一个在随机时间Leader选举基础上叠加了各种补丁的方案, 它是一个分布式一致性的实际操作指南, 它是实现的过程;<code>Paxos</code>是一个经过论证的完备理论, 任何形态下都有解, 前提是你要有解决它给出步骤的工程手段;这类似道与术, 理论和实践的区别</font></p><blockquote><ol><li><code>Leader的选举过程</code>随机时间触发, 先到先得得</li><li><code>Log的复制方案</code>给予Log复制机制的状态机</li><li><code>数据安全</code>其实就是一致性, 对前两者的补充</li></ol></blockquote><h4 id="leader选举">Leader选举</h4><p>节点处于三个状态中的一种: <code>Leader</code>, <code>Follower</code>, <code>Candidate</code>大家都是从<code>Follower</code>追随者开始的</p><p><code>Raft</code>算法有两个控制选举的超时设置:<code>选举超时</code>: 是等待追随者(<code>Follower</code>)成为候选人(<code>Candidate</code>)的时间(100ms~300ms内随机)</p><blockquote><ol><li>先启动则优先发起投票, 将当前已知<code>Terms</code>加1, 向其他服务器发送投票请求, 同时给自己一票</li><li>其他服务器对每个节点至多投一票, 意思是谁先给我发送投票请求, 我就投给谁, 来晚了我就没票了, 先到先得; 同时重置<code>投票超时</code><font color="red">(a)注意Leader会定时发送心跳给Follower, Follower接收到心跳会重置选举超时时间(当然也可能会额外做一些日志commit之类的事情), (b)一旦Follower没有接收到心跳直到选举超时<code>election term</code>, 则会重新开始投票进行选举, 因为Leader很有可能’挂’掉了;谁先选举超时则会成为<code>候选人Candidate</code>, 新一轮的选举投票请求开始,  直到选票过半重新选举出Leader;©问题在于可能会出现我们认为’挂’掉的Leader只是由于网络原因暂时无法通信, 如果恢复了则会出现两个Leader, 则可以进行分裂投票(d) 分裂投票不止局限于上面的情况, 还可能两个节点同时启动的情况, 同时<code>投票超时</code>, 即同时成为了<code>候选人Candidate</code>, 都在发送投票请求, 而且各种的票数量一致, 这时则将通过谁先超时, 则谁成为Leader(e)网络分区的治愈, 很多情况下可能导致集群节点分成2个或多个分区, 意味着会出现多个Leader, 最后治愈时将会根据<code>Term</code>最高(递增)的那个Leader成为新Leader, 其余<code>Term</code>较低的Leader则会下台成为<code>Follower</code></font></li><li>某台服务器选票过半, 则当选<code>Leader</code></li></ol></blockquote><ol start="4"><li>为防止各自投票导致议案永远不一致的情况, 投票超时并发起投票请求的时间是随机的(一定范围内, 150ms~300ms)实践证明一般两轮选举即可达成议案一致, 即选举<code>Leader</code>成功</li></ol><blockquote><ol start="5"><li>理论简单但是有许多细节需要约定 :</li></ol></blockquote><p>一个有意思的 <a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">Raft分布式一致性算法动画</a></p><h4 id="log日志同步">Log日志同步</h4><p>选举<code>Leader</code>完毕, 则主要任务是日志同步<font color="red">日志有两个辅助概念: <strong>Terms</strong>, <strong>序号</strong>每次选举<code>Terms</code>和<code>序号</code>单向递增, 这不是分布式一致性本质要求, 只是工程实践的手段; 暂且称呼为<code>时期号</code>, 它作为逻辑时钟帮助Leader选举而存在</font><img src="http://img-blog.csdn.net/20170629122054768" alt></p><blockquote><ol><li>所有客户端请求由<code>Leader</code>负责处理</li><li><code>Leader</code>将请求命令封装成一条日志, 发送给其他服务器节点;日志包含: <code>命令+Terms+序号+日志所在Log文件索引</code>这些额外信息是为了其他服务器判定日志合法性与数据同步安全</li><li>日志确定提交<code>Commit</code>;当<code>Leader</code>确认一条日志已经被多数服务器成功复制后, 此条日志包含的指令则可以提交生效</li><li><code>Leader</code>记录当前最新提交状态的日志索引号, 并将索引号在后续的日志复制请求或心跳中发送给其他服务器;最终所有的从服务器也将得到最新的信息并执行指令更新自己的状态机</li><li><font color="red">日志同步也会产生很多网络问题, 比如Leader崩溃, 日志复制了但未能提交; 日志同步进度也各不相同, 期间可能遇到重启, 崩溃等等<code>Raft</code>会采取强制同步的方式, 来规避日志的反向或交叉复制, 以简化同步策略<code>Leader</code>会为每个<code>Follower</code>服务器维护一个当前待同步日志索引来跟踪同步进度, 是否发送<code>Commit</code>指令(心跳)也是根据此队列信息来判定, 比如当发现有一半的节点的同步进度符合要求, 则开始<code>Commit</code></font></li></ol></blockquote><p>参考:<a href="https://www.cnblogs.com/bangerlee/p/5991417.html" target="_blank" rel="noopener">分布式系统理论进阶 - Raft、Zab</a><a href="https://www.jianshu.com/p/24307e7ca9da" target="_blank" rel="noopener">Raft Vs Zab</a><a href="https://my.oschina.net/pingpangkuangmo/blog/782702" target="_blank" rel="noopener">Raft对比ZAB协议 </a><a href="https://www.zhihu.com/question/19787937" target="_blank" rel="noopener">如何浅显易懂地解说Paxos 的算法</a></p><h2 id="注册中心的算法选择">注册中心的算法选择</h2><p>zookeeper zab</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;cap与base&quot;&gt;CAP与BASE&lt;/h2&gt;
&lt;h3 id=&quot;cap&quot;&gt;CAP&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://www.wangbase.com/blogimg/asset/201807/bg2018071607.jpg&quot; alt&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringMCV</title>
    <link href="https://doooyo.github.io/2019/04/22/SpringMCV/"/>
    <id>https://doooyo.github.io/2019/04/22/SpringMCV/</id>
    <published>2019-04-21T16:35:08.076Z</published>
    <updated>2019-04-21T16:35:08.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是servlet">什么是Servlet</h2><p>Servlet是为了解决实现动态页面而衍生的东西;一个Web应用应该只有一个Servlet, 可以理解为Http请求的唯一入口, 实际上我们也是这么做的;</p><p>tomcat容器与Servlet请求执行过程 :<img src="http://images2015.cnblogs.com/blog/874710/201702/874710-20170214204632894-1786729693.png" alt></p><blockquote><ol><li>浏览器Http请求发送至Tomcat</li><li>Tomcat加载相应的Servlet并实例化(<code>ServletContext</code>+<code>ServletConfig</code>)</li><li>Tamcat解析Http协议为ServletRequest对象, 同时也把ServletResponse对象生成</li><li>调用Servlet实例的service方法, 将ServletRequest和ServletResponse传递过去</li><li>Servlet实例处理后, 将ServletResponse填装并返回</li><li>Tomcat将ServletResponse解析为Http协议的响应,返回浏览器客户端</li></ol></blockquote><p><font color="red">tomcat就是servlet实例的容器, 负责servlet的生命周期, 一个应用只应有唯一的servlet, tomcat将对应的Http请求转换成request对象传递给Servlet实例进行处理, 完毕后再返回Response对象给tomcat, 最后由tomcat返回响应</font></p><p>web容器有两类 (其他还有EJB容器如jboss) :一类是servlet容器(tomcat, jetty…);一类是portlet容器(websphere);</p><p>定义一个Servlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tomcat,jetty等servlet容器会调用init(config)进行初始化, config是从web.config读取</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// servlet销毁时, 为空实现, 需要自己重写</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tomcat, Jetty等容器会加载此MyServlet类, 请求到达时会调用service方法, 传入req, resp</span></span><br><span class="line">    <span class="comment">// 不需要重写此类, 此处只是为了做说明</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.service(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写get方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"GET"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写post方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"POST"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写put方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPut</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"PUT"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写delete方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDelete</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DELETE"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义相应的web.xmlspringmvc的<code>DispatcherServlet</code>web应用唯一servletdurid链接池的<code>StatViewServlet</code>状态监控servlet说明tomcat, jetty等容器可以根据url映射到不同的servlet</p><p><font color="red">每个servlet都有一个<code>ServletConfig</code>,<code>ServletContext</code>,  <code>&lt;load-on-startup&gt;</code>值为0表示Tomcat在启动时就会去加载servlet, 大于0则表示第一次请求时才加载</font></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- SpringMVC的servlet请求调度中心,也叫前端控制器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 若不写则默认为/WEB-INF/springmvc-servlet.xml, 可以自定义名称为[&lt;servlet-name&gt;]-servlet.xml，如springmvc-servlet.xml;</span></span><br><span class="line"><span class="comment">         一旦自定义名字和位置,名字必须是'contextConfigLocation' --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 小于0或不写表示该servlet被选择时才加载; 大于0表示应用启动立即加载,且数值越小优先级越高 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 用于指定截获何种类型的请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 必须是上面指定的servlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 意思是所有请求都由smvc这个调度器分派 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- druid数据库连接池监控Servlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DruidStatView<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.alibaba.druid.support.http.StatViewServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DruidStatView<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/druid/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="springmvc">SpringMVC</h2><h3 id="运行流程">运行流程</h3><p>SpringMVC运行流程图<img src="https://upload-images.jianshu.io/upload_images/7964614-85f89a14164e5be0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/952/format/webp" alt></p><p>流程 :</p><blockquote><ol><li>用户发送请求至前端控制器<code>DispatcherServlet</code> (其实是先发送到<code>tomcat</code>, <code>jetty</code>等servlet容器, 再由容器通过web.xml的配置选择相应的servlet进行调用)</li><li><code>DispatcherServlet</code>收到请求调用<code>HandlerMapping</code>处理器映射器</li><li>处理器映射器根据请求url找到具体的处理器(即Controller), 生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet<font color="red">其实请求会先经过tomcat等容器的<code>filterChain</code>过滤链(<strong>基于回调</strong>), 然后才会到达servlet, 然后由<code>HandlerMapping</code>根据url找到<code>HandlerIntercepter</code>拦截器链(<strong>基于动态代理, 反射</strong>)</font></li><li>DispatcherServlet通过HandlerAdapter处理器适配器调用处理器</li><li>执行处理器(Controller，也叫后端控制器)</li><li>Controller执行完成返回ModelAndView</li><li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet</li><li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li><li>ViewReslover解析后返回具体View</li><li>DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）</li><li>DispatcherServlet响应<code>ServletResponse</code>给tomcat容器, 由tomcat将之解析为http内容并返回</li></ol></blockquote><p>关于过滤器<code>Filter</code>, 拦截器<code>Interecpter</code>, 如图 :</p><p><img src="http://images.cnitblog.com/blog/615156/201501/020253086387177.jpg" alt></p><p><font color="red"><code>Filter</code>是Servlet规范定义的, 所以只能在容器(tomcat,jetty…)内使用, 本质是一个过滤器队列(链表);<code>HandlerIntercepter</code>是springmvc的定义, 使用的是动态代理 </font>所以从表象上看, 有如下几个区别 :</p><blockquote><ol><li>拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用，因为资源的请求会被其他Servlet或者容器处理</li><li>拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问</li><li>拦截器可以获取IOC容器中的各个bean，而过滤器就不行；因为拦截器本身就属于SpingMVC，所以可以在里面注入相应的service</li></ol></blockquote><h3 id="九大组件">九大组件</h3><p>首先要了解<code>Handler</code>处理器, 它对应着<code>Controller</code>层, 可以是类也可以是其中的方法, 只要处理请求即可称为<code>Handler</code>, 这是一个广义的概念</p><table><thead><tr><th style="text-align:center">- springmvc组件</th><th style="text-align:left">- 作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>HandlerMapping</code></td><td style="text-align:left">用于查找Handler, 主要是根据<code>@RequestMapping</code>注解的url地址来寻找</td></tr><tr><td style="text-align:center"><code>HandlerAdapter</code></td><td style="text-align:left">是一个适配器</td></tr><tr><td style="text-align:center"><code>HandlerExceptionResolver</code></td><td style="text-align:left">所有的组件都可能产生异常, 发生异常后需要一个专门角色进行处理, 并设置ModelAndView错误, render渲染后返回给浏览器</td></tr><tr><td style="text-align:center"><code>ViewResolver</code></td><td style="text-align:left">视图解析器, 用来将String类型的视图名和Locale解析为View类型的视图; 这里使用策略模式, 即用户可以配置不同的模板引擎, <code>ViewResolver</code>的工作就是找到对应模板引擎和对应的视图类型, 具体的渲染过程则交由不同的视图自己完成</td></tr><tr><td style="text-align:center"><code>RequestToViewNameTranslator</code></td><td style="text-align:left">从request中获取ViewName就是RequestToViewNameTranslator要做的事情, 所有request到ViewName的转换规则都要在一个Translator里面全部实现, 即springmvc只允许配置一个转换器</td></tr><tr><td style="text-align:center"><code>LocaleResolver</code></td><td style="text-align:left">解析视图需要两个参数：一是视图名, 另一个是Locale, 即<code>zh-cn</code>之类的本地化信息</td></tr><tr><td style="text-align:center"><code>ThemeResolver</code></td><td style="text-align:left">用于解析主题;  相关的类还有<code>ThemeSource</code>和<code>Theme</code>, 然后通过主题名称找到对应的主题（可以理解为一个配置）文件，这是ThemeSource的工作。最后从主题中获取资源就可以了</td></tr><tr><td style="text-align:center"><code>MultipartResolver</code></td><td style="text-align:left">用于处理上传请求; 处理方法是将普通的request包装成MultipartHttpServletRequest，后者可以直接调用getFile方法获取File，如果上传多个文件，还可以调用getFileMap得到FileName-&gt;File结构的Map。此组件中一共有三个方法，作用分别是判断是不是上传请求，将request包装成MultipartHttpServletRequest、处理完后清理上传过程中产生的临时资源</td></tr><tr><td style="text-align:center"><code>FlashMapManager</code></td><td style="text-align:left">用来管理FlashMap的, FlashMap主要用在redirect中传递参数</td></tr></tbody></table><h2 id="手写springmvc">手写SpringMVC</h2><p><img src="http://upload-images.jianshu.io/upload_images/7964614-452d6f34ffbde14a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt></p><p>可以看出SpringMVC本质就是一个Servlet</p><h3 id="定义三个注解">定义三个注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同 @Controller注解</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyController &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示给controller注册别名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  同 @RequestMapping注解</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyRequestMapping &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示访问该方法的url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  同 @RequestParam注解, 这里只解析GET请求参数</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.PARAMETER)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyRequestParam &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示参数的别名，必填</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义servlet-类似dispatcherservlet">定义Servlet (类似DispatcherServlet)</h3><p>tomcat等类似的Servlet容器会加载此Servlet, 是否懒加载则是容器根据<code>web.xml</code>配置的内容为准, 当然<code>web.xml</code>还会初始化一些初始化数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDispatcherServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存web.xml配置</span></span><br><span class="line">    <span class="keyword">private</span> Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="comment">// 保存用户指定扫描包路径下的所有类</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; classNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 保存所有扫描到的类的实例化对象, 类似IOC注入</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; ioc = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 保存URL和Handler的映射 (狭义的Handler即Action, 也即Controller中的方法, 广义的Handler即只要能处理请求的都是)</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Method&gt; handlerMapping = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 保存URL和Controller实例的映射, 以便可以反射调用</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; controllerMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.加载配置文件</span></span><br><span class="line">        doLoadConfig(config.getInitParameter(<span class="string">"contextConfigLocation"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.初始化所有相关联的类,扫描用户设定的包下面所有的类</span></span><br><span class="line">        doScanner(properties.getProperty(<span class="string">"scanPackage"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.拿到扫描到的类,通过反射机制,实例化,并且放到ioc容器中(k-v  beanName-bean) beanName默认是首字母小写</span></span><br><span class="line">        doInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.初始化HandlerMapping(将url和method对应上)</span></span><br><span class="line">        initHandlerMapping();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//处理请求</span></span><br><span class="line">            doDispatch(req, resp);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            resp.getWriter().write(<span class="string">"500!! Server Exception"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handlerMapping.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String url = req.getRequestURI();</span><br><span class="line">        String contextPath = req.getContextPath();</span><br><span class="line"></span><br><span class="line">        url = url.replace(contextPath, <span class="string">""</span>).replaceAll(<span class="string">"/+"</span>, <span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.handlerMapping.containsKey(url)) &#123;</span><br><span class="line">            resp.getWriter().write(<span class="string">"404 NOT FOUND!"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Method method = <span class="keyword">this</span>.handlerMapping.get(url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取方法的参数列表</span></span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取请求的参数</span></span><br><span class="line">        Map&lt;String, String[]&gt; parameterMap = req.getParameterMap();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存参数值</span></span><br><span class="line">        Object[] paramValues = <span class="keyword">new</span> Object[parameterTypes.length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法的参数列表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">            <span class="comment">//根据参数名称，做某些处理</span></span><br><span class="line">            String requestParam = parameterTypes[i].getSimpleName();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (requestParam.equals(<span class="string">"HttpServletRequest"</span>)) &#123;</span><br><span class="line">                <span class="comment">//参数类型已明确，这边强转类型</span></span><br><span class="line">                paramValues[i] = req;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (requestParam.equals(<span class="string">"HttpServletResponse"</span>)) &#123;</span><br><span class="line">                paramValues[i] = resp;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (requestParam.equals(<span class="string">"String"</span>)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Entry&lt;String, String[]&gt; param : parameterMap.entrySet()) &#123;</span><br><span class="line">                    String value = Arrays.toString(param.getValue()).replaceAll(<span class="string">"\\[|\\]"</span>, <span class="string">""</span>).replaceAll(<span class="string">",\\s"</span>, <span class="string">","</span>);</span><br><span class="line">                    paramValues[i] = value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//利用反射机制来调用</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method.invoke(<span class="keyword">this</span>.controllerMap.get(url), paramValues);<span class="comment">//第一个参数是method所对应的实例 在ioc容器中</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doLoadConfig</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//把web.xml中的contextConfigLocation对应value值的文件加载到流里面</span></span><br><span class="line">        InputStream resourceAsStream = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(location);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//用Properties文件加载文件里的内容</span></span><br><span class="line">            properties.load(resourceAsStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关流</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != resourceAsStream) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    resourceAsStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doScanner</span><span class="params">(String packageName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//把所有的.替换成/</span></span><br><span class="line">        URL url = <span class="keyword">this</span>.getClass().getClassLoader().getResource(<span class="string">"/"</span> + packageName.replaceAll(<span class="string">"\\."</span>, <span class="string">"/"</span>));</span><br><span class="line">        File dir = <span class="keyword">new</span> File(url.getFile());</span><br><span class="line">        <span class="keyword">for</span> (File file : dir.listFiles()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                <span class="comment">//递归读取包</span></span><br><span class="line">                doScanner(packageName + <span class="string">"."</span> + file.getName());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                String className = packageName + <span class="string">"."</span> + file.getName().replace(<span class="string">".class"</span>, <span class="string">""</span>);</span><br><span class="line">                classNames.add(className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (classNames.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String className : classNames) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//把类搞出来,反射来实例化(只有加@MyController需要实例化)</span></span><br><span class="line">                <span class="comment">// Class.forName是加载类, 且指定了需要执行static静态代码块, 但不会分配堆内存进行实例化</span></span><br><span class="line">                Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line">                <span class="keyword">if</span> (clazz.isAnnotationPresent(MyController.class)) &#123;</span><br><span class="line">                    ioc.put(toLowerFirstWord(clazz.getSimpleName()), clazz.newInstance());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ioc.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;String, Object&gt; entry : ioc.entrySet()) &#123;</span><br><span class="line">                Class&lt;? extends Object&gt; clazz = entry.getValue().getClass();</span><br><span class="line">                <span class="keyword">if</span> (!clazz.isAnnotationPresent(MyController.class)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//拼url时,是controller头的url拼上方法上的url</span></span><br><span class="line">                String baseUrl = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">if</span> (clazz.isAnnotationPresent(MyRequestMapping.class)) &#123;</span><br><span class="line">                    MyRequestMapping annotation = clazz.getAnnotation(MyRequestMapping.class);</span><br><span class="line">                    baseUrl = annotation.value();</span><br><span class="line">                &#125;</span><br><span class="line">                Method[] methods = clazz.getMethods();</span><br><span class="line">                <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!method.isAnnotationPresent(MyRequestMapping.class)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    MyRequestMapping annotation = method.getAnnotation(MyRequestMapping.class);</span><br><span class="line">                    String url = annotation.value();</span><br><span class="line"></span><br><span class="line">                    url = (baseUrl + <span class="string">"/"</span> + url).replaceAll(<span class="string">"/+"</span>, <span class="string">"/"</span>);</span><br><span class="line">                    handlerMapping.put(url, method);</span><br><span class="line">                    controllerMap.put(url, clazz.newInstance());</span><br><span class="line">                    System.out.println(url + <span class="string">","</span> + method);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把字符串的首字母小写</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">toLowerFirstWord</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] charArray = name.toCharArray();</span><br><span class="line">        charArray[<span class="number">0</span>] += <span class="number">32</span>;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(charArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试controller">测试Controller</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyController</span></span><br><span class="line"><span class="meta">@MyRequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyRequestMapping</span>(<span class="string">"/doTest"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                      @MyRequestParam(<span class="string">"param"</span>)</span> String param)</span>&#123;</span><br><span class="line">        System.out.println(param);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response.getWriter().write( <span class="string">"doTest method success! param:"</span>+param);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyRequestMapping</span>(<span class="string">"/doTest2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response.getWriter().println(<span class="string">"doTest2 method success!"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置web-xml">配置web.xml</h3><p>位于<code>webapp/WEB-INF/web.xml</code><code>webapp</code>和<code>resource</code>目录同级</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span> <span class="attr">xmlns:web</span>=<span class="string">"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"3.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>MySpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.doyo.springmvc.servlet.MyDispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>application.properties<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>MySpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是servlet&quot;&gt;什么是Servlet&lt;/h2&gt;
&lt;p&gt;Servlet是为了解决实现动态页面而衍生的东西;
一个Web应用应该只有一个Servlet, 可以理解为Http请求的唯一入口, 实际上我们也是这么做的;&lt;/p&gt;
&lt;p&gt;tomcat容器与Servle
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringFramework概览</title>
    <link href="https://doooyo.github.io/2019/04/22/SpringFramework%E6%A6%82%E8%A7%88/"/>
    <id>https://doooyo.github.io/2019/04/22/SpringFramework概览/</id>
    <published>2019-04-21T16:34:21.454Z</published>
    <updated>2019-04-21T16:34:21.454Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概览">概览</h2><p>SpringFramework3的框架结构图 (重要的里程碑版本)<em>(SpringFramework4去掉了Struts, 增加了WebSocket, Messaging)</em><em>(SpringFramework5增加了WebFlux, 最低java8, 所以支持响应式编程)</em><img src="https://upload-images.jianshu.io/upload_images/7896890-a7c003d175bd41af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>参考:<a href="https://www.cnblogs.com/dhcn/p/8905904.html" target="_blank" rel="noopener">Spring Framework5中的新特性</a><a href="https://blog.csdn.net/wd2014610/article/details/80061808" target="_blank" rel="noopener">Spring Framework架构</a></p><p><strong>SpringFramework一共分为五部分</strong></p><blockquote><ol><li><code>Core</code> springframework核心</li><li><code>AOP</code> 面向切面部分</li><li><code>DataAccess</code>  数据访问整合部分</li><li><code>Web</code> webmvc部分</li><li><code>Test</code> 测试部分</li></ol></blockquote><p>最核心(IOC)就<code>Core模块</code>中的三个 <strong><code>Core</code>, <code>Beans</code>, <code>Context</code></strong>它通过DI注入方式, 解决了Bean的生命周期统一管理<font color="orange">图中每个块即为一个jar包, <code>instrumentation</code>有两个包, <code>spring-context-support</code>未在图中列出, 一共19个jar包4.0版本取消了Struts, 增加了WebSocket和Messaging, 所以有20个jar包</font></p><p>下面我们就以各个包的作用以及依赖关系做出解释</p><h2 id="core核心模块-ioc依赖注入">Core核心模块 (IOC依赖注入)</h2><table><thead><tr><th style="text-align:center">- Core核心模块</th><th style="text-align:left">- 特点</th></tr></thead><tbody><tr><td style="text-align:center"><code>spring-core</code></td><td style="text-align:left">依赖注入IoC与DI的最基本实现, 只依赖<code>common-logging</code></td></tr><tr><td style="text-align:center"><code>spring-beans</code></td><td style="text-align:left">Bean工厂与bean的装配, 只依赖性<code>spring-core</code></td></tr><tr><td style="text-align:center"><code>spring-expression</code></td><td style="text-align:left">spring表达式语言, 只依赖性<code>spring-core</code></td></tr><tr><td style="text-align:center"><code>spring-context</code></td><td style="text-align:left">spring的context上下文即IoC容器, 它依赖了4个模块<code>spring-core</code>,<code>spring-beans</code>,<code>spring-expression</code>,<code>spring-aop</code></td></tr></tbody></table><p><img src="http://pic4.zhimg.com/v2-05b6565ecd67276d34d85d8c6ace61bb_b.png" alt></p><p>所以, 依赖了<code>spring-context</code>就相当于可以使用Spring的<code>IOC</code>和<code>AOP</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.17.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            注意spring-core默认依赖了jdk默认的日志框架common-logging</span></span><br><span class="line"><span class="comment">            如果使用了slf4j的门面日志logback, 则可以去掉common-logging</span></span><br><span class="line"><span class="comment">            如果去掉了, 但是没有依赖其他任何日志实现, 则会抛出异常</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="aop面向切面模块-动态代理">AOP面向切面模块 (动态代理)</h2><table><thead><tr><th style="text-align:center">- AOP模块</th><th style="text-align:left">- 特点</th></tr></thead><tbody><tr><td style="text-align:center"><code>spring-aop</code></td><td style="text-align:left">面向切面编程 (动态代理), 依赖<code>spring-core</code>, <code>spring-beans</code>, <code>aopalliance</code></td></tr><tr><td style="text-align:center"><code>spring-aspects</code></td><td style="text-align:left">集成AspectJ (编译期静态代理)</td></tr><tr><td style="text-align:center"><code>spring-instrument</code></td><td style="text-align:left">提供一些类级的工具支持和ClassLoader级的实现, 用于服务器; <font color="red">instrument是jdk5引入,jdk6发扬光大的, <code>ASM,CGLIB,javassist,jdk动态代理</code>之流只能通过反射或字节码方式创建一个新类, 但javaAgent是 <strong>JVM虚拟机级别的动态AOP代理</strong>, 在载入jvm前动态修改class的字节码, 注意是在原始字节码基础上做修改, 不会生成一个新的字节码文件, 也没有必须有接口等限制</font> 参考: <a href="https://www.jianshu.com/p/9f4e8dcb3e2f" target="_blank" rel="noopener">Java Instrument原理</a></td></tr><tr><td style="text-align:center"><code>spring-instrument-tomcat</code></td><td style="text-align:left">针对tomcat的instrument实现</td></tr></tbody></table><p><img src="http://pic4.zhimg.com/v2-4e8213b319d657a270fa456bbfc55643_b.png" alt></p><p>需要注意<code>aspectj</code>的支持需要单独依赖<code>spring-aspects</code></p><h2 id="dataaccess数据访问模块">DataAccess数据访问模块</h2><table><thead><tr><th style="text-align:center">- 数据访问模块</th><th style="text-align:left">- 特点</th></tr></thead><tbody><tr><td style="text-align:center"><code>spring-jdbc</code></td><td style="text-align:left">jdbc的支持</td></tr><tr><td style="text-align:center"><code>spring-tx</code></td><td style="text-align:left">事务控制, <font color="red">定义了七种事务传播行为</font></td></tr><tr><td style="text-align:center"><code>spring-orm</code></td><td style="text-align:left">对象关系映射，集成orm框架; 主要针对<code>JDO</code> ,<code>ibatis</code>, <code>hibernate</code>…</td></tr><tr><td style="text-align:center"><code>spring-oxm</code></td><td style="text-align:left">对象xml映射, 用以支持xml方式</td></tr><tr><td style="text-align:center"><code>spring-jms</code></td><td style="text-align:left">java消息服务</td></tr></tbody></table><p><img src="http://pic3.zhimg.com/v2-16c0fb6c425aef8c373925fc79d1aada_b.png" alt></p><h2 id="web模块">Web模块</h2><table><thead><tr><th style="text-align:center">- 数据访问模块</th><th style="text-align:left">- 特点</th></tr></thead><tbody><tr><td style="text-align:center"><code>spring-web</code></td><td style="text-align:left">基础web功能, 如文件上传, servlet等</td></tr><tr><td style="text-align:center"><code>spring-webmvc</code></td><td style="text-align:left">mvc实现, 通过策略模式, 所有都变成可配置, 视图技术支持包括<code>JSP、Velocity、Tiles、iText、POI、FreeMarker</code></td></tr><tr><td style="text-align:center"><code>spring-webmvc-portlet</code></td><td style="text-align:left">基于portlet的mvc实现, 类似<code>Fragment</code>片段组成的单页后端web应用, 与安卓<code>Fragment</code>, 前端单页<code>SPA</code>相对应</td></tr><tr><td style="text-align:center"><code>~~spring-struts~~</code></td><td style="text-align:left">与struts的集成, 不推荐, spring4已移除</td></tr><tr><td style="text-align:center"><code>spring-websocket</code></td><td style="text-align:left">springframework4开始支持</td></tr></tbody></table><p><img src="http://pic1.zhimg.com/v2-c53a936dcef5b2e337a48ad95d1c8840_b.png" alt></p><p>附注 :<code>protlet</code>类似<code>fragment</code>片段, 可以理解为服务端的单页面web应用, 和<code>servlet</code>传统模式有本质区别WebSphere容器支持了 JSR 168 Portlet API 的 Portlet 容器<img src="http://dl2.iteye.com/upload/attachment/0104/1719/6a43f993-c1e0-3d8b-983b-ea50912576d8.png" alt></p><h2 id="test测试模块">Test测试模块</h2><table><thead><tr><th style="text-align:center">- 测试模块</th><th style="text-align:left">- 特点</th></tr></thead><tbody><tr><td style="text-align:center"><code>spring-test</code></td><td style="text-align:left">spring测试, 提供junit与mock测试功能</td></tr><tr><td style="text-align:center"><code>spring-context-support</code></td><td style="text-align:left">spring额外支持包,  比如邮件服务、视图解析等</td></tr></tbody></table><h2 id="springframework4-0">springframework4.0</h2><p>去掉<code>spring-struts</code>的支持, 新增<code>spring-websocket</code>, <code>spring-messaging</code>两个模块(还支持groovy, <code>spring-beans-groovy</code>)</p><table><thead><tr><th style="text-align:center">- 4.0新增模块</th><th style="text-align:left">- 特点</th></tr></thead><tbody><tr><td style="text-align:center"><code>spring-websocket</code></td><td style="text-align:left">为web应用提供的高效通信工具</td></tr><tr><td style="text-align:center"><code>spring-messaging</code></td><td style="text-align:left">用于构建基于消息的应用程序</td></tr></tbody></table><p><img src="http://pic4.zhimg.com/v2-8d03bdf11aa484ff373bf7d35d9c095b_b.png" alt></p><h2 id="总结">总结</h2><p>根据以上的模块的依赖关系</p><ol><li>若只想使用sping的IOC和AOP, 则只需要引用<code>spring-context</code></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.17.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            注意spring-core默认依赖了jdk默认的日志框架common-logging</span></span><br><span class="line"><span class="comment">            如果使用了slf4j的门面日志logback, 则可以去掉common-logging</span></span><br><span class="line"><span class="comment">            如果去掉了, 但是没有依赖其他任何日志实现, 则会抛出异常</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>若想使用spingmvc, 则只需要引用<code>spring-webmvc</code></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.17.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概览&quot;&gt;概览&lt;/h2&gt;
&lt;p&gt;SpringFramework3的框架结构图 (重要的里程碑版本)
&lt;em&gt;(SpringFramework4去掉了Struts, 增加了WebSocket, Messaging)&lt;/em&gt;
&lt;em&gt;(SpringFramework5
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SPI(service provider interface 服务发现机制)</title>
    <link href="https://doooyo.github.io/2019/04/22/SPI(service%20provider%20interface%20%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E6%9C%BA%E5%88%B6)/"/>
    <id>https://doooyo.github.io/2019/04/22/SPI(service provider interface 服务发现机制)/</id>
    <published>2019-04-21T16:34:21.450Z</published>
    <updated>2019-04-21T16:34:21.450Z</updated>
    
    <content type="html"><![CDATA[<p>SPI全称为(Service Provider Interface) ，是JDK内置的一种服务提供发现机制；主要被框架的开发人员使用，比如java.sql.Driver接口，数据库厂商实现此接口即可，当然要想让系统知道具体实现类的存在，还需要使用固定的存放规则，需要在classpath下的META-INF/services/目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类；日志门面框架和DriverManager数据库驱动都是基于此。</p><blockquote><p>spi是一种动态发现并替换的机制, 比如运行时动态添加接口实现,主要针对厂商或者插件;典型的比如数据库驱动Driver, slf4j日志框架(外观模式)基于接口编程 + 策略模式 + 配置文件</p><blockquote><p>1.定义一组接口<code>com.doyo.learn.spi.IHello</code></p></blockquote><blockquote><p>2.接口的多个实现<code>com.doyo.learn.spi.impl.HelloV1Impl</code><code>com.doyo.learn.spi.impl.HelloV2Impl</code></p></blockquote><blockquote><p>3.在 <code>src/main/resources/</code> 下建立 <code>/META-INF/services</code> 目录,新增一个以接口命名的文件/META-INF/services/com.doyo.learn.spi.IHello文件的内容是实现类的全名,可以写上多个实现, 比如:<code>com.doyo.learn.spi.impl.HelloV1Impl com.doyo.learn.spi.impl.HelloV2Impl</code></p></blockquote><blockquote><p>4.使用ServiceLoader来加载指定配置文件中的实现</p></blockquote></blockquote><p>例如有一个开源搜索模块基于接口编程规范,可能基于文件系统,可能基于数据库; 接口如下:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">package</span> <span class="string">org.xyz.spi;</span></span><br><span class="line"><span class="string">import</span> <span class="string">java.util.List;</span></span><br><span class="line"><span class="string">public</span> <span class="string">interface</span> <span class="string">ISearch</span> <span class="string">&#123;</span></span><br><span class="line">   <span class="string">public</span> <span class="string">List</span> <span class="string">serch(String</span> <span class="string">keyword);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>A公司提供文件搜索实现<code>com.A.spi.impl.FileSearch</code>A公司发布jar时,文件<code>META-INF/services/org.xyz.spi.ISearch</code>中填写如下内容:<code>com.A.spi.impl.FileSearch</code></p><p>B公司提供数据库搜索实现<code>com.B.spi.impl.DatabaseSearch</code>B公司发布jar时,文件<code>META-INF/services/org.xyz.spi.ISearch</code>中填写如下内容:<code>com.B.spi.impl.DatabaseSearch</code></p><p>最后使用者会通过开源搜索jar包(<code>门面模式</code>)的工厂类来使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.xyz.factory;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.ServiceLoader;</span><br><span class="line"><span class="keyword">import</span> org.xyz.spi.ISearch;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Search <span class="title">newSearch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Search search = <span class="keyword">null</span>;</span><br><span class="line">        ServiceLoader&lt;Search&gt; serviceLoader = ServiceLoader.load(Search.class);</span><br><span class="line">        Iterator&lt;Search&gt; searchs = serviceLoader.iterator();</span><br><span class="line">        <span class="keyword">if</span> (searchs.hasNext()) &#123;</span><br><span class="line">            search = searchs.next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> search;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结: 这是一种接口与实现分离解耦,提升可扩展性,轻松实现功能模块的可插拔;开发者无须手动注入实现,只需引入<code>具体实现jar包 + spi接口jar包</code>参考:<a href="https://blog.csdn.net/sigangjun/article/details/79071850" target="_blank" rel="noopener">java中的SPI机制</a><a href="https://blog.csdn.net/lemon89/article/details/79189475" target="_blank" rel="noopener">jdbc的设计</a><a href="https://www.cnblogs.com/lovesqcc/p/5229353.html" target="_blank" rel="noopener">spi服务加载的手工实现</a></p><h2 id="serviceloader">ServiceLoader</h2><p>从上面看出最终会使用<code>ServiceLoader</code>来实现类的载入</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="string">读取`/META-INF/services/&#123;接口全路径名文件&#125;`配置,获取实现类的全名称字符串</span></span><br><span class="line"><span class="number">2.</span><span class="string">java反射机制(或者采用Class.forName或者ClassLoader)构造服务实现类的实例</span></span><br><span class="line"><span class="number">3.</span><span class="string">官方实现</span> <span class="string">使用了迭代器,</span> <span class="string">ClassLoader,</span> <span class="string">以及System.setSecurityManager(new</span> <span class="string">SecurityManager());开启权限检查</span></span><br></pre></td></tr></table></figure><p>java简单实现<code>Serviceloader</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleServiceLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">"/META-INF/services/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">load</span><span class="params">(Class&lt;T&gt; cls)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; implClasses = readServiceFile(cls);</span><br><span class="line">        List&lt;T&gt; implList = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String implClass : implClasses) &#123;</span><br><span class="line">            Class&lt;T&gt; c;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                c = (Class&lt;T&gt;) Class.forName(implClass);</span><br><span class="line">                implList.add(c.newInstance());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> implList;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">readServiceFile</span><span class="params">(Class&lt;?&gt; cls)</span> </span>&#123;</span><br><span class="line">        String infName = cls.getCanonicalName();</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        String fileName = cls.getResource(PREFIX + infName).getPath();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="keyword">new</span> File(fileName)));</span><br><span class="line">            String line;</span><br><span class="line">            List&lt;String&gt; implClasses = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                implClasses.add(line);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> implClasses;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"File not found: "</span> + fileName);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Read file failed: "</span> + fileName);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="slf4j日志框架">Slf4j日志框架</h2><blockquote><p>使用了门面模式,注意只有slf4j是无法打印日志的(最优选择是<code>Logback＋SLF4J</code> (Logback是Log4j的改进版))<code>SLF4J(Log4j/Logback/Commons-logging(Apache)/logging(JDK))</code></p></blockquote><ul><li>java日志框架历史</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="attr">Log4j:</span></span><br><span class="line">  <span class="number">1996</span><span class="string">年早期,</span> <span class="string">Log4j是java社区的日志标准(后成为apache基金会项目一员)</span></span><br><span class="line"><span class="number">2.</span><span class="attr">JUL:</span></span><br><span class="line">  <span class="string">Java</span> <span class="string">Util</span> <span class="string">Logging,由Sun在2002年推出java标准库(Apache曾建议过将Log4j纳入java标准库被拒)</span></span><br><span class="line"><span class="number">3.</span><span class="attr">common-logging:</span></span><br><span class="line">  <span class="string">原因是Log4j和JUL比较混乱且接口不统一,所以Apache推出的统一日志接口(内部有一个Simple</span> <span class="string">Log简单实现);以便统一Log4j和JUL</span></span><br><span class="line"><span class="number">4.</span><span class="attr">Slf4j:</span> <span class="string">Ceki</span> <span class="string">Gülcü离开Apache后创建的Slf4j日志门面接口,其实现为logback</span></span><br><span class="line"><span class="number">5.</span><span class="string">阵营:</span> <span class="string">common-logging阵营(Apache),</span> <span class="string">Slf4j阵营(Ceki</span> <span class="string">Gülcü)</span></span><br><span class="line"></span><br><span class="line"><span class="number">6.</span><span class="attr">Log4j2:</span> <span class="string">Apache眼看Slf4j快要将其超越,</span> <span class="string">随即2012/07重写了Log4j实现,且拥有Slf4j实现Logback的全部特性,所以两个版本无法兼容</span></span><br><span class="line"></span><br><span class="line"><span class="string">使用方式:</span></span><br><span class="line">  <span class="string">Slf4j</span> <span class="string">+</span> <span class="string">Logback</span></span><br><span class="line">  <span class="string">Commons</span> <span class="string">Logging</span> <span class="string">+</span> <span class="string">Log4j</span></span><br><span class="line"></span><br><span class="line"><span class="string">实现机制:</span></span><br><span class="line">    <span class="string">Commons</span> <span class="string">Logging通过动态查找机制,使用自己的ClassLoader寻找和载入本地实现;主要通过扫描`META-INF/services/org.apache.commons.logging.LogFactory`配置文件,来查找`org.apache.commons.logging.impl.LogFactoryImpl.java`实现类</span></span><br><span class="line">    <span class="string">Slf4j是在编译期间,静态绑定本地Log实现库,</span> <span class="string">通过查找类路径下`org.slf4j.impl.StaticLoggerBinder`,然后在`StaticLoggerBinder`中进行绑定</span></span><br></pre></td></tr></table></figure><p>下面将以<code>Slf4j + Logback</code>来说明日志如何加载</p><ul><li><p>第一句话开始<code>Logger logger = LoggerFactory.getLogger(Object.class);</code>SLF4J只有接口,没有实现,所以各大厂商通过META-INF/services/org.apache.commons.logging.LogFactory配置文件</p></li><li><p>进入内部</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getLogger</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    Logger logger = getLogger(clazz.getName());</span><br><span class="line">    <span class="keyword">if</span> (DETECT_LOGGER_NAME_MISMATCH) &#123;</span><br><span class="line">        Class&lt;?&gt; autoComputedCallingClass = Util.getCallingClass();</span><br><span class="line">        <span class="keyword">if</span> (autoComputedCallingClass != <span class="keyword">null</span> &amp;&amp; nonMatchingClasses(clazz, autoComputedCallingClass)) &#123;</span><br><span class="line">            Util.report(String.format(<span class="string">"Detected logger name mismatch. Given name: \"%s\"; computed name: \"%s\"."</span>, logger.getName(),</span><br><span class="line">                            autoComputedCallingClass.getName()));</span><br><span class="line">            Util.report(<span class="string">"See "</span> + LOGGER_NAME_MISMATCH_URL + <span class="string">" for an explanation"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> logger;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>到bind方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Set&lt;URL&gt; staticLoggerBinderPathSet = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// skip check under android, see also</span></span><br><span class="line">        <span class="comment">// http://jira.qos.ch/browse/SLF4J-328</span></span><br><span class="line">        <span class="keyword">if</span> (!isAndroid()) &#123;</span><br><span class="line">            staticLoggerBinderPathSet = findPossibleStaticLoggerBinderPathSet();</span><br><span class="line">            reportMultipleBindingAmbiguity(staticLoggerBinderPathSet);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// the next line does the binding</span></span><br><span class="line">        StaticLoggerBinder.getSingleton();</span><br><span class="line">        INITIALIZATION_STATE = SUCCESSFUL_INITIALIZATION;</span><br><span class="line">        reportActualBinding(staticLoggerBinderPathSet);</span><br><span class="line">        fixSubstituteLoggers();</span><br><span class="line">        replayEvents();</span><br><span class="line">        <span class="comment">// release all resources in SUBST_FACTORY</span></span><br><span class="line">        SUBST_FACTORY.clear();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoClassDefFoundError ncde) &#123;</span><br><span class="line">        String msg = ncde.getMessage();</span><br><span class="line">        <span class="keyword">if</span> (messageContainsOrgSlf4jImplStaticLoggerBinder(msg)) &#123;</span><br><span class="line">            INITIALIZATION_STATE = NOP_FALLBACK_INITIALIZATION;</span><br><span class="line">            Util.report(<span class="string">"Failed to load class \"org.slf4j.impl.StaticLoggerBinder\"."</span>);</span><br><span class="line">            Util.report(<span class="string">"Defaulting to no-operation (NOP) logger implementation"</span>);</span><br><span class="line">            Util.report(<span class="string">"See "</span> + NO_STATICLOGGERBINDER_URL + <span class="string">" for further details."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            failedBinding(ncde);</span><br><span class="line">            <span class="keyword">throw</span> ncde;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.lang.NoSuchMethodError nsme) &#123;</span><br><span class="line">        String msg = nsme.getMessage();</span><br><span class="line">        <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.contains(<span class="string">"org.slf4j.impl.StaticLoggerBinder.getSingleton()"</span>)) &#123;</span><br><span class="line">            INITIALIZATION_STATE = FAILED_INITIALIZATION;</span><br><span class="line">            Util.report(<span class="string">"slf4j-api 1.6.x (or later) is incompatible with this binding."</span>);</span><br><span class="line">            Util.report(<span class="string">"Your binding is version 1.5.5 or earlier."</span>);</span><br><span class="line">            Util.report(<span class="string">"Upgrade your binding to version 1.6.x."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> nsme;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        failedBinding(e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected initialization failure"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第七行的<code>findPossibleStaticLoggerBinderPathSet</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Set&lt;URL&gt; <span class="title">findPossibleStaticLoggerBinderPathSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// use Set instead of list in order to deal with bug #138</span></span><br><span class="line">    <span class="comment">// LinkedHashSet appropriate here because it preserves insertion order</span></span><br><span class="line">    <span class="comment">// during iteration</span></span><br><span class="line">    Set&lt;URL&gt; staticLoggerBinderPathSet = <span class="keyword">new</span> LinkedHashSet&lt;URL&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ClassLoader loggerFactoryClassLoader = LoggerFactory.class.getClassLoader();</span><br><span class="line">        Enumeration&lt;URL&gt; paths;</span><br><span class="line">        <span class="keyword">if</span> (loggerFactoryClassLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">            paths = ClassLoader.getSystemResources(STATIC_LOGGER_BINDER_PATH);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            paths = loggerFactoryClassLoader.getResources(STATIC_LOGGER_BINDER_PATH);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (paths.hasMoreElements()) &#123;</span><br><span class="line">            URL path = paths.nextElement();</span><br><span class="line">            staticLoggerBinderPathSet.add(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">        Util.report(<span class="string">"Error getting resources from path"</span>, ioe);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> staticLoggerBinderPathSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第十二行代码</li></ul><p>其中<code>STATIC_LOGGER_BINDER_PATH</code>为<code>org/slf4j/impl/StaticLoggerBinder.class</code>注意:<code>所有slf4j的实现，在提供的jar包路径下，一定是有&quot;org/slf4j/impl/StaticLoggerBinder.class&quot;存在的, 由于可能出现引用多个日志框架,所以reportMultipleBindingAmbiguity(staticLoggerBinderPathSet);方法会打印警告</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paths = loggerFactoryClassLoader.getResources(STATIC_LOGGER_BINDER_PATH);</span><br></pre></td></tr></table></figure><p>参考: <a href="https://www.cnblogs.com/xrq730/p/8619156.html" target="_blank" rel="noopener">https://www.cnblogs.com/xrq730/p/8619156.html</a></p><h2 id="jdbc的spi设计">JDBC的SPI设计</h2><blockquote><p><code>Driver接口</code>:Sun公司提供了JDBC驱动的统一接口规范<code>java.sql.Driver</code>,各大厂商(oracle/mysql/db2/sqlserver)驱动只要实现其接口逻辑<code>DriverManager管理类</code>:主要是注册管理Driver实现类</p></blockquote><h4 id="流程">流程</h4><p>1.启动后,DriverManager有一个静态代码块,对Driver进行加载到内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    loadInitialDrivers();</span><br><span class="line">    println(<span class="string">"JDBC DriverManager initialized"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.<code>loadInitialDrivers</code>方法首先会尝试从系统变量中加载,若没有则通过SPI加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.尝试获取JDBC驱动的系统变量</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    drivers = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;String&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> System.getProperty(<span class="string">"jdbc.drivers"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    drivers = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果系统变量存在则Class.forName进行加载,注意第二个参数为true,即加载时需要运行静态代码块;后面可以看到Driver实现类的静态代码块在进行注册到DriverManager</span></span><br><span class="line"><span class="keyword">if</span> (drivers == <span class="keyword">null</span> || drivers.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">String[] driversList = drivers.split(<span class="string">":"</span>);</span><br><span class="line">println(<span class="string">"number of Drivers:"</span> + driversList.length);</span><br><span class="line"><span class="keyword">for</span> (String aDriver : driversList) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        println(<span class="string">"DriverManager.Initialize: loading "</span> + aDriver);</span><br><span class="line">        Class.forName(aDriver, <span class="keyword">true</span>,</span><br><span class="line">                ClassLoader.getSystemClassLoader());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        println(<span class="string">"DriverManager.Initialize: load failed: "</span> + ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.尝试SPI加载</span></span><br><span class="line">AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br><span class="line">        Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(driversIterator.hasNext()) &#123;</span><br><span class="line">                <span class="comment">// 迭代遍历的时候,加载并初始化Driver实现类</span></span><br><span class="line">                driversIterator.next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">        <span class="comment">// Do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3.<code>Class.forName</code>进行加载MySql驱动的Driver实现类会有一个静态代码块,在向DriverManager进行注册<code>DriverInfo</code>,info对象内部包含Driver实现类的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.mysql.cj.jdbc.Driver静态代码块</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 注意new了一个Driver实例并注册到DriverManager</span></span><br><span class="line">        java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.<code>SPI</code>进行加载截取上面的代码片段, 重点是<code>ServiceLoader.load(Driver.class)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br><span class="line">        Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(driversIterator.hasNext()) &#123;</span><br><span class="line">                driversIterator.next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">        <span class="comment">// Do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>再来看<code>ServieLoader</code>内部的迭代器如何初始化Driver并注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> S <span class="title">nextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    String cn = nextName;<span class="comment">//上一步找到的服务实现者全限定名</span></span><br><span class="line">    nextName = <span class="keyword">null</span>;</span><br><span class="line">    Class&lt;?&gt; c = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//加载字节码返回class对象.但并不去初始化（换句话就是说不去执行这个类中的static块与static变量初始化）</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">        c = Class.forName(cn, <span class="keyword">false</span>, loader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">"Provider "</span> + cn + <span class="string">" not found"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">"Provider "</span> + cn  + <span class="string">" not a subtype"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//初始化这个实现类.将会通过static块的方式触发实现类注册到DriverManager(其中组合了一个CopyOnWriteArrayList的registeredDrivers成员变量)中</span></span><br><span class="line">        S p = service.cast(c.newInstance());</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        providers.put(cn, p);<span class="comment">//本地缓存 （全限定名，实现类对象）</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">"Provider "</span> + cn + <span class="string">" could not be instantiated"</span>,</span><br><span class="line">             x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error();          <span class="comment">// This cannot happen</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.<code>Class.forName(cn, false, loader)</code>中的cn第22行实际在读取<code>META-INF/services/java.sql.Driver</code>里的内容内容为: <code>com.mysql.cj.jdbc.Driver</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nextName != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (configs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// SPI资源路径</span></span><br><span class="line">            String fullName = PREFIX + service.getName();</span><br><span class="line">            <span class="keyword">if</span> (loader == <span class="keyword">null</span>)</span><br><span class="line">                configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                configs = loader.getResources(fullName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">            fail(service, <span class="string">"Error locating configuration files"</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次时,会去读取META-INF中的SPI资源里的配置信息</span></span><br><span class="line">    <span class="keyword">while</span> ((pending == <span class="keyword">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读取文件内容</span></span><br><span class="line">        pending = parse(service, configs.nextElement());</span><br><span class="line">    &#125;</span><br><span class="line">    nextName = pending.next();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SPI全称为(Service Provider Interface) ，是JDK内置的一种服务提供发现机制；主要被框架的开发人员使用，比如java.sql.Driver接口，数据库厂商实现此接口即可，当然要想让系统知道具体实现类的存在，还需要使用固定的存放规则，需要在cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringCloud初体验</title>
    <link href="https://doooyo.github.io/2019/04/22/SpringCloud%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>https://doooyo.github.io/2019/04/22/SpringCloud初体验/</id>
    <published>2019-04-21T16:34:21.445Z</published>
    <updated>2019-04-21T16:34:21.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="springboot1-x升级2-x">SpringBoot1.x升级2.x</h2><p>1.<code>spring-boot-starter-parent</code>依赖改为<code>2.x</code>版本2.启动类修改<code>SpringBootServletInitializer</code>包名3.全局错误控制器<code>ErrorController</code>更换包名重写<code>/error</code>路由</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = &#123;<span class="string">"/error"</span>&#125;)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">error</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="comment">//return getResponse(HttpCode.URI_NOT_FOUND, null, "uri not found.");</span></span><br><span class="line"><span class="keyword">int</span> status = (Integer) request.getAttribute(<span class="string">"javax.servlet.error.status_code"</span>);</span><br><span class="line"><span class="keyword">if</span>(status == <span class="number">401</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> getResponse(HttpCode.LOGIN_FAIL, <span class="keyword">null</span>, <span class="string">"未登陆"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(status == <span class="number">403</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> getResponse(HttpCode.PERMISSION_DENY, <span class="keyword">null</span>, <span class="string">"未授权"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(status == <span class="number">404</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> getResponse(HttpCode.URI_NOT_FOUND, <span class="keyword">null</span>, <span class="string">"资源未找到"</span>);</span><br><span class="line">&#125;  <span class="keyword">else</span> <span class="keyword">if</span>(status == <span class="number">500</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> getResponse(HttpCode.INTERNAL_SERVER_ERROR, <span class="keyword">null</span>, <span class="string">"系统异常"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> getResponse(HttpCode.INTERNAL_SERVER_ERROR, <span class="keyword">null</span>, <span class="string">"系统异常"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.config配置~~<code>WebMvcConfigurerAdapter</code>~~已过时, 替换为<code>WebMvcConfigurationSupport</code></p><p>5.<code>Pageable</code>在SpringBoot2.x无法注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> </span>&#123;</span><br><span class="line">argumentResolvers.add(<span class="keyword">new</span> PageableHandlerMethodArgumentResolver());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.<code>application.yml</code>的配置变更</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  servlet:</span> <span class="comment"># 添加servlet节点</span></span><br><span class="line"><span class="attr">    context-path:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure><p>7.<code>javax.validation</code>替换<code>org.hibernate.validator</code></p><h2 id="ribbon">Ribbon</h2><p>它是客户端负载均衡器, <code>Eureka</code>是基于<code>AP</code>的客户端发现, <code>Ribbon</code>会从注册中心(<code>Eureka Server</code>)拉取注册的服务列表到Client, 然后<code>Ribbon</code>通过剔除无效服务后再进行负载均衡策略, 选取一个服务进行直接调用</p><blockquote><ol><li>服务发现主要是基于<code>Eureka</code>注册中心实现客户端发现服务列表, 即根据服务名找出所有服务实例列表</li><li>服务选择规则根据策略从多个有效服务实例中选取一个进行调用,</li><li>服务监听检测失效服务并进行剔除, 通过<code>IPing</code>接口的<code>PingTask</code>定时器任务, 默认<code>pingIntervalSeconds=10</code>, 即每10秒钟向<code>Eureka Server</code>发送一次<code>ping</code>包</li><li>五大组件<font color="red">每个接口都可以自己实现并配置替换内置实现, 且经常会自定义IRule策略规则</font><code>ILoadBalancer</code><code>ServiceList</code> 服务器列表的处理类, 用来维护服务器列表<code>ServerListFilter</code> 服务器的过滤类<code>IRule</code> 我们经常会自定义策略规则<code>IPing</code> 查看服务器是否存活, 是定时器任务, 默认10s<code>ping</code>一次</li><li>流程:通过<code>ServiceList</code>获取有效的服务实例列表;再通过<code>ServerListFilter</code>过滤一些服务实例, 比如剔除负载高的或者通讯故障率高(短路)的;最后通过<code>IRule</code>负载均衡策略选取一个进行调用</li></ol></blockquote><h3 id="配置五大接口自定义实现">配置五大接口自定义实现</h3><p>配置可以通过<code>ConfigurationManager</code>配置实例类进行代码配置, 也可以通过<code>application.yml</code>配置</p><table><thead><tr><th style="text-align:center">- 自定义接口实现配置</th><th style="text-align:left">- 描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>&lt;clientName&gt;.ribbon.NFLoadBalancerClassName</code></td><td style="text-align:left">需实现<code>ILoadBalancer</code>接口</td></tr><tr><td style="text-align:center"><code>&lt;clientName&gt;.ribbon.NFLoadBalancerRuleClassName</code></td><td style="text-align:left">需实现<code>IRule</code>接口, 这个是我们可能经常需要自定义负载均衡策略规则</td></tr><tr><td style="text-align:center"><code>&lt;clientName&gt;.ribbon.NFLoadBalancerPingClassName</code></td><td style="text-align:left">需实现<code>IPing</code>, 一般很少重写, 默认10s发送一次<code>ping</code></td></tr><tr><td style="text-align:center"><code>&lt;clientName&gt;.ribbon.NIWSServerListClassName</code></td><td style="text-align:left">需实现<code>ServerList</code>, 一般很少重写</td></tr><tr><td style="text-align:center"><code>&lt;clientName&gt;.ribbon.NIWSServerListFilterClassName</code></td><td style="text-align:left">需实现<code>ServerListFilter</code>, 一般很少重写</td></tr></tbody></table><h3 id="七个负载均衡策略规则">七个负载均衡策略规则</h3><p><code>随机 (Random)</code>, <code>轮询 (RoundRobin)</code>, <code>一致性哈希 (ConsistentHash)</code>, <code>哈希 (Hash)</code>, <code>加权（Weighted）</code>…</p><table><thead><tr><th style="text-align:center">- Ribbon负载均衡规则</th><th style="text-align:left">- 规则描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>RoundRobinRule</code><br>(轮询-默认)</td><td style="text-align:left">简单轮询服务列表来选择服务器(默认)</td></tr><tr><td style="text-align:center"><code>AvailabilityFilteringRule</code><br>(排除高负载和短路)</td><td style="text-align:left"><font color="orange">以下两种情况会被过滤掉 : <br>情况1 : 默认3次连接失败, 这台服务器就会被设置为&quot;短路&quot;状态, 短路持续30s, 再次连接失败则几何递增<br>情况2 : 并发数过高的服务器, <code>&lt;clientName&gt;.&lt;clientConfigNameSpace&gt;.ActiveConnectionsLimit</code>配置并发连接上限</font></td></tr><tr><td style="text-align:center"><code>WeightedResponseTimeRule</code><br>(加权)</td><td style="text-align:left">为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td></tr><tr><td style="text-align:center"><code>ZoneAvoidanceRule</code><br>(区域划分)</td><td style="text-align:left">以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等</td></tr><tr><td style="text-align:center"><code>BestAvailableRule</code><br>(并发请求数最少)</td><td style="text-align:left">忽略哪些短路的服务器，并选择并发数较低的服务器。</td></tr><tr><td style="text-align:center"><code>RandomRule</code><br>(随机)</td><td style="text-align:left">随机选择一个可用的服务器</td></tr><tr><td style="text-align:center"><code>RetryRule</code><br>(重试)</td><td style="text-align:left">重试机制的选择逻辑</td></tr></tbody></table><p>附上<code>AvailabilityFilteringRule</code>规则的三个配置</p><blockquote><ol><li>设置为<code>短路</code>的连接失败次数, 默认3次<code>niws.loadbalancer.&lt;clientName&gt;.connectionFailureCountThreshold</code></li><li>状态<code>短路</code>的持续时间, 默认30s<code>niws.loadbalancer.&lt;clientName&gt;.circuitTripMaxTimeoutSeconds</code></li><li>服务并发访问数量上限, 默认Integer.MAX_VALUE<code>&lt;clientName&gt;.&lt;clientConfigNameSpace&gt;.ActiveConnectionsLimit</code></li></ol></blockquote><h3 id="自定义负载均衡策略">自定义负载均衡策略</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义策略, 需要实现IRule接口</span></span><br><span class="line"><span class="comment">// 构建一个60%的概率选择8091端口, 40%概率选择8092端口的规则</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProbabilityRandomRule</span> <span class="keyword">implements</span> <span class="title">IRule</span> </span>&#123;</span><br><span class="line">ILoadBalancer balancer = <span class="keyword">new</span> BaseLoadBalancer();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">List&lt;Server&gt; allServers = balancer.getAllServers();</span><br><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> number = random.nextInt(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (number &lt; <span class="number">7</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> findServer(allServers,<span class="number">8091</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> findServer(allServers,<span class="number">8092</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Server <span class="title">findServer</span><span class="params">(List&lt;Server&gt; allServers, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Server server : allServers) &#123;</span><br><span class="line"><span class="keyword">if</span> (server.getPort() == port) &#123;</span><br><span class="line"><span class="keyword">return</span> server;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"NULL port="</span>+port);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoadBalancer</span><span class="params">(ILoadBalancer lb)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.balancer = lb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ILoadBalancer <span class="title">getLoadBalancer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.balancer;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRuleClientApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 1、设置请求的服务器</span></span><br><span class="line">ConfigurationManager.getConfigInstance().setProperty(<span class="string">"happybks-client.ribbon.listOfServers"</span>,</span><br><span class="line"><span class="string">"localhost:8091,localhost:8092"</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2、 配置规则处理类</span></span><br><span class="line"><span class="comment">//本示例略，先默认使用其默认负载均衡策略规则</span></span><br><span class="line">ConfigurationManager.getConfigInstance().setProperty(<span class="string">"happybks-client.ribbon.NFLoadBalancerRuleClassName"</span>,MyProbabilityRandomRule.class.getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、获取 REST 请求客户端</span></span><br><span class="line">RestClient client = (RestClient) ClientFactory.getNamedClient(<span class="string">"happybks-client"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、创建请求实例</span></span><br><span class="line">HttpRequest request = HttpRequest.newBuilder().uri(<span class="string">"/carsInfo/onsale"</span>).build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5、发 送 10 次请求到服务器中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"the "</span>+(i+<span class="number">1</span>)+<span class="string">"th: "</span>);</span><br><span class="line">HttpResponse response = client.executeWithLoadBalancer(request);</span><br><span class="line">String result = response.getEntity(String.class);</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置">配置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置自定义负载均衡规则: &lt;clientName&gt;.ribbon.NFLoadBalancerRuleClassName: &lt;自定义类限定名&gt;</span></span><br><span class="line"><span class="attr">product-server:</span></span><br><span class="line"><span class="attr">  ribbon:</span></span><br><span class="line"><span class="attr">    NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RoundRobinRule</span></span><br></pre></td></tr></table></figure><p>参考 :<a href="https://www.cnblogs.com/cxxjohnson/p/9027919.html" target="_blank" rel="noopener">Ribbon负载均衡器</a></p><h2 id="feign">Feign</h2><p>这是一个类似<code>Retrofit</code>的http客户端调用组件, 因为和<code>Dubbo RPC</code>调用不同, SpringCloud采用了<code>Http Restful</code>形式进行服务调用;</p><h3 id="feign使用httpclient和okhttp3">Feign使用HttpClient和OkHttp3</h3><p>SpringCloud的使用到<code>Ribbon</code>客户端负载均衡调用有三类 :</p><blockquote><ol><li><code>RestTemplate</code></li><li><code>Feign</code></li><li><code>Zuul</code>服务网关 (现已使用<code>SpringCloud GateWay</code>替换)</li></ol></blockquote><p><font color="red">首先说明几者逻辑关系 :</font></p><ol><li><em>Zuul服务网关</em> 底层使用了<em>Ribbon客户端负载均衡</em><em>Ribbon</em>有两个实现: <code>HttpClient</code>和<code>OkHttp3</code>, 默认使用的前者, 当然你可以配置使用后者</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.squareup.okhttp3<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.yml添加ribbon配置</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line"><span class="attr">  httpclient:</span></span><br><span class="line"><span class="attr">     enabled:</span> <span class="literal">false</span> <span class="comment"># 默认开启需要禁用</span></span><br><span class="line"><span class="attr">  okhttp:</span></span><br><span class="line"><span class="attr">     enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><font color="red">2. <em>Fegin</em> 也使用了<code>Ribbon</code>, 当然可以直接使用上述配置来更改<code>Ribbon</code>的默认配置, 但更推荐使用<code>Fegin</code>的配置来替换;<s>默认有四种实现:(1) <code>Default</code>: <em>使用HttpURLConnection构建</em>(2) <code>LoadBalancerFeignClient</code>: <em>使用Apache HttpClient构建</em>(3) <code>OkHttpClient</code>: <em>使用OkHttp3构建</em>(4) <code>TraceFeignClient</code>: <em>这是<code>sleuth</code>实现的</em></s></font></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- feign整合OkHttp --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在application.yml文件配置fegin</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">  httpclient:</span></span><br><span class="line"><span class="attr">      enabled:</span> <span class="literal">false</span> <span class="comment">#关闭, 重点还是在于依赖了哪个jar包</span></span><br><span class="line"><span class="attr">  okhttp:</span></span><br><span class="line"><span class="attr">      enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="feign使用步骤">Feign使用步骤</h3><h4 id="1-定义服务对外暴露接口">(1)定义服务对外暴露接口</h4><p>比如拿<code>product-server</code>服务举例 :首先添加maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注意老版本叫做spring-cloud-starter-feign --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>提供对外调用接口jar包, 这和<code>RPC</code>形式上一致, 但有所区别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"product-server"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/product/listForOrder"</span>)</span><br><span class="line">    <span class="function">List&lt;ProductInfoOutput&gt; <span class="title">listForOrder</span><span class="params">(@RequestBody List&lt;String&gt; productIdList)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/product/decreaseStock"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">decreaseStock</span><span class="params">(@RequestBody List&lt;DecreaseStockInput&gt; decreaseStockInputList)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-调用方添加服务方接口依赖">(2)调用方添加服务方接口依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.doyo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>product-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意启动类上需要添加一个注解<code>@EnableFeignClients</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="comment">// 注意添加接口包扫描路径, 否则不会扫描并注入</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span>(basePackages = <span class="string">"org.doyo.product.client"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="安装rabbitmq">安装rabbitmq</h2><p>由于<code>docker.hub</code>速度太慢, 先设置仓库镜像加速</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"><span class="meta">#</span> 添加如下代码</span><br><span class="line"><span class="meta">#</span> &#123;</span><br><span class="line"><span class="meta">#</span>  "registry-mirrors": ["https://fy707np5.mirror.aliyuncs.com"]</span><br><span class="line"><span class="meta">#</span> &#125;</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"><span class="meta">#</span> 如果是mac版本</span><br><span class="line"><span class="meta">#</span> preferences-&gt;daemon-&gt;registry mirrors 内添加镜像地址即可</span><br></pre></td></tr></table></figure><p>拉取<code>rabbitmq</code>镜像, 并启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker pull rabbitmq:3.7.14-management</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 不指定账号密码默认都是guest</span><br><span class="line">docker run -itd --hostname my-rabbit --name my-rabbit -e RABBITMQ_DEFAULT_USER=user -e RABBITMQ_DEFAULT_PASS=password -p 5672:5672 -p 15672:15672 rabbitmq:3.7.14-management</span><br></pre></td></tr></table></figure><p>端口说明 :</p><blockquote><p><code>4369</code>：epmd，RabbitMQ节点和CLI工具使用的对等发现服务<code>5672,5671</code>：AMQP 0-9-1和1.0客户端使用没有和使用TLS<code>25672</code>：用于节点间和CLI工具通信（Erlang分发服务器端口），并从动态范围分配（默认情况下限于单个端口，计算为AMQP端口+ 20000）。除非确实需要这些端口上的外部连接（例如，群集使用联合或CLI工具在子网外的计算机上使用），否则不应公开这些端口。有关详情， 请参阅网络指南<code>35672-35682</code>：由CLI工具（Erlang分发客户端端口）用于与节点通信，并从动态范围（计算为服务器分发端口+ 10000到服务器分发端口+ 10010）进行分配。有关详情， 请参阅网络指南<code>15672</code>：HTTP API客户端，管理UI和rabbitmqadmin（仅当启用了管理插件时）<code>61613,61614</code>：没有和使用TLS的STOMP客户端（仅当启用了STOMP插件时）<code>1883,8883</code>:( 如果启用了MQTT插件，则没有和使用TLS的MQTT客户端<code>15674</code>：STOMP-over-WebSockets客户端（仅当启用了Web STOMP插件时）<code>15675</code>：MQTT-over-WebSockets客户端（仅当启用了Web MQTT插件时）</p></blockquote><p>Redis启动命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker stop redis</span><br><span class="line">docker rm redis</span><br><span class="line">docker run -itd -p 6379:6379 -v `pwd`/data:/data --name redis -v `pwd`/redis.conf:/etc/redis/redis_default.conf hub.c.163.com/public/redis:2.8.4</span><br></pre></td></tr></table></figure><h2 id="config">Config</h2><p>主要用于动态更新和加载配置文件</p><h3 id="添加依赖">添加依赖</h3><p>服务端依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- config server --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- bus --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- monitor --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-monitor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 本身就是一个config服务, 所以需要注册Eureka --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>客户端依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="服务端注解-enableconfigserver">服务端注解<code>@EnableConfigServer</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span> <span class="comment">// 需要指定git地址</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置文件">配置文件</h3><p>需要指定git仓库地址</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8083</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">config-server</span> <span class="comment">#服务名</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      server:</span></span><br><span class="line"><span class="attr">        git:</span> <span class="comment">#git仓库地址</span></span><br><span class="line"><span class="attr">          uri:</span> <span class="attr">https://github.com/DoyuLy/cloud-config-repo</span></span><br><span class="line"><span class="attr">          username:</span> <span class="string">duyud@qq.com</span></span><br><span class="line"><span class="attr">          password:</span> <span class="string">duyu1988</span></span><br><span class="line">          <span class="comment"># 本地clone地址, 最好不要在本项目里, 避免被覆盖</span></span><br><span class="line"><span class="attr">          basedir:</span> <span class="string">/Users/apple/idea/spring-cloud-bingo-config-repo</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span></span><br><span class="line"><span class="attr">management:</span>  <span class="comment">#config的UI管理界面配置</span></span><br><span class="line"><span class="attr">  endpoints:</span></span><br><span class="line"><span class="attr">    web:</span></span><br><span class="line"><span class="attr">      expose:</span> <span class="string">"*"</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="string">dev</span></span><br><span class="line"><span class="attr">lable:</span></span><br><span class="line">  <span class="string">master</span></span><br></pre></td></tr></table></figure><h3 id="映射规则">映射规则</h3><blockquote><p><code>/{name}-{profiles}.yml</code><code>/{lable}/{name}-{profiles}.yml</code><font color="orange">支持<code>json</code>, <code>yml</code>, <code>properties</code>三种后缀格式</font>name: 配置文件名(必须是服务名, 否则无法匹配)profiles: 环境, 可以取名<code>env</code>, <code>test</code>等随意填写lable: 表示git分支, 不写表示<code>master</code>分支</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>##########################################</span><br><span class="line"><span class="meta">#</span> 支持三种后缀格式自动互转换</span><br><span class="line"><span class="meta">#</span>##########################################</span><br><span class="line">`http://localhost:8083/order-server.yml`</span><br><span class="line">`http://localhost:8083/order-server.json`</span><br><span class="line">`http://localhost:8083/order-server.properties`</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>##########################################</span><br><span class="line"><span class="meta">#</span>&#123;lable&#125;表示分支branch, 不填写默认master分支</span><br><span class="line"><span class="meta">#</span>&#123;profiles&#125;代表什么环境的配置, 甚至可以写自己的名字, 若没有相当于没写(容错)</span><br><span class="line"><span class="meta">#</span>##########################################</span><br><span class="line">`http://localhost:8083/master/order-server-dev.yml`</span><br><span class="line">`http://localhost:8083/release/order-server.yml`</span><br><span class="line">`http://localhost:8083/develop/order-server-test.yml`</span><br></pre></td></tr></table></figure><h3 id="自定义git-log">自定义<code>git log</code></h3><p>意思是将以下命令写到~/.gitconfig的[alias]下面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 定义一个lg别名, 格式化log日志输出</span><br><span class="line">git config --global alias.lg "log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset'"</span><br></pre></td></tr></table></figure><p>进入<code>~/.gitconfig</code>查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">        name = duyu</span><br><span class="line">        email = duyud@qq.com</span><br><span class="line">[color]</span><br><span class="line">        ui = true</span><br><span class="line">[alias]</span><br><span class="line">        lg = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset'</span><br><span class="line">[credential]</span><br><span class="line">        helper = store</span><br><span class="line">[core]</span><br><span class="line">        autocrlf = false</span><br></pre></td></tr></table></figure><p>当然也可以直接输入命令, 只是很繁琐</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit</span><br></pre></td></tr></table></figure><h3 id="注意事项">注意事项</h3><ul><li><code>bootstrap.yml</code>优先读取配置</li></ul><p>服务名<code>spring.application.name</code>必须配置在项目里的<code>bootstrap.yml</code>里, 不管是放在本地还是在远端</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line">    <span class="comment">#经测试, 服务名必须配置在bootstrap.yml里才能通过, 否则会报数据库配置错误</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">order-server</span></span><br></pre></td></tr></table></figure><ul><li><code>order.yml</code>, <code>order-dev.yml</code>远端配置合并问题</li></ul><p>如果本地配置config拉取的是<code>order-dev.yml</code>, 如下 :</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">order-serverv</span> <span class="comment">#经测试, 服务名必须配置在bootstrap.yml里才能通过, 否则会报数据库配置错误</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      discovery:</span></span><br><span class="line"><span class="attr">        enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">        service-id:</span> <span class="string">config-server</span></span><br><span class="line"><span class="attr">      profile:</span> <span class="string">dev</span> <span class="comment"># git上的配置文件必须叫&#123;order-server&#125;或者&#123;order-server-dev&#125;</span></span><br></pre></td></tr></table></figure><p>Order服务通过config服务拉取到的配置会将<code>order.yml</code>, <code>order-dev.yml</code>两个配置进行合并; 有时候<code>order.yml</code>的内容多于<code>order-dev.yml</code>时, 会发现多出一些配置选项;如果拉取的是<code>order.yml</code>则不会合并</p><h2 id="bus">Bus</h2><p>是一个通知config更新的组件正常情况下所有服务实例都从<code>config服务</code>获取配置文件, 问题在于一旦启动后是不知道git仓库是否有更新;<code>sping-cloud-bus</code>作用就是用于通知配置更新的组件</p><blockquote><ol><li>git通过webhook调用<code>/actuator/bus-refresh</code>接口通知<code>config服务</code></li><li><code>config服务</code>会将收到的消息写入<code>rabbitmq消息队列</code></li><li>其他服务通过<code>spring-cloud-starter-bus-amqp</code>jar包就可以从消息队列取出消息进行重新加载更新</li></ol></blockquote><h3 id="使用步骤">使用步骤:</h3><p>1.安装<code>RabbitMq</code>2.所有服务和<code>config服务</code>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.<code>config服务</code>为git仓库的<code>webhook</code>开启<code>/actuator/bus-refresh</code>接口</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在spring-cloud-config 服务端配置此节点</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">  endpoints:</span></span><br><span class="line"><span class="attr">    web:</span></span><br><span class="line"><span class="attr">      exposure:</span></span><br><span class="line"><span class="attr">        include:</span> <span class="string">"*"</span> <span class="comment">#默认有health,info两个状态的通知, 通知接口为/actuator/bus-refresh, 用于给git仓库的webhook调用</span></span><br></pre></td></tr></table></figure><p>4.使用<code>@RefreshScope</code><font color="orange">需要添加<code>@RefreshScope</code>注解来让重新加载的配置生效, 否则不生效</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RefreshScope</span> <span class="comment">//注意如果配置需要生效, 必须在类上加此注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnvTestBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;env&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String env;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> env;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.配置<code>webhook</code>请求地址不可能每次更新配置之后手动调用<code>/actuator/bus-refresh</code>接口, 所以需要配置此通知接口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用内网穿透工具, 比如natapp</span><br><span class="line">配置webhook通知地址, 可以只选push类型通知, 不填密钥</span><br><span class="line">http://e9cfxj.natappfree.cc/monitor (指向本地8080 config服务端口)</span><br></pre></td></tr></table></figure><h3 id="使用curl发起测试">使用curl发起测试</h3><p><font color="red">测试发现的确通知了Order服务刷新配置, 且在2~4秒内生效, 个人猜测生效时长在于服务的代码量大小</font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v -X POST "http://localhost:8083/actuator/bus-refresh"</span><br></pre></td></tr></table></figure><p>解释下<code>curl</code>命令参数</p><blockquote><p><code>-v</code> 查看详细请求信息<code>-X PUT / -X POST / -X DELETE</code> 发起put/post/delete请求<code>-d</code> 参数-d “name=duyu&amp;age=28”-H “Content-Type:application/json” -d ‘“name”:“duyu”,“age”:28’<code>-H</code> 如上所示, 用于指定<code>header</code><code>-F</code> 文件上传-F “file=@/Users/duyu/Downloads/401.png” -H “token: 222” -v<code>man curl</code> 更新信息请通过此命令查阅</p></blockquote><h2 id="踩坑">踩坑</h2><p>由于springcloud在飞速迭代, 难免很多bug或者升级导致的代码和配置属性不一致的问题下面记录几个BUG</p><h3 id="spring-cloud-bus无法触发更新服务实例"><code>spring-cloud-bus</code>无法触发更新服务实例</h3><p>调试发现手动触发能更新配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v -X POST "http://localhost:8083/actuator/bus-refresh"</span><br></pre></td></tr></table></figure><p>但是使用<code>webhook</code>则无法触发更新发现<code>http://e9cfxj.natappfree.cc/monitor</code>的确已经通知了<code>config服务</code>, 并且<code>rabbitmq</code>也已经写入了消息, order服务也消费了服务, 但是就是没有触发更新;只有调试<code>spring-cloud-bus</code>源码, 使用的版本为<code>2.0.0.RELEASE</code></p><p>1.下载源码<code>git clone https://github.com/spring-cloud/spring-cloud-bus.git</code>2.切换版本到tag为<code>2.0.0.RELEASE</code>的commit id<code>git reset --hard 1974b23</code>3.更改类<code>BusEnvironmentPostProcessor</code>中<code>getDefaultServiceId</code>方法的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getDefaultServiceId</span><span class="params">(ConfigurableEnvironment environment)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"$&#123;vcap.application.name:$&#123;spring.application.name:application&#125;&#125;:$&#123;vcap.application.instance_index:$&#123;spring.application.index:$&#123;local.server.port:$&#123;server.port:0&#125;&#125;&#125;&#125;:$&#123;vcap.application.instance_id:$&#123;random.value&#125;&#125;"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>spring.application.index</code>改为<code>spring.cloud.config.profile</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getDefaultServiceId</span><span class="params">(ConfigurableEnvironment environment)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"$&#123;vcap.application.name:$&#123;spring.application.name:application&#125;&#125;:$&#123;vcap.application.instance_index:$&#123;spring.application.index:$&#123;local.server.port:$&#123;server.port:0&#125;&#125;&#125;&#125;:$&#123;vcap.application.instance_id:$&#123;random.value&#125;&#125;"</span>;</span><br></pre></td></tr></table></figure><h2 id="mq消息队列的使用">MQ消息队列的使用</h2><p>首先说明一下, <code>RabbitMQ</code>是基于<code>AMQP</code>协议(2003), <code>ActiveMQ</code>是基于<code>JMS</code>, 所以前者注重数据协议, 后者注重API接口的规约所以<code>RabbitMQ</code>天生跨语言, <code>ActiveMQ</code>则只使用于java, 跨语言很麻烦, 需要其他语言实现客户端</p><h3 id="引入依赖">引入依赖</h3><p>以下三个都和mq消息队列有关</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- rabbitmq --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- stream --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="comment">&lt;!--spring-cloud-starter-stream-kafka--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- spring-cloud-bus自动刷新config --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置-v2">配置</h3><p>rabbitmq配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  rabbitmq:</span></span><br><span class="line">    <span class="comment"># addresses: amqp://127.0.0.1:5672</span></span><br><span class="line"><span class="attr">    host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">5672</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">guest</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">guest</span></span><br></pre></td></tr></table></figure><p>spring-cloud-sream配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    stream:</span></span><br><span class="line"><span class="attr">      bindings:</span></span><br><span class="line"><span class="attr">        myStream:</span> <span class="comment"># 队列名(也是exchange名字, binding默认创建为'#')</span></span><br><span class="line"><span class="attr">          group:</span> <span class="string">order-server</span> <span class="comment"># 消费者服务名字, 不指定则会多个相同服务实例都接收到消息</span></span><br><span class="line"><span class="attr">          contentType:</span> <span class="string">application/json</span> <span class="comment"># 默认队列存储的是base64编码字符串, 比如可以为text/plain</span></span><br><span class="line">          <span class="comment">#destination: myStream-exchange # 指定exchange名字的队列</span></span><br><span class="line">          <span class="comment">#binder:</span></span><br><span class="line">          <span class="comment">#consumer:</span></span><br><span class="line">          <span class="comment">#producer</span></span><br></pre></td></tr></table></figure><h3 id="注解的使用">注解的使用</h3><ul><li><code>@RabbitListener 消费者</code></li></ul><p>方式1 : 不会主动创建队列, 需要去rabbitmq管理页面手动添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"orderQueue"</span>)</span><br></pre></td></tr></table></figure><p>方式2 : 主动创建队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(queuesToDeclare = <span class="meta">@Queue</span>(<span class="string">"orderQueue"</span>))</span><br></pre></td></tr></table></figure><p>方式3 : 主动创建队列, 同时Exchange和Queue绑定<font color="orange">exchange是交换机, queue是队列, RabbitMQ具体实现后面单独讲解</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">            exchange = <span class="meta">@Exchange</span>(<span class="string">"orderExchange"</span>),</span><br><span class="line">            value = <span class="meta">@Queue</span>(<span class="string">"test-order-queue"</span>)</span><br><span class="line">    ))</span><br></pre></td></tr></table></figure><p>方式4 : 主动创建队列, 同时Exchange和Queue绑定, 同时进行分组<font color="orange">即不同的服务分组消费不同的队列, 否则会出现多个服务实例重复消费一条消息</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">            exchange = <span class="meta">@Exchange</span>(<span class="string">"orderExchange"</span>),</span><br><span class="line">            key = <span class="string">"fruit"</span>,                        <span class="comment">// binding-key='fruit' 水果订单分组</span></span><br><span class="line">            value = <span class="meta">@Queue</span>(<span class="string">"fruit-order-queue"</span>)   <span class="comment">// 绑定到'fruit-order-queue'队列, 注意没有都会自动创建</span></span><br><span class="line">    ))</span><br></pre></td></tr></table></figure><ul><li>生产者</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mqSender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数1: exchange交换机</span></span><br><span class="line">    <span class="comment">// 参数2: 队列名</span></span><br><span class="line">    <span class="comment">// 参数3: 传输的数据</span></span><br><span class="line">    amqpTemplate.convertAndSend(<span class="string">"orderExchange"</span>, <span class="string">"digital"</span>, <span class="string">"now "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="spring-cloud-stream的使用">spring-cloud-stream的使用</h3><p>springcloud 对消息队列的使用还提供了<code>steam</code>, 它封装了MQ的不同, 来看如下图 :<img src="http://images2018.cnblogs.com/blog/1202638/201805/1202638-20180528204400011-1996551371.png" alt></p><p>后续补充…</p><h2 id="zuul">Zuul</h2><p><code>路由</code>+ <code>过滤器</code> = <code>zuul</code>本质是一个servlet应用, <code>ZuulServlet</code>类似SpringMvc的<code>DispatcherServlet</code>, 所有的Request都要经过<code>ZuulServlet</code>的处理实现了一系列的filter,  类比Servlet框架的filter, 或者也和springmvc的<code>interceptor</code>拦截器理念是一致的;</p><p><img src="http://images2015.cnblogs.com/blog/486074/201702/486074-20170220185335288-1703224333.png" alt></p><p>用以实现如下功能 :</p><blockquote><p><code>验证与安全保障</code>: 识别面向各类资源的验证要求并拒绝那些与要求不符的请求。<code>审查与监控</code>: 在边缘位置追踪有意义数据及统计结果，从而为我们带来准确的生产状态结论。<code>动态路由</code>: 以动态方式根据需要将请求路由至不同后端集群处。<code>压力测试</code>: 逐渐增加指向集群的负载流量，从而计算性能水平。<code>负载分配</code>: 为每一种负载类型分配对应容量，并弃用超出限定值的请求。<code>静态响应处理</code>: 在边缘位置直接建立部分响应，从而避免其流入内部集群。<code>多区域弹性</code>: 跨越AWS区域进行请求路由，旨在实现ELB使用多样化并保证边缘位置与使用者尽可能接近。</p></blockquote><h3 id="四种类型过滤器">四种类型过滤器</h3><p>1.前置(Pre)限流, 鉴权, 跨域, 参数校验, 请求转发, 反向代理;配合<code>OAuth2.0</code>做权限验证和<code>csrf</code>, <code>SQL注入</code>, <code>DDos</code>, <code>盗链</code>…</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="attr">ServletDetectionFilter:</span></span><br><span class="line"><span class="string">优先级-3,</span> <span class="string">最先被执行;</span> <span class="string">用来检测当前请求是通过Spring的DispatcherServlet处理运行的,</span> <span class="string">还是通过ZuulServlet来处理运行的</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span><span class="attr">Servlet30WrapperFilter:</span></span><br><span class="line"><span class="string">优先级-2,</span> <span class="string">第二个执行;</span> <span class="string">将原始的HttpServletRequest包装成Servlet30RequestWrapper对象</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span><span class="attr">FormBodyWrapperFilter:</span></span><br><span class="line"><span class="string">优先级-1,</span> <span class="string">第三个执行;</span> <span class="string">该过滤器仅对两类请求生效，第一类是Context-Type为application/x-www-form-urlencoded的请求，第二类是Context-Type为multipart/form-data并且是由String的DispatcherServlet处理的请求</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span><span class="attr">DebugFilter:</span></span><br><span class="line"><span class="string">优先级1,</span> <span class="string">第四个执行;</span> <span class="string">该过滤器会根据配置参数zuul.debug.request和请求中的debug参数来决定是否执行过滤器中的操作</span></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span><span class="string">PreDecorationFilter</span></span><br><span class="line"><span class="string">pre阶段最后被执行的过滤器,</span> <span class="string">为当前请求做一些预处理,</span> <span class="string">比如路由匹配信息和设置Headers头域信息,</span> <span class="string">后续过滤器通过RequestContext.getCurrentContext()能获取到</span></span><br></pre></td></tr></table></figure><p>2.路由(Route)</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="string">RibbonRoutingFilter</span></span><br><span class="line"><span class="string">优先级10,</span> <span class="string">route阶段第一个被执行;</span> <span class="string">只对请求上下文中存在serviceId参数的请求进行处理;</span></span><br><span class="line"><span class="string">直接向routeHost参数的物理地址发起请求作用是通过使用ribbon和hystrix来向服务实例发起请求,</span> <span class="string">并将服务实例的请求结果返回</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span><span class="string">SimpleHostRoutingFilter</span></span><br><span class="line"><span class="string">优先级100,</span> <span class="string">route阶段第二个被执行;</span> <span class="string">只对请求上下文存在routeHost参数的请求进行处理,</span> <span class="string">即只对通过url配置路由规则的请求生效</span></span><br><span class="line"><span class="string">作用是直接向routeHost参数的物理地址发起请求(直接使用HttpClient,</span> <span class="string">没有经过ribbon和hystrix)</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span><span class="string">SendForwardFilter</span></span><br><span class="line"><span class="string">优先级500,</span> <span class="string">route阶段第三个被执行;</span> <span class="string">只对请求上下文中存在的forward.do参数进行处理请求,</span> <span class="string">即用来处理路由规则中的forward本地跳转装配</span></span><br></pre></td></tr></table></figure><p>3.后置(Post)统计, 日志记录, 返回结果包装…</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="string">SendErrorFilter</span></span><br><span class="line"><span class="string">优先级0,</span> <span class="string">post阶段第一个被执行;</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span><span class="string">SendResponseFilter</span></span><br><span class="line"><span class="string">优先级1000,</span> <span class="string">post阶段最后执行;</span> <span class="string">检查请求上下文中是否包含请求响应相关的头信息,</span> <span class="string">响应数据流或是响应体</span></span><br></pre></td></tr></table></figure><p><code>FilterConstants</code>常量类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterConstants</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// KEY constants -----------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Zuul &#123;<span class="doctag">@link</span> com.netflix.zuul.context.RequestContext&#125; key for use in &#123;<span class="doctag">@link</span> org.springframework.cloud.netflix.zuul.filters.pre.ServletDetectionFilter&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String IS_DISPATCHER_SERVLET_REQUEST_KEY = <span class="string">"isDispatcherServletRequest"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Zuul &#123;<span class="doctag">@link</span> com.netflix.zuul.context.RequestContext&#125; key for use in &#123;<span class="doctag">@link</span> org.springframework.cloud.netflix.zuul.filters.route.SendForwardFilter&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FORWARD_TO_KEY = <span class="string">"forward.to"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Zuul &#123;<span class="doctag">@link</span> com.netflix.zuul.context.RequestContext&#125; key for use in <span class="doctag">TODO:</span> determine use</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROXY_KEY = <span class="string">"proxy"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Zuul &#123;<span class="doctag">@link</span> com.netflix.zuul.context.RequestContext&#125; key for use in &#123;<span class="doctag">@link</span> org.springframework.cloud.netflix.zuul.filters.route.RibbonRoutingFilter&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REQUEST_ENTITY_KEY = <span class="string">"requestEntity"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Zuul &#123;<span class="doctag">@link</span> com.netflix.zuul.context.RequestContext&#125; key for use in to override the path of the request.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REQUEST_URI_KEY = <span class="string">"requestURI"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Zuul &#123;<span class="doctag">@link</span> com.netflix.zuul.context.RequestContext&#125; key for use in &#123;<span class="doctag">@link</span> org.springframework.cloud.netflix.zuul.filters.route.RibbonRoutingFilter&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String RETRYABLE_KEY = <span class="string">"retryable"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Zuul &#123;<span class="doctag">@link</span> com.netflix.zuul.context.RequestContext&#125; key for use in &#123;<span class="doctag">@link</span> org.springframework.cloud.netflix.zuul.filters.post.SendResponseFilter&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROUTING_DEBUG_KEY = <span class="string">"routingDebug"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Zuul &#123;<span class="doctag">@link</span> com.netflix.zuul.context.RequestContext&#125; key for use in &#123;<span class="doctag">@link</span> org.springframework.cloud.netflix.zuul.filters.route.RibbonRoutingFilter&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVICE_ID_KEY = <span class="string">"serviceId"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Zuul &#123;<span class="doctag">@link</span> com.netflix.zuul.context.RequestContext&#125; key for use in &#123;<span class="doctag">@link</span> org.springframework.cloud.netflix.zuul.filters.route.RibbonRoutingFilter&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOAD_BALANCER_KEY = <span class="string">"loadBalancerKey"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ORDER constants -----------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Filter Order for &#123;<span class="doctag">@link</span> DebugFilter#filterOrder()&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEBUG_FILTER_ORDER = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Filter Order for &#123;<span class="doctag">@link</span> org.springframework.cloud.netflix.zuul.filters.pre.FormBodyWrapperFilter#filterOrder()&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FORM_BODY_WRAPPER_FILTER_ORDER = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Filter Order for &#123;<span class="doctag">@link</span> org.springframework.cloud.netflix.zuul.filters.pre.PreDecorationFilter&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRE_DECORATION_FILTER_ORDER = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Filter Order for &#123;<span class="doctag">@link</span> org.springframework.cloud.netflix.zuul.filters.route.RibbonRoutingFilter#filterOrder()&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RIBBON_ROUTING_FILTER_ORDER = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Filter Order for &#123;<span class="doctag">@link</span> org.springframework.cloud.netflix.zuul.filters.post.SendErrorFilter#filterOrder()&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SEND_ERROR_FILTER_ORDER = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Filter Order for &#123;<span class="doctag">@link</span> SendForwardFilter#filterOrder()&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SEND_FORWARD_FILTER_ORDER = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Filter Order for &#123;<span class="doctag">@link</span> org.springframework.cloud.netflix.zuul.filters.post.SendResponseFilter#filterOrder()&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SEND_RESPONSE_FILTER_ORDER = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Filter Order for &#123;<span class="doctag">@link</span> org.springframework.cloud.netflix.zuul.filters.route.SimpleHostRoutingFilter#filterOrder()&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIMPLE_HOST_ROUTING_FILTER_ORDER = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * filter order for &#123;<span class="doctag">@link</span> Servlet30WrapperFilter#filterOrder()&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVLET_30_WRAPPER_FILTER_ORDER = -<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * filter order for &#123;<span class="doctag">@link</span> org.springframework.cloud.netflix.zuul.filters.pre.ServletDetectionFilter#filterOrder()&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVLET_DETECTION_FILTER_ORDER = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Zuul Filter TYPE constants -----------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@link</span> ZuulFilter#filterType()&#125; error type.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ERROR_TYPE = <span class="string">"error"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@link</span> ZuulFilter#filterType()&#125; post type.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String POST_TYPE = <span class="string">"post"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@link</span> ZuulFilter#filterType()&#125; pre type.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PRE_TYPE = <span class="string">"pre"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@link</span> ZuulFilter#filterType()&#125; route type.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROUTE_TYPE = <span class="string">"route"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// OTHER constants -----------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Zuul &#123;<span class="doctag">@link</span> com.netflix.zuul.context.RequestContext&#125; key for use in &#123;<span class="doctag">@link</span> org.springframework.cloud.netflix.zuul.filters.route.SendForwardFilter&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FORWARD_LOCATION_PREFIX = <span class="string">"forward:"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * default http port</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HTTP_PORT = <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * default https port</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HTTPS_PORT = <span class="number">443</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * http url scheme</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HTTP_SCHEME = <span class="string">"http"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * https url scheme</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HTTPS_SCHEME = <span class="string">"https"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// HEADER constants -----------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * X-* Header for the matching url. Used when routes use a url rather than serviceId</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVICE_HEADER = <span class="string">"X-Zuul-Service"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * X-* Header for the matching serviceId</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVICE_ID_HEADER = <span class="string">"X-Zuul-ServiceId"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * X-Forwarded-For Header</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String X_FORWARDED_FOR_HEADER = <span class="string">"X-Forwarded-For"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * X-Forwarded-Host Header</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String X_FORWARDED_HOST_HEADER = <span class="string">"X-Forwarded-Host"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * X-Forwarded-Prefix Header</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String X_FORWARDED_PREFIX_HEADER = <span class="string">"X-Forwarded-Prefix"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * X-Forwarded-Port Header</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String X_FORWARDED_PORT_HEADER = <span class="string">"X-Forwarded-Port"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * X-Forwarded-Proto Header</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String X_FORWARDED_PROTO_HEADER = <span class="string">"X-Forwarded-Proto"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * X-Zuul-Debug Header</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String X_ZUUL_DEBUG_HEADER = <span class="string">"X-Zuul-Debug-Header"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.错误(Error)</p><p>参考: <a href="https://www.jianshu.com/p/ff863d532767" target="_blank" rel="noopener">zuul过滤器详解</a></p><h3 id="生命周期">生命周期</h3><p><img src="https://upload-images.jianshu.io/upload_images/5225109-371a03f23204ae6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/960/format/webp" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ZuulServlet的doFilter方法核心流程</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    preRoute();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ZuulException e) &#123;</span><br><span class="line">    error(e);</span><br><span class="line">    postRoute();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    route();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ZuulException e) &#123;</span><br><span class="line">    error(e);</span><br><span class="line">    postRoute();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    postRoute();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ZuulException e) &#123;</span><br><span class="line">    error(e);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red">可以动态加载<code>filter</code>, 它的过滤器是由<code>groovy</code>实现的, 放在指定目录, zuul server会定期扫描目录下的文件的变化, 动态的[读取][编译][运行]这些filter, 请查阅<code>GroovyCompiler</code>;<code>RequestContext</code> 生命周期管理, 因为<code>ZuulServlet</code>是单例多线程, 这就要求RequestContext即要线程安全又要Request安全, 所以使用了<code>ThreadLocal</code>来存储线程上下文数据 </font></p><h3 id="路由匹配规则">路由匹配规则</h3><p>yml配置主要是配置路由规则, 接口过滤名单<code>ignored-patterns</code>, http header会默认阻止三个cookie往服务路由转发<code>Cookie</code>,<code>Set-Cookie</code>,<code>Authorization</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="comment">#全部服务统一忽略敏感头</span></span><br><span class="line">  <span class="comment">#sensitive-headers:</span></span><br><span class="line"><span class="attr">  routes:</span></span><br><span class="line">    <span class="comment">#自定义路由规则, 是一个map, key可以随意写, 通过 /application/routes 接口可以看到所有路由规则</span></span><br><span class="line"><span class="attr">    myproduct:</span></span><br><span class="line">      <span class="comment">#自定义的路由url</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/myproduct/**</span></span><br><span class="line">      <span class="comment">#路由目的地服务名</span></span><br><span class="line"><span class="attr">      serviceId:</span> <span class="string">product-server</span></span><br><span class="line">      <span class="comment">#zuul默认禁止三个敏感Header信息往内部服务传递["Cookie", "Set-Cookie", "Authorization"], 设置黑名单为空即可</span></span><br><span class="line"><span class="attr">      sensitiveHeaders:</span></span><br><span class="line">    <span class="comment">#简洁写法, key必须是服务名</span></span><br><span class="line"><span class="attr">    order-server:</span> <span class="string">/myorder/**</span></span><br><span class="line"><span class="attr">  ignored-patterns:</span> <span class="comment">#禁止外部调用</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">/product-server/product/list</span>  <span class="comment">#或者通配符 /**/product/list</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">/myproduct/product/list</span></span><br></pre></td></tr></table></figure><p>默认路由规则为</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http:</span><span class="string">//localhost:8083/&#123;具体服务名&#125;/&#123;具体服务的接口&#125;</span></span><br><span class="line"><span class="comment">#比如</span></span><br><span class="line"><span class="attr">http:</span><span class="string">//localhost:8083/product-server/product/list</span></span><br></pre></td></tr></table></figure><p>上面配置自定义路由后, 还可以支持如下路由</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http:</span><span class="string">//localhost:8083/&#123;自定义映射服务名&#125;/&#123;具体服务的接口&#125;</span></span><br><span class="line"><span class="comment">#比如</span></span><br><span class="line"><span class="attr">http:</span><span class="string">//localhost:8083/myproduct/product/list</span></span><br></pre></td></tr></table></figure><h3 id="动态刷新配置">动态刷新配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(<span class="string">"zuul"</span>)</span><br><span class="line">    <span class="meta">@RefreshScope</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ZuulProperties <span class="title">zuulProperties</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ZuulProperties();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"animal"</span>)</span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String kind;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义filter">自定义filter</h3><h4 id="限流过滤器">限流过滤器</h4><p>这里可以做<code>限流</code>, <code>鉴权</code>… (注意限流一定是在<code>pre</code>类型的最前面)限流可以有很多种方式参考: <a href="https://www.cnblogs.com/biglittleant/p/8979915.html" target="_blank" rel="noopener">https://www.cnblogs.com/biglittleant/p/8979915.html</a>算法如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/1272254-0d4388e78c3f18c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/443/format/webp" alt></p><blockquote><ol><li><code>令牌桶限流算法</code>google开源的guava工具包就有实现原理:</li></ol></blockquote><ul><li>令牌桶(<code>token bucket</code>)以固定速率生成<code>令牌token</code>, 桶有最大容量, 一旦满了就溢出丢弃</li><li>请求到达后从<code>bucket</code>获取一个<code>token</code>, 若能获取则放行, 若token耗尽则直接拒绝请求(丢弃request)</li></ul><blockquote><ol start="2"><li><code>漏桶算法(leaky bucket)</code>本质即队列queue缓存请求, 并匀速转发, 队列满则丢弃</li><li><code>nginx限流</code></li><li><code>zuul网关限流</code></li></ol></blockquote><p>nginx默认是<code>漏桶算法</code></p><blockquote><ol><li><code>$binary_remote_addr</code>表示基于<code>remote_addr</code>(客户端IP)来做限流, <code>binary_</code>前缀 的目是压缩内存占用量</li><li><code>zone=myRateLimit:10m</code>定义共享内存区来存储访问信息, 表示名为<code>myRateLimit</code>的<code>10M</code>内存区域, 10M大致能保存16w IP请求信息</li><li><code>rate=10r/s</code>设置最大访问速率, 表示每秒最多处理10个请求; nginx是ms毫秒为单位, 意味着<code>每100毫秒处理一个请求, 之内如果还有其他请求到达, 则丢弃</code></li></ol></blockquote><p><code>漏桶算法</code>主要特点就是保证绝对平稳的速度, 所以是无法处理突发流量的注意下面<code>burst=20 nodelay;</code></p><blockquote><ol><li><code>burst=20</code>它表示当请求量超过阈值该如何处理突发流量; 当前配置下如果100ms内(<code>可理解为同时</code>)到达21个请求, 则处理第一个, 其余20个入队, 每隔100ms取出一个进行处理, 请求数大于21, 拒绝处理, 配置直接返回<code>503</code></li><li><code>nodelay</code>单独设置<code>burst</code>并不实用, 假设 burst=50 , rate依然为10r/s, 排队中的50个请求虽然每100ms会处理一个, 但第50个请求却需要等待 50 * 100ms = 5snodelay 表示这20个请求立马处理, 不能延迟不过，即使这20个突发请求立马处理结束，后续来了请求也不会立马处理。burst=20 相当于缓存队列中占了20个坑，即使请求被处理了，这20个位置这只能按 100ms一个来释放</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#动态加载模块，必须写道开头</span><br><span class="line">load_module modules/ngx_stream_module.so;</span><br><span class="line">#cpu核心数 * 2</span><br><span class="line">worker_processes  4;</span><br><span class="line">#配置nginx打开最大文件数 (每个工作进程绑定一个cpu，worker_cpu_affinity配置)</span><br><span class="line">worker_rlimit_nofile   102400;</span><br><span class="line">#工作进程使用哪个cpu的核心(下面表示四核序列)</span><br><span class="line">worker_cpu_affinity 0001 0010 0100 1000;</span><br><span class="line"></span><br><span class="line">pid   logs/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    use epoll;</span><br><span class="line">    worker_connections  10240;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line"></span><br><span class="line">    sendfile           on;</span><br><span class="line">    keepalive_timeout  30;</span><br><span class="line"></span><br><span class="line">    #默认允许客户端最大上传文件大小</span><br><span class="line">    client_max_body_size 8m;</span><br><span class="line"></span><br><span class="line">    ####################### 核心 #######################</span><br><span class="line">    # ngx_http_limit_req_module 模块采用漏桶算法</span><br><span class="line">    limit_req_zone $binary_remote_addr zone=myRateLimit:10m rate=10r/s;</span><br><span class="line"></span><br><span class="line">    #超出限制时, 统一返回状态码</span><br><span class="line">    limit_conn_status 503;</span><br><span class="line"></span><br><span class="line">    # 负载均衡配置</span><br><span class="line">upstream myserver &#123;</span><br><span class="line">server 192.168.10.253:8090;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">location / &#123;</span><br><span class="line">    #limit_conn addr 1; #并发数限制</span><br><span class="line">    # 指定限流zone</span><br><span class="line">limit_req zone=myRateLimit burst=20 nodelay;</span><br><span class="line"># 转发到负载均衡器</span><br><span class="line">proxy_pass http://myserver;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">##################################################</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>限流过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiterFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RateLimiter RETELIMITER = RateLimiter.create(<span class="number">100</span>);<span class="comment">// 每秒放100个token</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PRE_TYPE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 限流要在所有pre类型过滤器之前</span></span><br><span class="line">        <span class="keyword">return</span> SERVLET_DETECTION_FILTER_ORDER - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 尝试获取token, 没有则会失败</span></span><br><span class="line"><span class="comment">         * 注意: rateLimiter.tryAcquire(500, TimeUnit.MILLISECONDS)是判断500ms内是否能拿到令牌, 并不是真会阻塞1s</span></span><br><span class="line"><span class="comment">         * 它是根据令牌生成速率和当前时间做对比,</span></span><br><span class="line"><span class="comment">         * 比如100个令牌/每秒, 在前100ms内到达101个请求, 说明令牌耗尽, 需要等待至少900ms才能拿到令牌, 所以没有等待必要, 立刻失败</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (RETELIMITER.tryAcquire())&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="跨域过滤器csrf">跨域过滤器CSRF</h4><p>spring提供了一个注解<code>@CrossOrigin(allowCredentials = &quot;true&quot;)</code><code>allowCredentials=&quot;true&quot;</code>指cookie允许跨域</p><p>问题在于它只能添加在类或方法上, 所以一劳永逸的办法还是添加过滤器Spring已经提供了<code>CorsFilter</code>, 配置一下即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line"></span><br><span class="line">        CorsConfiguration config = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        config.setAllowCredentials(<span class="keyword">true</span>); <span class="comment">// 设置允许cookie跨域</span></span><br><span class="line">        config.setAllowedOrigins(Arrays.asList(<span class="string">"*"</span>)); <span class="comment">// 设置允许跨域的域名</span></span><br><span class="line">        config.setAllowedHeaders(Arrays.asList(<span class="string">"*"</span>));</span><br><span class="line">        config.setAllowedMethods(Arrays.asList(<span class="string">"*"</span>)); <span class="comment">// 设置允许GET/PUT/POST/DELETE等</span></span><br><span class="line">        config.setMaxAge(<span class="number">300l</span>); <span class="comment">//设置跨域生存时间, 单位:S</span></span><br><span class="line"></span><br><span class="line">        source.registerCorsConfiguration(<span class="string">"/**"</span>, config); <span class="comment">//设置对所有接口路径生效</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="spring-cloud-gateway">Spring-Cloud-Gateway</h2><h2 id="hystrix">Hystrix</h2><blockquote><ol><li><code>服务降级</code></li><li><code>依赖隔离</code></li><li><code>服务熔断</code></li><li><code>缓存</code> (请求缓存,请求合并)</li><li><code>监控 (Hystrix Dashboard)</code></li></ol></blockquote><h3 id="服务降级">服务降级</h3><p>qps过大, 或者秒杀, 双11这种流量高峰期, 必须对核心服务提供高可用, 对非核心服务则可降级操作, 比如返回&quot;服务繁忙中…&quot;</p><blockquote><ol><li><code>@HystrixCommand</code>注解</li><li><code>fallBackMethod</code>(回退函数)中实现具体的降级逻辑, 比如导向一个繁忙提示页面, 或者一个包含友好提示的json数据</li></ol></blockquote><ul><li>添加依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注意1.x时使用 spring-cloud-starter-hystrix --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>启动类添加注解<code>@EnableCircuitBreaker</code></li></ul><p>开启熔断器的意思</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须添加包路径, 否则编译报错, 第二个路径用于测试</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span>(basePackages = &#123;<span class="string">"org.doyo.product.client"</span>, <span class="string">"org.doyo.order.client"</span>&#125;)</span><br><span class="line"><span class="comment">//@SpringBootApplication</span></span><br><span class="line"><span class="comment">//@EnableDiscoveryClient</span></span><br><span class="line"><span class="comment">//@EnableCircuitBreaker</span></span><br><span class="line"><span class="meta">@SpringCloudApplication</span> <span class="comment">// 上面三者合并</span></span><br></pre></td></tr></table></figure><ul><li>具体使用</li></ul><p>主要是设置<code>@DefaultProperties(defaultFallback = &quot;defaultFallback&quot;)</code><code>defaultFallback</code>是方法名, 指定超时或熔断后需要降级调用的方法;当然也可以全局指定降级方法<code>@DefaultProperties(defaultFallback = &quot;defaultFallback&quot;)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="comment">//此类所有方法出现异常都默认调用defaultFallback</span></span><br><span class="line"><span class="meta">@DefaultProperties</span>(defaultFallback = <span class="string">"defaultFallback"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixTestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HystrixCommand</span>(</span><br><span class="line">        <span class="comment">// 指定某个方法的降级方法(优先级高于全局的)</span></span><br><span class="line">        fallbackMethod = <span class="string">"fallback"</span>,</span><br><span class="line">        commandProperties = &#123;</span><br><span class="line">            <span class="comment">// 默认超时时间为1秒, 根据具体业务设置timeout</span></span><br><span class="line">            <span class="meta">@HystrixProperty</span>(</span><br><span class="line">                name = <span class="string">"execution.isolation.thread.timeoutInMilliseconds"</span>,</span><br><span class="line">                value = <span class="string">"2000"</span>)&#125;)</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hystrix/getProductList"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getProductList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用其他服务接口...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依赖隔离">依赖隔离</h3><p>正常情况下, 请求都是使用一个线程池, 比如<code>Servlet</code>就是单例多线程模型, 多线程就是使用线程池;如果某个服务(方法调用/rpc调用/http调用)出现故障, 比如超时等待,或阻塞, 多人并发调用此服务会导致线程池瞬间耗尽, 影响其他服务的调用;<font color="orange">解决办法就是线程隔离, 隔离办法就是为每个<code>@HystrixCommand</code>启动一个线程池, 池之间是互不影响的, 类似<code>sandbox沙盒</code>, 可以类比我们所熟悉的<code>Reactor反应堆模型</code>或<code>Proactor主动器模型</code>类似的实现方式</font></p><h4 id="同步-异步-阻塞-非阻塞-reactor-proactor">同步/异步, 阻塞/非阻塞, reactor/proactor</h4><p>这里复习下之前说过的概念, 为了捋顺思路, 分几个层次来说明</p><ul><li>同步/异步, 阻塞/非阻塞</li></ul><blockquote><ol><li><code>同步/异步</code> : 关注消息通讯链路方式是原有<code>链路</code>返回, 还是通过其他<code>本地接口回调/MQ消息/远程rpc/http接口</code>, 即其他<code>链路</code>返回</li><li><code>阻塞/非阻塞</code>: 关注线程在调用并等待获取结果时线程的状态可理解为<code>client</code>调用<code>server</code>之后, <code>client</code>是挂起等待, 还是立即不管了,可以去做其他事情</li><li>如何理解<code>同步非阻塞</code>?看下面的分析</li></ol></blockquote><ul><li>理解层次的不同</li></ul><blockquote><ol><li><code>cpu层次</code>IO指令发出后, 执行后续指令(并不等待), 所以是非阻塞数据准备好后是通过中断信号来通知IO操作, 所以是异步<code>cpu</code>是真正意义上的<code>异步非阻塞</code></li><li><code>操作系统(kernel内核)</code>为了减轻编码难度, 系统内核封装成了同步调用接口(<code>read/write</code>); 问题在于此方式会挂起调用方线程(即<code>同步阻塞接口</code>);所以提出改进 :主要改进点在于把阻塞点封装到内部并优化, 让外部使用者不阻塞即可, 至于异步还是同步重要程度不如前者; 因为阻塞挂起会极度影响效率; 实现方式当前有如下三种 :<font color="orange">(1).<strong>多线程(<code>同步阻塞</code>)</strong>只是使用了线程池, 效率有一定提升, 本质还是<code>同步阻塞</code>(2).<strong>IO多路复用(select/poll/epoll <code>同步非阻塞</code>)</strong>它内部使用了一个<code>select</code>线程轮询所有的<code>fd队列集合</code>上的可读事件, 相当于将阻塞点封装到了内部的<code>select轮询</code>上, 这样就不会阻塞客户端调用线程,  且内部使用了事件机制来进行了优化, 效率大大提升;注意, <code>client</code>如果不阻塞了则需要轮询读取数据, 因为可能一次读取数据是没有准备完整的, 它只管是有可读事件, 有1byte也叫可读, 虽然同步, 但已经不阻塞客户端了(3).<strong>暴露异步接口(<code>异步非阻塞</code>)</strong>将同步接口直接改为异步返回, 既然异步了, 何不将数据完全准备好后再通知进程呢? 所以<code>AIO</code>的确是这样做的, 用户进程就无须再进行数据拷贝操作, 直接就可用; 典型的实现有<code>kernel-aio(linux), ICOP(微软)</code></font></li><li><code>程序员感知(应用进程)</code>(1) NIO/Netty(java), 使用上是<code>同步非阻塞</code>, 本质是改变阻塞点到内部了, 使用上感知不到(2) NodeJS, 使用上是<code>异步非阻塞</code>接口, 实际在操作系统层次是<code>同步非阻塞(IO多路复用-epoll)</code>(3) AIO, 如果是在操作系统上的实现,比如<code>ICOP</code>, <code>kernel-aio</code>, 这两者是真正意义上的异步非阻塞, 因为<code>异步非阻塞</code>的一个重大特点就是<font color="red">应用进程不参与数据复制, 由内核完成数据拷贝后再通知, 所以真正的AIO是需要操作系统级别的支持</font>;比如应用层次的<code>netty4</code>, 支持了AIO, 使用上是异步非阻塞, 内部还是多路复用, 只是提供了<code>Future</code>接口的<code>get</code>函数来阻塞获取最终完整结果, 模拟达到<code>AIO</code>的<code>异步复制完成并通知</code>的效果, 因为不阻塞<code>read</code>, 阻塞的是<code>future.get</code></li></ol></blockquote><ul><li>Reactor/Proactor</li></ul><p>其实这是上面讲述的<code>I/O多路复用</code>的两种设计模式;</p><blockquote><ol><li><code>Reactor</code>采用<code>同步非阻塞(多路复用)</code></li><li><code>Proactor</code>采用<code>异步非阻塞(AIO)</code>注意上面所讲述的<code>异步非阻塞</code>的重大特点就是<font color="red">应用进程不参与数据复制, 由内核完成数据拷贝后再通知, 所以真正的AIO是需要操作系统级别的支持</font>; 所以可以通过<code>同步IO模拟Proactor</code>若是应用进程模拟, 则只能通过<code>Future</code>等形式来封装异步库, 使用者得到的即为<code>AIO(不是真正的内核级别)</code></li></ol></blockquote><ul><li>netty</li></ul><p>这个以后会单独写, 先看两个图</p><p><code>netty</code>使用了<code>IO多路复用模型</code>, 内部使用异步接口<code>Future</code>, 所以<code>netty</code>对于使用者算是<code>异步非阻塞</code>,当然它也支持同步模式</p><p><code>Reactor模型</code>是netty采用的实现模式</p><p><code>Spring5</code>发布了<code>Spring WebFlux</code>, 因为之前的<code>SpringMVC</code>是<code>一请求一线程</code>的同步阻塞模型, 就算提供了异步接口内部也是同步阻塞的;<code>WebFlux</code>则是基于<code>Reactor模型</code>响应式的</p><p>图1 (Doug Lee - Scalable IO in Java)<img src="http://5b0988e595225.cdn.sohucs.com/images/20181102/6d2033c48bc24c139bed1fde5f11f530.jpeg" alt></p><p><code>netty</code>参考了上图的<code>Reactor</code>模型, 具体实现只有细微差别, 大致方向是符合<code>Doug Lee</code>大神的思路<img src="http://5b0988e595225.cdn.sohucs.com/images/20181102/56127ef6c0e44ae582534a6e0d1e5d48.jpeg" alt></p><p>参考: <a href="http://www.sohu.com/a/272879207_463994" target="_blank" rel="noopener">目前最透彻的Netty原理架构解析 </a></p><h3 id="服务熔断">服务熔断</h3><p>主要还是<code>@HystrixCommand</code>, 之前说过降级配置<code>fallbackMethod</code>, 和调用超时阈值<code>execution.isolation.thread.timeoutInMilliseconds(默认1秒)</code>;</p><p>断路器设计模式-状态机</p><blockquote><ol><li><code>closed</code>默认为<code>关闭状态</code>, 当失败(超时/异常…)到达一定的阈值, 则转为<code>open</code>状态;</li><li><code>open</code>一旦为<code>open</code>状态, 此时服务将采用降级调用, 会开启一个时钟倒计时, 计时结束后进入<code>half-open</code>状态</li><li><code>half-open</code>此状态会将到达的多个请求, 释放一次去执行正常业务逻辑, 如果还是失败, 则回到<code>open</code>状态, 时钟倒计时重置;  如果正常就回到<code>closed</code>状态</li></ol></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/10297697-841a5f8523a4b600.jpg!web?imageMogr2/auto-orient/strip%7CimageView2/2/w/450/format/webp" alt></p><p>现在来说明下熔断配置</p><blockquote><ol><li><strong><code>circuitBreaker.enabled = true</code></strong><code>启用熔断</code>; 用来跟踪circuit的健康性, 如果未达标则短路, 默认true</li><li><strong><code>circuitBreaker.requestVolumeThreshold = 20</code></strong><code>滑动窗口最小请求数</code>; 比如一个滑动窗口统计时间内(比如10s), 调用20次都失败(异常或超时), 则开启熔断机制,  进入<code>open</code>状态;  如果10s统计时间内只调用19次且都失败, 都不会开启熔断; 默认20</li><li><strong><code>circuitBreaker.sleepWindowInMilliseconds = 5000</code></strong><code>滑动窗口长度(毫秒)</code>, 意思是<code>half-open</code>状态的到期时间; 此状态内, 降级逻辑临时成为主逻辑, 到期后会释放一次请求去执行主逻辑;如果成功, 则回到<code>closed</code>状态, 请求变更为执行主逻辑;如果失败, 则回到<code>open</code>状态, 重置到期时间开始倒计时;</li><li><strong><code>circuitBreaker.errorThresholdPercentage = 50</code></strong><code>错误比率阀值</code>; 上面设置断路器请求数为20, 这里是设置开启断路器开启的失败百分比; 默认50;比如10s内30次请求(&gt;=20)失败了15次, 失败率50%&gt;=50%, 则会进入<code>open</code>状态</li><li><strong><code>metrics.rollingStats.timeInMilliseconds</code></strong><code>滑动窗口的统计时间</code>, 默认10s; 它只会统计此时间内的请求情况</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span>(</span><br><span class="line">        fallbackMethod = <span class="string">"fallback"</span>,</span><br><span class="line">        commandProperties = &#123;</span><br><span class="line">                <span class="meta">@HystrixProperty</span>(name = <span class="string">"execution.isolation.thread.timeoutInMilliseconds"</span>, value = <span class="string">"2000"</span>),</span><br><span class="line"></span><br><span class="line">                <span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.enabled"</span>, value = <span class="string">"true"</span>),  <span class="comment">//设置熔断</span></span><br><span class="line">                <span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.requestVolumeThreshold"</span>, value = <span class="string">"20"</span>),</span><br><span class="line">                <span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.sleepWindowInMilliseconds"</span>, value = <span class="string">"5000"</span>),</span><br><span class="line">                <span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.errorThresholdPercentage"</span>, value = <span class="string">"60"</span>)</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/hystrix/getProductList1"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getProductList1</span><span class="params">(@RequestParam(<span class="string">"number"</span>)</span> Integer number) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 偶数则直接放行</span></span><br><span class="line">    <span class="keyword">if</span> (number % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 奇数则访问异常的product服务</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">        String res = restTemplate.postForObject(</span><br><span class="line">                <span class="string">"http://127.0.0.1:8081/product/listForOrder"</span>,</span><br><span class="line">                Arrays.asList(<span class="string">"157875196366160022"</span>),</span><br><span class="line">                String.class);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单个方法的降级,优先级高</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">fallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"繁忙中, 请稍后再试..."</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细配置说明请参考 :<a href="https://blog.csdn.net/sun_qiangwei/article/details/80376791" target="_blank" rel="noopener">Hystrix 参数详解</a><a href="https://zhenbianshu.github.io/2018/09/hystrix_configuration_analysis.html" target="_blank" rel="noopener">Hystrix 配置参数全解析</a></p><h3 id="开启hystrix-dashboard">开启hystrix-dashboard</h3><ul><li>添加依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>Application</code>启动类添加注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br></pre></td></tr></table></figure><ul><li>添加servlet</li></ul><p>注意, 由于springboot的路径我们默认为’/’, 所以需要在xml中添加<code>hystrix-dashboard</code>的servlet路由</p><p>可以在<code>HystrixMetricsStreamServlet</code>的注释中找到说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">getServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HystrixMetricsStreamServlet streamServlet = <span class="keyword">new</span> HystrixMetricsStreamServlet();</span><br><span class="line">    ServletRegistrationBean registrationBean = <span class="keyword">new</span> ServletRegistrationBean(streamServlet);</span><br><span class="line">    registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">    registrationBean.addUrlMappings(<span class="string">"/hystrix.stream"</span>);</span><br><span class="line">    registrationBean.setName(<span class="string">"HystrixMetricsStreamServlet"</span>);</span><br><span class="line">    <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进入dashboard</li></ul><p>经过尝试, 单节点应用按如下配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">地址:</span> <span class="attr">http://localhost:8082/hystrix.stream</span></span><br><span class="line"><span class="attr">delay:</span> <span class="string">随意填</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">填项目名即可</span></span><br></pre></td></tr></table></figure><h3 id="注意事项-v2">注意事项</h3><ul><li>开启feign对Hystrix服务熔断降级支持</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开启Feign Hystrix支持(Finchley.SR1版本没有属性提示)</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">  hystrix:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">hystrix:</span></span><br><span class="line"><span class="attr">  command:</span></span><br><span class="line">    <span class="comment">#更多配置请参考https://zhenbianshu.github.io/2018/09/hystrix_configuration_analysis.html</span></span><br><span class="line">    <span class="comment">#针对所有请求生效, 如果想针对某个Action生效, 此处请写方法名, 或者commandKey指定的值 (不是URL)</span></span><br><span class="line"><span class="attr">    default:</span></span><br><span class="line"><span class="attr">      execution:</span></span><br><span class="line"><span class="attr">        isolation:</span></span><br><span class="line"><span class="attr">          thread:</span></span><br><span class="line"><span class="attr">            timeoutInMilliseconds:</span> <span class="number">2000</span></span><br></pre></td></tr></table></figure><ul><li>服务降级的接口或者类必须能扫描到</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处为了扫描到FeignClientFallback服务降级类, 因为默认只会扫描此包下的类</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"org.doyo"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须添加FeignClient接口包路径, 否则编译报错, 第二个路径用于测试</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span>(basePackages = &#123;<span class="string">"org.doyo.product.client"</span>, <span class="string">"org.doyo.order.client"</span>&#125;)</span><br></pre></td></tr></table></figure><h2 id="sleuth-zipkin">Sleuth-Zipkin</h2><h3 id="原理">原理</h3><p>链路请求跟踪, <code>zipkin</code>是根据Google发表的Dapper论文进行实现;<code>sleuth</code>是对<code>zipkin</code>的一个包装其基本思路是在服务调用的请求和响应中加入ID, 标明上下游请求的关系;</p><p>日志信息</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[order-server,4315dc6135b627e5,8853c37e804e2230,false]</span></span><br></pre></td></tr></table></figure><blockquote><p><code>application name</code>为一个请求分配的ID号, 用来标识一条请求链路<code>traceId</code>为一个请求分配的ID号, 用来标识一条请求链路<code>spanId</code>表示一个基本的工作单元, 一个请求可以包含多个步骤, 每个步骤都拥有自己的spanId; 一个请求包含一个TraceId, 多个SpanId<code>export</code>是否要将该信息输出到类似Zipkin这样的聚合器进行收集和展示;需要配置采集样本速率, 默认0.1, 如下所示 :</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring</span></span><br><span class="line"><span class="attr">    sleuth:</span></span><br><span class="line"><span class="attr">        feign:</span></span><br><span class="line"><span class="attr">          enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">        sampler:</span></span><br><span class="line">          <span class="comment">#采集率0~1</span></span><br><span class="line"><span class="attr">          probability:</span> <span class="number">1.0</span></span><br></pre></td></tr></table></figure><h3 id="pom依赖">pom依赖</h3><ul><li>zipkin客户端</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-sleuth<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- sleuth集成zipkin客户端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-sleuth-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者简化为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 上面的两个依赖可简化为 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>zipkin服务端</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Zipkin服务端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.zipkin.java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zipkin-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Zipkin可视化界面依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.zipkin.java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zipkin-autoconfigure-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="注解与配置">注解与配置</h3><ul><li>服务端</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 或者使用@EnableZipkinStreamServer, 但需要依赖MQ</span></span><br><span class="line"><span class="comment">// springboot2.0已经不推荐自建zipkin-server, 且mq方式也变了</span></span><br><span class="line"><span class="meta">@EnableZipkinServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZipkinServerApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ZipkinServerApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>客户端</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  sleuth:</span></span><br><span class="line"><span class="attr">    feign:</span></span><br><span class="line"><span class="attr">      enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    sampler:</span></span><br><span class="line">      <span class="comment">#1.采集频率</span></span><br><span class="line"><span class="attr">      probability:</span> <span class="number">1.0</span></span><br><span class="line"><span class="attr">    web:</span></span><br><span class="line"><span class="attr">      client:</span></span><br><span class="line"><span class="attr">        enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  zipkin:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#2.zipkin地址</span></span><br><span class="line"><span class="attr">    base-url:</span> <span class="attr">http://localhost:9411/</span></span><br><span class="line"><span class="attr">    service:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br><span class="line"><span class="attr">    sender:</span></span><br><span class="line">      <span class="comment">#3.注意一定要指定数据传输方式, 否则不会到达zipkin</span></span><br><span class="line"><span class="attr">      type:</span> <span class="string">web</span></span><br></pre></td></tr></table></figure><h3 id="升级spring-boot2-x">升级spring-boot2.x</h3><p>已经不推荐上面自己创建<code>zipkin server</code>, 需要使用编译好的jar包</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">run</span> <span class="bullet">-d</span> <span class="bullet">-p</span> <span class="number">9411</span><span class="string">:9411</span> <span class="string">openzipkin/zipkin</span></span><br></pre></td></tr></table></figure><h2 id="本机服务地址">本机服务地址</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka-server:</span> <span class="attr">http://localhost:8761/</span></span><br><span class="line"><span class="string">zuul-gateway</span> <span class="string">:</span></span><br><span class="line"><span class="attr">    - http:</span><span class="string">//localhost:8083/product-server/product/list</span></span><br><span class="line"><span class="attr">    - http:</span><span class="string">//localhost:8083/order-server/order/create</span></span><br><span class="line"><span class="string">order-server</span> <span class="string">:</span></span><br><span class="line"><span class="string">项目地址:</span> <span class="attr">https://github.com/asan3524/yiran</span></span><br><span class="line"><span class="string">配置文件地址:</span> <span class="attr">https://github.com/DoyuLy/cloud-config-repo</span></span><br><span class="line"><span class="attr">rabbitmq:</span> <span class="attr">http://localhost:15672/</span></span><br><span class="line"><span class="attr">config-server:</span> <span class="attr">http://localhost:8080</span></span><br><span class="line"><span class="attr">zipkin-server:</span> <span class="attr">http://localhost:9411</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;springboot1-x升级2-x&quot;&gt;SpringBoot1.x升级2.x&lt;/h2&gt;
&lt;p&gt;1.&lt;code&gt;spring-boot-starter-parent&lt;/code&gt;依赖改为&lt;code&gt;2.x&lt;/code&gt;版本
2.启动类修改&lt;code&gt;SpringBo
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LinkedTransferQueue 与 SynchronousQueue</title>
    <link href="https://doooyo.github.io/2019/04/22/LinkedTransferQueue%20%E4%B8%8E%20SynchronousQueue/"/>
    <id>https://doooyo.github.io/2019/04/22/LinkedTransferQueue 与 SynchronousQueue/</id>
    <published>2019-04-21T16:32:54.338Z</published>
    <updated>2019-04-21T16:32:54.339Z</updated>
    
    <content type="html"><![CDATA[<p>两者是比较特殊的阻塞队列</p><h2 id="linkedtransferqueue">LinkedTransferQueue</h2><blockquote><ol><li>单向链表结构的无界阻塞队列 (CAS无锁)</li><li>遵循<strong>happen-before</strong>, 即插入先行于访问或删除</li><li>采用预占模式比如消费者线程take时发现队列为空, 则队列生成一个<code>item为null, waiter为消费者线程本身</code>节点并入队, 然后阻塞take操作;直到生产者线程put入队时, 发现队列有一个<code>item为null</code>的节点, 则不入队, 直接填充数据到该节点, 并唤醒消费者线程的take操作<font color="orange">这和传递东西很类似, 也和通道pipeline很像, 这种模式叫做**‘匹配’**</font></li><li>LinkedTransferQueue是无锁设计, 是SynchronousQueue和LinkedBlockingQueue的超集, 结合了两者的优点, 并摒弃了其缺陷<code>SynchronousQueue</code>: 无法存放数据, 严格的<strong>一应一答</strong><code>LinkedBlockingQueue</code>: 使用了Lock锁, 并发效率低<code>LinkedTransferQueue</code>: 使用CAS和LockSupport, 且可存放数据和请求, 不会长时间阻塞;同时它适合生产者和消费者速度不匹配的情况, 允许生产者适当调整生产速度;普通队列的生产者和消费者是分离的, 举一个例子:<font color="gray">通常情况下, 厨师只管炒菜, 服务员只管端菜, 厨师是不关心也不知道服务员端没有端走; 现在的情形是厨师可能会将菜直接递到服务员手里, 即知道服务员有没有端菜, 既然知道了厨师就可以调整炒菜的速度, 是快点还是慢点 </font></li></ol></blockquote><h3 id="一-数据结构与算法特性">一. 数据结构与算法特性</h3><p><img src="https://upload-images.jianshu.io/upload_images/6050820-1514eb965ce72781.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/855/format/webp" alt></p><ul><li><strong>算法特性</strong></li></ul><p>它是单链表, 但和典型的单链表不同</p><blockquote><ol><li><code>双重队列</code>多了一个<code>isData</code>布尔属性, 说明队列可以存储<code>数据item</code>和<code>消费者本身(null表示)</code>; 它在意义上叫做<code>双重队列</code>, 但本质是<code>单链表</code><font color="red">节点item不为null,表示生产者节点;节点item为null(waiter为消费者线程), 表示消费者节点通过<code>isData</code>属性来标识</font></li><li><code>松弛度</code>如下图2, 节点匹配后(put/take匹配),节点会置为自引用(断开外界引用,GC会进行清理), 但是它不会立刻更新head/tail, 而是当一个最近的未匹配节点距离head/tail超过阈值(默认2)时才会分别更新head/tail;  这会导致队列里「消费者」和「生产者」都会出现<font color="red">这样设计的原因？正常情况是匹配删除节点后立刻更新head/tail, 但一旦队列为空, 消费者take线程会进行自旋尝试等待put来唤醒自己 (虽然不是一直自旋), 这会消耗CPU时间片设计「延迟」更新head/tail能缓解自旋带来的性能损耗, 但「延迟」有一个度, 匹配是需要遍历链表的, 过多的「冗余(已匹配的节点)」会增大遍历性能消耗</font></li></ol></blockquote><p>图1: 流程示意图<font color="pink">如下图, 按理某一时刻队列永远只会有「生产者(put)」或者「消费者(take)」, 但是由于<code>松弛特性</code>,「匹配」后不会立刻更新<code>head/tail</code>, 导致一些已匹配使用了的节点不会立刻移除;所以某一时刻, 队列里是生产者和消费者都可能出现的;<strong>注意: take消费者线程的阻塞使用了CAS自旋 (也不是一直自旋), 所以会浪费CPU时间片</strong></font></p><p>下图逻辑不对, 并不只是去匹配队头<img src="https://upload-images.jianshu.io/upload_images/4236553-d60a5b0368dd8d8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt></p><p>图2: 某一时刻队列状态图<font color="pink">上面已解释过, <code>松弛特性(默认阈值2)</code>导致生产者和消费者都会出现在队列里;</font></p><blockquote><ol><li><code>未匹配节点</code>可能是生产者(item不为null), 可能是消费者(item为null, waiter为消费线程本身)</li><li><code>已匹配节点</code>可能是生产者节点已被消费者拿走(被消费者赋值为节点自身), 也可能是消费者被生产者填充了数据(item不为null)</li></ol></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/6050820-6afec565cfff223f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/859/format/webp" alt></p><p><font color="red">上图有些不准确, 队头部分应是连续的已匹配节点, 队尾部分应是连续的未匹配节点正常的做法, 实时更新head/tail, 但这样做会增加CAS竞争开销; 所以折中办法是延迟更新head/tail;<strong>slack (head位置和第一个未匹配的结点的最大距离，尾结点类似)</strong>这是经验问题, 大多平台最佳值是1～3, jdk默认值是2所以正常情况补充为如下图:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">          head                 tail</span><br><span class="line">           |                    |</span><br><span class="line">           v                    v</span><br><span class="line">M   M  -&gt;  M  -&gt;  M  -&gt;  U  -&gt;  U  -&gt; U  -&gt;  U</span><br></pre></td></tr></table></figure><h3 id="二-源码分析">二. 源码分析</h3><ul><li>基本属性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MP表示是否是多核处理器</span></span><br><span class="line"><span class="keyword">boolean</span> MP = Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 当一个节点目前是队列的第一个等待者(waiter), 在多核处理器上自旋的次数2^7(随机穿插调用thread.yield)</span></span><br><span class="line"><span class="keyword">int</span> FRONT_SPINS   = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line"><span class="comment">// 当一个节点先于另一个明显自旋的结点阻塞时自旋的次数</span></span><br><span class="line"><span class="comment">// 前继节点正在处理, 当前节点阻塞前的自旋次数</span></span><br><span class="line"><span class="keyword">int</span> CHAINED_SPINS = FRONT_SPINS &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="comment">// sweepVotes(清除已匹配节点)的阀值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SWEEP_THRESHOLD = <span class="number">32</span>;</span><br><span class="line"><span class="comment">// 队列头节点，第一次入列之前为空</span></span><br><span class="line">Node head;</span><br><span class="line"><span class="comment">// 队列尾节点，第一次添加节点之前为空</span></span><br><span class="line">Node tail;</span><br><span class="line"><span class="comment">// 累计到一定次数再清除已匹配node</span></span><br><span class="line"><span class="keyword">int</span> sweepVotes;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * xfer执行类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> NOW   = <span class="number">0</span>; <span class="comment">// for untimed poll, tryTransfer</span></span><br><span class="line"><span class="keyword">int</span> ASYNC = <span class="number">1</span>; <span class="comment">// for offer, put, add</span></span><br><span class="line"><span class="keyword">int</span> SYNC  = <span class="number">2</span>; <span class="comment">// for transfer, take</span></span><br><span class="line"><span class="keyword">int</span> TIMED = <span class="number">3</span>; <span class="comment">// for timed poll, tryTransfer</span></span><br></pre></td></tr></table></figure><ul><li><strong>链表节点Node数据结构</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isData;  <span class="comment">// put型(true), take型(false)</span></span><br><span class="line">Object item;     <span class="comment">// put型(不为null), take型(null)</span></span><br><span class="line">Node next;       <span class="comment">// 后继节点</span></span><br><span class="line">Thread waiter;   <span class="comment">// 特指消费者线程(入队阻塞等待匹配)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CAS更新当前结点next字段</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(Node cmp, Node val)</span></span></span><br><span class="line"><span class="function"><span class="comment">// CAS更新当前结点的item字段</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">casItem</span><span class="params">(Object cmp, Object val)</span></span></span><br><span class="line"><span class="function"><span class="comment">// CAS设置当前结点的next字段为自身(自引用, 即删除)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forgetNext</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// CAS设置item字段为node自身，waiter为null</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forgetContents</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 是否是匹配了的结点</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isMatched</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 是否是未匹配的消费者take型节点</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isUnmatchedRequest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 当该节点是未匹配节点却与当前的结点类型不符的时候，返回true。</span></span></span><br><span class="line"><span class="function"><span class="comment">// 意思就是当前都是请求节点，数据节点应该立刻被消耗，未匹配的结点应该是同一种节点才允许附加入队</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">cannotPrecede</span><span class="params">(<span class="keyword">boolean</span> haveData)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 数据节点尝试匹配</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryMatchData</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><ul><li><strong><code>xfer</code>基本流程</strong></li></ul><p>根据如下队列快照, 来讲述一下流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 意味着M1匹配成功, 准备将head指针指向M1后继节点U1</span></span><br><span class="line"><span class="comment"> * 注意M1还保留着next引用, 后面会根据阈值进行清扫</span></span><br><span class="line"><span class="comment"> * 最后会将原始head节点断开next引用</span></span><br><span class="line"><span class="comment"> * ************************************************</span></span><br><span class="line"><span class="comment"> *           head                   tail</span></span><br><span class="line"><span class="comment"> *            |                      |</span></span><br><span class="line"><span class="comment"> *            v                      v</span></span><br><span class="line"><span class="comment"> * M   M  -&gt;  M  -&gt;  M1  -&gt;  U1  -&gt;  U  -&gt; U  -&gt;  U</span></span><br><span class="line"><span class="comment"> * ************************************************</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><blockquote><ol><li>从head开始向后匹配, 找到一个节点模式跟本次操作的模式不同的未匹配的节点（生产或消费）进行匹配; 没找到则下一个节点; 遍历完都没匹配到, 则准备尝试入队尾<strong>注意:<code>Node n = p.next; p = (p != n) ? n : (h = head);</code>p==n表明是已匹配且删除的节点(自引用), 说明有其他线程赶在前面匹配成功且重置了head, 需要重新从头部遍历, p!=n则继续遍历</strong></li><li>找到未匹配节点, 如果发现节点和当前节点同类型, 说明整个队列未匹配的节点都是put或者take(如上图); 跳出循环准备尝试入队尾</li><li>找到为匹配节点, 且不同类型, 说明允许匹配, 则开始匹配操作;</li><li>开始匹配, CAS更新item, 失败说明被其他线程抢先, 继续循环直到CAS更新item成功(匹配成功);对照下面代码注解</li><li>尝试入队<code>tryAppend</code></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.若CAS更新item成功, 表示匹配成功</span></span><br><span class="line"><span class="comment"> * 2.开始判断是否更新head, (q=p &amp;&amp; q!=h)表明p肯定是head之后的节点(其实就是head-&gt;next),</span></span><br><span class="line"><span class="comment"> *   然后n=q.next, 表明跳过了2个节点, slack=2满足条件则开始CAS更新head指针</span></span><br><span class="line"><span class="comment"> *   如果head的next节点未被匹配，跳出循环，不更新head，也就是松弛度&lt;2</span></span><br><span class="line"><span class="comment"> * 3.最后唤醒匹配节点其中的消费者节点线程(waiter), 返回节点的item值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (p.casItem(item, e)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Node q = p; q != h;) &#123;</span><br><span class="line">        Node n = q.next;  <span class="comment">// update by 2 unless singleton</span></span><br><span class="line">        <span class="keyword">if</span> (head == h &amp;&amp; casHead(h, n == <span class="keyword">null</span> ? q : n)) &#123;</span><br><span class="line">            <span class="comment">// 将原始head的next指向自己, 即自引用(删除)</span></span><br><span class="line">            h.forgetNext();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;                 <span class="comment">// advance and retry</span></span><br><span class="line">        <span class="comment">// 如果head的next节点未被匹配，跳出循环，不更新head，也就是松弛度&lt;2</span></span><br><span class="line">        <span class="keyword">if</span> ((h = head) == <span class="keyword">null</span> ||</span><br><span class="line">                (q = h.next) == <span class="keyword">null</span> || !q.isMatched())</span><br><span class="line">            <span class="keyword">break</span>;        <span class="comment">// unless slack &lt; 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后唤醒匹配节点其中的消费者节点线程(waiter), 返回节点的item值</span></span><br><span class="line">    LockSupport.unpark(p.waiter);</span><br><span class="line">    <span class="keyword">return</span> OwnLinkedTransferQueue.&lt;E&gt;cast(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试入队</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">tryAppend</span><span class="params">(Node s, <span class="keyword">boolean</span> haveData)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Node t = tail, p = t;;) &#123;        <span class="comment">// move p to last node and append</span></span><br><span class="line">        Node n, u;                        <span class="comment">// temps for reads of next &amp; tail</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果队列为空, 则将节点CAS设置为队头, 它没有前继节点则返回自己</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; (p = head) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casHead(<span class="keyword">null</span>, s))</span><br><span class="line">                <span class="keyword">return</span> s;                 <span class="comment">// initialize</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 还有未匹配的节点, 如果入队尾则会违反算法逻辑, 因为根本没必要入队, 此时返回true表明「入队不能发生在还未匹配完之前」</span></span><br><span class="line">        <span class="comment">// 注意: 其实这种情况发生在put和take多线程竞争, 比如一个put节点遍历之后没有找到还未匹配的take节点,开始准备入队尾,</span></span><br><span class="line">        <span class="comment">//       再次判断的时候, 发现期间发生了很多take操作(多于put操作); 此时则不允许入队, 需要重新循环整个队列</span></span><br><span class="line">        <span class="comment">// 简单点说: 有相反类型的节点先附加入队(称之为失速)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.cannotPrecede(haveData))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;                  <span class="comment">// lost race vs opposite mode</span></span><br><span class="line">        <span class="comment">// 如果发现队尾还有后继节点, 说明期间有其他操作入队(可能同类型,也可能不同类型)</span></span><br><span class="line">        <span class="comment">// 说明期间其他线程在维护tail尾节点, t变量为过时的tail</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((n = p.next) != <span class="keyword">null</span>) &#123;  <span class="comment">// not last; keep traversing</span></span><br><span class="line">            <span class="comment">//p = p != t &amp;&amp; t != (u = tail) ? (t = u) : (p != n) ? n : null;      // restart if off list</span></span><br><span class="line">            p = (p != t &amp;&amp; t != (u = tail)) ? (t = u) : ((p != n) ? n : <span class="keyword">null</span>);    <span class="comment">// 更新为最新的tail, 重新开始</span></span><br><span class="line">            <span class="comment">//  ---------------------------   -------   ---------------------</span></span><br><span class="line">            <span class="comment">//   p = boolean ? t : (boolean ? n : null)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CAS入队尾节点失败, 说明有其他线程在入队</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!p.casNext(<span class="keyword">null</span>, s))</span><br><span class="line">            p = p.next;                   <span class="comment">// re-read on CAS failure</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p != t) &#123;                 <span class="comment">// update if slack now &gt;= 2</span></span><br><span class="line">                <span class="keyword">while</span> ((tail != t || !casTail(t, s)) &amp;&amp;</span><br><span class="line">                        (t = tail)   != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        (s = t.next) != <span class="keyword">null</span> &amp;&amp; <span class="comment">// advance and retry</span></span><br><span class="line">                        (s = s.next) != <span class="keyword">null</span> &amp;&amp; s != t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>awaitMatch(后续补充)</strong></li></ul><p><code>自旋/让步/阻塞,直到给定节点s匹配到或放弃匹配</code>当前操作为同步操作时，会调用<code>awaitMatch</code>方法阻塞等待匹配，成功返回匹配节点 item，失败返回给定参数e（s.item）。在等待期间如果线程被中断或等待超时，则取消匹配，并调用<code>unsplice</code>方法解除节点s和其前继节点的链接</p><ul><li><strong>unsplice(后续补充)</strong></li></ul><p><code>解除给定已经被删除/取消节点和前继节点的链接（可能延迟解除）</code>首先把给定节点s的next引用指向自身，如果s的前继节点pred还是指向s（pred.next == s），尝试解除s的链接，把pred的 next 引用指向s的 next 节点。如果s不能被解除（由于它是尾节点或者pred可能被解除链接，并且pred和s都不是head节点或已经出列），则添加到sweepVotes，sweepVotes累计到阀值SWEEP_THRESHOLD之后就调用sweep()对队列进行一次“大扫除”，清除队列中所有的无效节点。sweep()</p><ul><li><strong>sweep(后续补充)</strong></li></ul><p><code>解除(通常是取消)从头部遍历时遇到的已经被匹配的节点的链接</code></p><p>参考:<a href="https://www.jianshu.com/p/42ceaed2afe6" target="_blank" rel="noopener">JUC源码分析-集合篇（六）：LinkedTransferQueue</a><a href="https://www.jianshu.com/p/ae6977886cec" target="_blank" rel="noopener">并发编程-LinkedTransferQueue</a></p><h2 id="synchronousqueue-后续补充">SynchronousQueue（后续补充）</h2><blockquote><ol><li></li></ol></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/6050820-5bc09993fe75642d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/698/format/webp" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;两者是比较特殊的阻塞队列&lt;/p&gt;
&lt;h2 id=&quot;linkedtransferqueue&quot;&gt;LinkedTransferQueue&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;单向链表结构的无界阻塞队列 (CAS无锁)&lt;/li&gt;
&lt;li&gt;遵循&lt;strong&gt;hap
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="https://doooyo.github.io/2019/04/22/JVM/"/>
    <id>https://doooyo.github.io/2019/04/22/JVM/</id>
    <published>2019-04-21T16:32:29.233Z</published>
    <updated>2019-04-21T16:32:29.233Z</updated>
    
    <content type="html"><![CDATA[<p>JVM在性能优化时是必备知识点, 则必须知道JVM内存的结构, 如何GC回收, 如何使用工具和参数来实现调优;</p><blockquote><p><strong>JVM内存结构</strong><strong>GC回收机制与算法</strong><strong>垃圾收集器,使用性能监控工具调优,参数调优</strong><strong>动态字节码</strong><strong>类加载器</strong></p></blockquote><hr><h2 id="一-jvm内存结构">一 JVM内存结构</h2><h3 id="1-结构图">(1)结构图</h3><p>注意区别于JMM内存模型图1<img src="https://static.oschina.net/uploads/space/2018/0120/101859_uZAV_867830.png" alt></p><p>根据线程私有还是公有, 给出一张图,<font color="red">注意程序计数器没有内存异常;注意:</font></p><ol><li>申请Heap堆空间内存不足, 或者栈允许动态扩容且申请内存不足时抛出<code>OutOfMemeryError</code>; 一般是大量创建对象时才会发生堆内存溢出</li><li>只有栈才会抛出<code>StackOverFlowError</code>, 一般情况是入栈深度大于虚拟机所允许的深度, 常见的就是递归方法栈溢出(解决办法请见<code>尾递归</code>)图2<img src="http://incdn1.b0.upaiyun.com/2017/11/a48d39eef1ee33faede51c11d8a06780.png" alt></li></ol><h3 id="2-jvm内存的五大区域">(2)jvm内存的五大区域</h3><p>堆, 栈, 本地栈, 方法区(永久代), 程序计数器</p><blockquote><ol><li><strong><code>堆 Heap</code></strong>所有<strong>线程共享</strong>, JVM中最大的一块内存, 用于存储对象实例本身; 同时堆是垃圾搜集器管理的主要区域;所有对象以及数组都需要在堆上分配空间;堆的还有更具体的划分, 新生代, 老生代;堆大小可通过-Xmx 和 -Xms指定, 无法再扩展则会抛出OutOfMemoryError<font color="red">Heap堆里分为几块区域:<strong>方法区(永久代/Meta-Area)</strong>: 这块区域名字几经变化, java8叫做元数据空间; 主要存储jvm加载类的类信息，类变量，静态变量，方法信息，常量，即时编译器编译后的代码等数据<strong>运行时常量区</strong>: 它是<code>方法区</code>里的一部分, 存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中 (比如我们常说的字符串常量池)<strong>注意: jvm将方法区描述为Heap堆区的一个逻辑部分, 但实际上它的别名叫non-heap(非堆)</strong></font></li></ol></blockquote><blockquote><ol start="2"><li><strong><code>栈 Stack</code></strong>单个<strong>线程私有</strong>, 每个方法执行时都会创建栈, 线程执行每个方法其实就是栈帧的出栈入栈 (一个栈帧对应一个方法), 栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息<font color="red"><strong>局部变量表</strong>: 用于存储形参, 局部变量(基本类型/对象引用/返回类型); 它在编译期(class文件)完成局部变量表容量的计算, 运行期不会改变其大小<strong>操作数栈</strong>: 即方法执行期间出栈入栈操作, 栈的深度编译期就已确定; Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈, 也称Java虚拟机是基于栈的; 优点是可移植性好, 缺点是执行速度相对慢一些 (相对Android基于寄存器的虚拟机)<strong>动态链接</strong>: 每个栈帧都包含一个指向运行时常量池(位于方法区)中该栈帧所属方法的引用, 持有这个引用是为了支持方法调用过程中的动态连接;Class文件的常量池中存在有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数<code>静态解析</code>: 一部分符号引用会在类加载阶段或第一次使用的时候转化为直接引用（如 final、static 域等）<code>动态连接</code>: 另一部分将在每一次的运行期间转化为直接引用<strong>方法返回地址</strong>: 方法被执行后, 有两种方式退出该方法: 执行引擎遇到了任意一个方法返回的字节码指令或遇到了异常, 并且该异常没有在方法体内得到处理;方法退出后需要返回到方法被调用的位置, 如果是正常退出, 上层方法的栈帧会保存一些地址信息以便返回, 如果是异常退出, 则需要通过异常处理器来确定返回地址;<strong>退出方法需要做的操作: 恢复上层方法的局部变量表和操作数栈, 若有返回值则还需要压入调用者栈帧的操作数栈中</strong></font></li></ol></blockquote><blockquote><ol start="3"><li><strong><code>本地方法栈 Native Static</code></strong>单个<strong>线程私有</strong>, 和java栈很类似, 只是它存的是JVM调用C++的方法局部变量等</li></ol></blockquote><blockquote><ol start="4"><li><strong><code>程序计数器</code></strong>单个<strong>线程私有</strong>, 记录了当前线程执行到哪一条指令, 因为每个线程都有一个独立的线程计数器, 目的是为了线程切换的时候能恢复到正常执行位置 (cpu时间片只能执行一个指令)注意它没有抛出内存异常, 查阅上图2</li></ol></blockquote><blockquote><ol start="5"><li><strong><code>堆外内存(直接内存)</code></strong>这个不属于JVM内存管理的范畴, 所以回收跟c和c++一样需要自己回收, 而不通过垃圾回收器NIO中就有一个DirectByteBuffer可以开辟堆外内存</li></ol></blockquote><p><font color="orange">总结 :</font></p><ol><li>方法区：方法区称为持久代，因为GC会很少回收这块区域，但不代表不回收；比如运行时常量区，除了存储编译期常量外（字面常量、符号引用、翻译出来的直接引用），也可以存储在运行时间产生的常量，比如String类的intern()方法；针对持久代的回收一般是对<code>常量池</code>和<code>已加载类的卸载</code>进行回收；方法区可以设置大小：<code>--XX:PermSize</code>，<code>--XX:MaxPermSize</code>；方法区超出允许的大小会抛出OutOfMemory异常，一般来说无须调整方法区大小<font color="red">2. 运行时常量池和方法区的区别方法区包含两部分：其一，Class类信息(类的版本、字段、方法、接口等描述信息)其二，运行时常量池，主要是编译期生成的各种字面量和符号引用；它具有动态性，并不要求常量一定只有编译期才能产生，运行时也可产生，最常见的即String.intern()</font></li><li>堆区：常将-Xms和-Xmx设置成一样。为了让内存回收更加高效</li></ol><h3 id="3-hotspot逃逸分析">(3) <strong>HotSpot逃逸分析</strong></h3><p>这是HotSpot虚拟机比较前沿的优化技术, 一种全局的跨函数数据流分析算法;可以有效减少Java程序中同步负载, 降低内存堆分配压力和GC压力</p><p><font color="orange">首先要了解java创建对象或数组一般是在Heap堆上, 但这不是绝对; 有两种方式导致创建出来的对象不在Heap堆上 :</font></p><blockquote><ol><li>Java中的逃逸分析</li><li>TLAB（Thread Local Allocation Buffer）线程私有的缓存区</li></ol></blockquote><p>首先要了解什么是<code>java逃逸分析</code>?<font color="red"><strong>逃逸分析的基本行为就是分析对象动态作用域, 是否跨域了; 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上</strong></font></p><blockquote><p>发生逃逸的2种情况</p><blockquote><ol><li>当一个对象在方法中定义之后, 作为参数传递到其它方法中</li><li>如类变量或实例变量, 可能被其它线程访问到</li></ol></blockquote></blockquote><p>若没有出现逃逸行为, 则可以通过如下行为进行优化:</p><blockquote><ol><li>同步消除</li><li>标量替换</li><li>栈上分配</li></ol></blockquote><p><strong>1. 同步消除</strong><font color="orange">如果确定对象不会逃逸出线程, 无法被其他线程访问到, 那该对象的读写就不会存在竞争, 则可以消除对该对象的同步锁, 通过<code>-XX:+EliminateLocks</code>可以开启同步消除<strong>注意: 如果有逃逸行为, 但是线程永远只有一个(无锁竞争), 这时HotSpot不会做任何优化, 只是互斥锁会一直是偏向锁而已</strong></font></p><p><strong>2. 标量替换</strong></p><blockquote><p><font color="orange"><strong>1.</strong> 标量是指不可分割的量，如java中基本数据类型和reference类型，相对的一个数据可以继续分解，称为聚合量；<strong>2.</strong> 如果把一个对象拆散，将其成员变量恢复到基本类型来访问就叫做标量替换；<strong>3.</strong> 如果逃逸分析发现一个对象不会被外部访问，并且该对象可以被拆散，那么经过优化之后，并不直接生成该对象，而是在栈上创建若干个成员变量<strong>4.</strong> 通过<code>-XX:+EliminateAllocations</code>可以开启标量替换， <code>-XX:+PrintEliminateAllocations</code>查看标量替换情况</font></p></blockquote><p><strong>3. 栈上分配</strong><font color="orange">其实目前Hotspot并没有实现真正意义上的栈上分配，实际上是标量替换;堆内存的开辟和GC回收都是耗时操作, 如果能优化为栈上(局部变量表)分配, 栈帧出栈即会销毁, 大大减少堆分配和GC压力</font></p><p><strong>4. 总结</strong><font color="red">逃逸分析是一项耗时操作, 目前的实现都是采用不那么准确但是时间复杂度相对较小的算法来完成逃逸分析, 这就可能导致效果不稳定, 要<strong>慎用</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HotSpot逃逸分析 (创建200w个对象, 查看Heap堆的对象分布情况)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 即时编译（Just-in-time Compilation，JIT）</span></span><br><span class="line"><span class="comment"> * 是一种通过在运行时将字节码翻译为机器码，从而改善字节码编译语言性能的技术;</span></span><br><span class="line"><span class="comment"> * 1. C1编译速度快, 优化方式比较保守  (client)</span></span><br><span class="line"><span class="comment"> * 2. C2编译速度慢, 优化方式比较激进  (server)</span></span><br><span class="line"><span class="comment"> * 3. C1+C2在开始阶段采用C1编译, 当代码运行到一定热度之后采用G2重新编译 (分层编译)</span></span><br><span class="line"><span class="comment"> * 在1.8之前, 分层编译默认是关闭的, 可以添加-server -XX:+TieredCompilation参数进行开启</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. java -cp . -Xmx3G -Xmn2G -server -XX:-DoEscapeAnalysis DoEscapeAnalysis // 运行代码</span></span><br><span class="line"><span class="comment"> *    (-XX:-DoEscapeAnalysis // 关闭逃逸分析)</span></span><br><span class="line"><span class="comment"> *    jmap -histo [pid] // 查看Heap堆对象分布情况</span></span><br><span class="line"><span class="comment"> *    结果: 堆上200w个User对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. java -cp . -Xmx3G -Xmn2G -server DoEscapeAnalysis // 运行代码</span></span><br><span class="line"><span class="comment"> *    jmap -histo [pid] // 开启逃逸分析后, 查看Heap堆对象分布情况</span></span><br><span class="line"><span class="comment"> *    结果: 堆上41w+个User对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. java -cp . -Xmx3G -Xmn2G -server -XX:-TieredCompilation DoEscapeAnalysis //运行代码</span></span><br><span class="line"><span class="comment"> *    (-XX:-TieredCompilation // 关闭分层编译)</span></span><br><span class="line"><span class="comment"> *    jmap -histo [pid]</span></span><br><span class="line"><span class="comment"> *    结果: 堆上1w+个User对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 总结: 开启JIT分层编译会阻碍逃逸分析</span></span><br><span class="line"><span class="comment"> *     即时编译JIT只在代码段执行足够次数才会进行优化，在执行过程中不断收集各种数据，</span></span><br><span class="line"><span class="comment"> *     作为优化的决策，所以在优化完成之前，例子中的User对象还是在堆上进行分配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoEscapeAnalysis</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> age;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1000000</span>;</span><br><span class="line">        <span class="comment">//warm up</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            sum += fn(i);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            sum += fn(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fn</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(age);</span><br><span class="line">        <span class="keyword">int</span> i = user.getAge();</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考:<a href="http://www.importnew.com/27262.html" target="_blank" rel="noopener">Java 逃逸分析</a><a href="https://www.jianshu.com/p/20bd2e9b1f03" target="_blank" rel="noopener">浅谈HotSpot逃逸分析</a></p><hr><h2 id="二-gc回收机制与算法">二 GC回收机制与算法</h2><p>上面说过, JVM内存结构被描述为五大区域, 其中「程序计数器」,「native方法栈」,「虚拟机栈」三个是线程私有, 伴随线程的生命周期而生灭, 因此分配和回收具备确定性;垃圾收集器的工作场所主要是在Heap堆区</p><h3 id="1-堆内存分布">(1) 堆内存分布</h3><p>jvm堆内存分布图 : 所有回收器类型都是基于分代技术</p><blockquote><ol><li>新生代 : 分为三个区域<font color="red"> <strong>原始区(Eden) :</strong> 对象绝大部分在此区分配 (除非对象太大放不下则会放到<code>老年代</code>);<strong>存活区s1(From) :</strong> s1和s2是两块大小相同的存活区<strong>存活区s2(To) :</strong> 回收结束后, s1和s2交换, 保证<code>s2(To)</code>为空<strong>总结 :</strong> 回收选型为<code>Copy复制</code>, 回收后<code>原始区(Eden), s2(To)</code>是空的原始区和两个存活区按照 <strong>8:1:1</strong>的比例分配空间</font></li><li>老年代 :回收时, <code>标记（Mark</code>）、<code>清除（Sweep）</code>、<code>合并（Compact）</code>, 回收选型为<code>Compact合并</code></li></ol></blockquote><blockquote><ol start="3"><li>永久代 :也叫做<code>方法区</code>, 现在叫做<code>元数据区</code> (详情见上面)</li></ol></blockquote><p>图1<img src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=3927290212,3064353507&amp;fm=173&amp;s=9133C13245F8EE202E4D68CB02005032&amp;w=639&amp;h=156&amp;img.JPEG" alt></p><p>图2<img src="http://t11.baidu.com/it/u=4191374602,3766009169&amp;fm=173&amp;s=D9A019729FB84C030AFDE1DB000080B2&amp;w=640&amp;h=223&amp;img.JPEG" alt></p><blockquote><ol><li><strong>垃圾收集算法</strong>1.1 tracing算法 (标记-清除收集器)1.2 copying算法 (上面图中的s1, s2就是容量相等的两块区域)1.3 compacting算法1.4 generation算法</li><li><strong>常用垃圾收集器</strong>2.1 标记-清除收集器 Mark-Sweep2.2 复制收集器 Copying　　2.3 标记-压缩收集器 Mark-Compact2.4 分代收集器　　　Generational</li><li><strong>对象回收算法</strong>3.1 引用计数算法3.2 可达性分析算法</li></ol></blockquote><h3 id="2-垃圾回收算法">(2) 垃圾回收算法</h3><h4 id="1-tracing算法-mark-sweep-标记-清除收集器">1. tracing算法 (Mark-Sweep/标记-清除收集器)</h4><p>它是最简单的算法, 效率也是最高, 但缺陷也是最大的</p><blockquote><ol><li>标记(Mark) :从根集合（GC Roots）进行扫描, 对存活的对象进行标记</li><li>清除(Sweep) :再扫描整个空间中未被标记的对象，进行回收</li><li><font color="red">注意: 标记清除没有移动对象, 所以不管存活对象多不多, 这都是效率最高的方式, 但严重缺陷是会有内存碎片;极端情况时, 碎片太多导致大对象(数组)无法分配, 提前触发新的一次垃圾收集动作, 再次无法分配直接抛出OutOfMemeryError异常</font></li></ol></blockquote><p><img src="http://images0.cnblogs.com/i/288799/201406/181024382398115.jpg" alt></p><h4 id="2-copying算法-copying收集器">2. copying算法 (Copying收集器)</h4><p>为解决内存碎片, 提出此算法</p><blockquote><p>它将可用内存按容量划分为大小相等的两块, 每次只使用其中的一块;当这一块的内存用完了, 就将还存活着的对象复制到另外一块上面, 然后再把已使用的内存空间一次清理掉;这样一来就不容易出现内存碎片的问题<font color="red">注意: 此方式高效且没有内存碎片, 但是内存空间却浪费了一半如果存活对象很多, 那么复制的数量大大增加, 效率直线下降</font></p></blockquote><p>可以看出, 新生代中<code>Survivor1/Survivor2</code>就是两个相等的存活区, 所以jvm对于<code>新生代</code>的垃圾回收就是使用<code>copying算法</code><img src="http://images0.cnblogs.com/i/288799/201406/181041528488728.jpg" alt></p><h4 id="3-compacting算法-mark-compact-标记-压缩收集器">3. compacting算法 (Mark-Compact/标记-压缩收集器)</h4><p>为解决空间浪费, 以及移动大量活动对象造成效率低下, 提出此算法</p><blockquote><p>为了解决Copying算法的缺陷，充分利用内存空间，提出了Mark-Compact算法。该算法标记阶段和Mark-Sweep一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存</p></blockquote><h4 id="4-generation分代算法">4. Generation分代算法</h4><p>这是大部分HotSpot垃圾收集器采用的算法, 核心思想是根据对象生命后期进行分代, 将堆分为<code>新生代</code>, <code>老年代</code></p><p>图3<img src="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=503803508,4219141947&amp;fm=173&amp;s=90A3F11206AE5509084C6AEE0200E032&amp;w=640&amp;h=430&amp;img.JPEG" alt></p><ul><li>新生代</li></ul><p>其特点是每次GC都有大量对象被回收, 存活对象少;  所以<code>新生代</code>很适合<code>copying算法</code>, 因为复制的对象较少</p><blockquote><p>1 原始区 : <strong>较大</strong>; 是绝大多数对象分配内存的地方(少数放不下可能直接放到<code>老年代</code>)2 两块存活区 : <strong>较小,且一样大</strong>, 目的是为了符合<code>copying</code>算法3 minor gc : <font color="orange">3.1 Eden区域的空间不足于分配新对象时, 首次触发minor gc3.2 将存活对象拷贝到<code>s1(From)</code>, 清除<code>Eden</code>不可达对象, 同时年龄+1 (年龄就是minor gc的次数)3.3 当<code>s1(From)</code>也满了, 则第二次触发<code>minor gc</code>时, 将<code>Eden</code>, <code>s1(From)</code>中存活对象拷贝到<code>s2(To)</code>, 各自对象年龄+1, 清空<code>Eden</code>, <code>s1(From)</code>; 注意如果s2放不下则会直接放到<code>老年代</code>3.4 垃圾回收后<code>Eden</code>, <code>s1(From)</code>是空的; 此时<strong>交换s1和s2, 保证s2(To)是空的</strong>, 如此往复</font></p></blockquote><p>**<font color="red">注意 ：首先年轻代的默认空间配比: <code>Eden:s1:s2--&gt;8:1:1</code>, 可通过jvm参数调整(后续说明)</font></p><ol><li>年龄即为minor的次数, 每GC一次年龄+1 (默认超过8次minor gc还未回收则会进入老年代)</li><li>每次回收触发原因是由于<code>Eden</code>或者<code>s1(From)</code>空间不足 (当然还有Full GC)**</li></ol><ul><li>新生代垃圾回收流程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 在初始阶段，新创建的对象被分配到Eden区，survivor的两块空间都为空</span><br><span class="line"><span class="number">2</span>. 当Eden区满了的时候，minor garbage 被触发</span><br><span class="line"><span class="number">3</span>. 经过扫描与标记，存活的对象被复制到S1，不存活的对象被回收，清空Eden；首次回收完毕</span><br><span class="line">注意：当S1满了，则会触发第二次minor gc，和下面情形相同</span><br><span class="line"><span class="number">4</span>. 当Eden再次满时，触发第二次年轻代GC，Eden和S1存活的对象将会被拷贝到S2（放不下的会被放到老年代）</span><br><span class="line"><span class="number">5</span>. 清空Eden和S1，交换S1和S2，第二次回收完毕</span><br><span class="line"><span class="number">6</span>. 此时Eden和S2是空的，再循环往复</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"><span class="number">1</span>. 每次minor gc后，年龄+<span class="number">1</span></span><br><span class="line"><span class="number">2</span>. 若不指定，默认<span class="number">8</span>次minor gc后进入老年代</span><br><span class="line"><span class="number">3</span>. 如果触发gc后Eden还是无法分配内存，抛出OutOfMemery</span><br><span class="line"><span class="number">4</span>. s2不足以放下Eden和s1的存活对象，直接放到老年代</span><br><span class="line"><span class="number">5</span>. 老年代也满了则会触发Full GC，即新生代老年代都回收</span><br><span class="line"><span class="number">6</span>. 这里涉及-Xmx -Xms -Xmn -Xss的堆大小指定，</span><br><span class="line">还有-XX:NewRatio -XX:SurvivorRatio -XX:MaxPermSize -XX:MaxPermSize 堆的比例等等，后续讲解</span><br></pre></td></tr></table></figure><ul><li>老年代</li></ul><p>其特点是对象存活率很高，很少回收，所以很适合compacting算法（标记压缩）堆空间默认大致配比:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">原始区   存活区(from)   存活区(to)    老年代</span><br><span class="line">Eden    Survivor1     Survivor2    Tenured</span><br><span class="line"><span class="number">8</span>       <span class="number">1</span>             <span class="number">1</span>            <span class="number">10</span></span><br></pre></td></tr></table></figure><blockquote><p>标记出存活的对象， 并移动向一端以保证没有内存碎片，因为有移动，所以适合少量对象回收的情况（大量实践证明的确老年代很少有对象回收）</p></blockquote><p><font color="red">从新生代晋升到老年代会先判断老年代的剩余空间大小，如果不够存放一个对象，则会触发Full GC<code>XX:+Handle PromotionFailure</code>是只要晋升到老年代就会触发Full GC，就算老年代还有很多内存富余也会触发，所以最好不要用</font></p><ul><li>永久代(方法区)</li></ul><p>一般情况下很少回收永久代，如下两种情况会触发永久代回收如果不想回收永久代，可以通过jvm参数设置甚至可以设置Eden区域对象不经过存活区直接到老年代<font color="red">jvm规范的确不要求回收永久代，只是性价比很低，而且回收无用的类时条件十分苛刻；当然各个厂商的jvm实现也可以不回收；</font></p><p><strong>但是在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出</strong></p><p>方法区(永久代)可回收的内容：</p><blockquote><ol><li>常量池中的常量没有引用即可回收</li><li>无用的类信息 (条件苛刻, 必须保证如下3点)2.1 类的所有实例都已经被回收2.2 加载类的ClassLoader已经被回收2.3 类对象的Class对象没有被引用（即没有通过反射引用该类的地方）</li></ol></blockquote><ul><li>Minor GC ，Full GC 触发条件</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="string">Minor</span> <span class="string">GC触发条件</span> <span class="string">:</span></span><br><span class="line">    <span class="string">当Eden区满时，触发Minor</span> <span class="string">GC</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span><span class="string">Full</span> <span class="string">GC触发条件</span> <span class="string">:</span></span><br><span class="line">    <span class="number">2.1</span> <span class="string">调用System.gc时，系统建议执行Full</span> <span class="string">GC，但是不必然执行</span></span><br><span class="line">    <span class="number">2.2</span> <span class="string">老年代空间不足</span></span><br><span class="line">    <span class="number">2.3</span> <span class="string">永久代（方法区）空间不足</span></span><br><span class="line">    <span class="number">2.4</span> <span class="string">通过Minor</span> <span class="string">GC后进入老年代的平均大小大于老年代的可用内存</span></span><br><span class="line">    <span class="number">2.5</span> <span class="string">由Eden区、From</span> <span class="string">Space区向To</span> <span class="string">Space区复制时，对象大小大于To</span> <span class="string">Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-对象回收算法">(3) 对象回收算法</h3><p>上面讲述了垃圾回收采用分代算法，组合使用了<code>标记压缩</code>和<code>复制</code>；</p><blockquote><p>问题1: 标记对象不可达是如何计算的呢？问题2: 释放对象又是如何做到的呢？问题3: finalize方法?</p></blockquote><h4 id="1-finalize方法">1. finalize方法</h4><p>jvm只会回收new出来的内存堆块，通过native方法调用操作系统函数创建的对象则无法回收；<font color="red">finalize作用：finalize用于在GC发生前事先调用去回收JNI调用中申请的特殊内存，下次GC发生时候保证GC后所有该对象的内存都释放了</font></p><ul><li>特点</li></ul><blockquote><ol><li>finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法</li><li>finalize()与C<ins>中的析构函数不是对应的。C</ins>中的析构函数调用的时机是确定的（对象离开作用域或delete掉），但Java中的finalize的调用具有不确定性</li><li>不建议用finalize方法完成“非内存资源”的清理工作，但建议用于：① 清理本地对象(通过JNI创建的对象)；② 作为确保某些非内存资源(如Socket、文件等)</li></ol></blockquote><p><font color="red">当GC时，发现对象不可达，</font></p><ol><li>对象没有重写finalize方法，或者finalize已经被执行过（此方法只会被执行一次），则标记可清除</li><li>对象重写了finalize方法，则不会直接回收，会判断对象是否执行过finalize方法 (因为此方法只允许执行一次)，没有执行过就会放入<code>F-Queue队列</code>，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。</li></ol><p>所以，finalize被执行的不确定性太大，不要指望使用finalize来回收你的对象，它只会在系统进行GC的时候清理特殊内存，不受你的控制；因为它不是C/C<ins>中的析构函数，而是Java刚诞生时为了使C/C</ins>程序员更容易接受它所做出的一个妥协，运行代价高昂，不确定性大，无法保证各个对象的调用顺序</p><p><img src="http://img.blog.csdn.net/20131006163937765" alt></p><p>对象通过<code>finalize</code>’自救’</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeTest SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeTest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一次断开强引用, 即删除 (通过finalize自救)</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 建议系统Full GC</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 休眠半秒, 等待Full GC完成</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//此时对象应该处于(reachable, finalized)状态</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != SAVE_HOOK) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Yes , I am still alive"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"No , I am dead"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二次断开强引用, 即删除(finalize已执行过一次, 无法自救)</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != SAVE_HOOK) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Yes , I am still alive"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"No , I am dead"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只会执行一次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"execute method finalize()"</span>);</span><br><span class="line">        <span class="comment">// 只能自救一次, 重新添加引用, 第二次标记不可达时会从F-Queue队列移除</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-回收算法">2. 回收算法</h4><p>对象回收算法有两类：<code>引用计数法</code>，<code>根搜索算法</code></p><h5 id="2-1-引用计数法">2.1 引用计数法</h5><p>有一个巨大缺陷：无法检测循环引用问题<img src="http://img-blog.csdn.net/20171129111132033?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY4NjY4MDg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p><h5 id="2-2-根搜索算法-gc-roots">2.2 根搜索算法(GC Roots)</h5><p>根搜索是根据一系列作为root根的对象, 进行图遍历(引用链), 如果当一个对象到GC Roots没有任何引用链相连时, 则证明此对象是不可用的</p><ul><li>为GC Roots根对象</li></ul><p>可以为如下四类</p><blockquote><ol><li>Java虚拟机栈中引用的对象User user= new User()</li><li>静态属性引用的对象private static User user = new User()</li><li>常量引用的对象(final)private static final  User user = new User()</li><li>本地方法栈中引用的对象(JNI)</li></ol></blockquote><ul><li>对象何时死亡如果遍历后对象不可达，也并非&quot;非死不可&quot;，会判断是否重写过``或者虚拟机执行过，没有则直接标记为可移除，没有则是另外一个流程详情请见上面 《finalize方法》小节参考:<a href="https://www.cnblogs.com/Smina/p/7189427.html" target="_blank" rel="noopener">对象回收时finalize的作用</a></li></ul><h2 id="三-常用垃圾收集器-jvm调优-调优工具">三 常用垃圾收集器, jvm调优, 调优工具</h2><h3 id="1-垃圾收集器-3类7种">(1) 垃圾收集器(3类7种)</h3><p>大致分为3大类共7种垃圾收集器<img src="http://pic1.zhimg.com/80/v2-55fdcd5fe54faa11542cceb3642c4dcc_hd.jpg" alt></p><h4 id="1-新生代收集器">1. 新生代收集器</h4><ul><li>Serial收集器（新生代单线程Client模式）</li></ul><blockquote><p><strong>Serial收集器是最基本、发展历史最悠久的单线程收集器</strong></p><ol><li>是单线程的收集器</li><li>它在进行垃圾收集时，必须暂停其他所有的工作线程</li><li>采用复制算法进行垃圾收集</li><li>Serial收集器依然是虚拟机运行在Client模式下默认新生代收集器</li></ol></blockquote><ul><li>ParNew收集器（新生代多线程Server模式）</li></ul><blockquote><p><strong>Serial收集器的多线程版本</strong>附加说明:</p><ol><li>ParNew 在单核 CPU 环境并不会比 Serial 收集器达到更好的效果</li><li>它默认开启的收集线程数和 CPU 数量一致, 可通过<code>-XX:ParallelGCThreads</code> 来设置垃圾收集的线程数</li></ol></blockquote><ul><li>Parallel Scavenge收集器（新生代并行回收）</li></ul><blockquote><p><strong>该收集器的目标是达到一个可控制的吞吐量</strong></p><ol><li>也是基于多线程的复制算法</li><li>提供两个参数用于精确控制吞吐量，分别是控制最大垃圾收起停顿时间的<code>-XX:MaxGCPauseMillis</code>，以及直接设置吞吐量大小的<code>-XX:GCTimeRatio</code></li><li>自适应调节策略 <code>-XX:+UseAdaptiveSizePolicy</code>，开启之后就无须设置如下3个参数:<code>-Xmn (新生代大小)</code>,<code>-XX:SurvivorRatio (Eden&amp;Survivor区的比例)</code>,<code>-XX:PretenureSizeThreshold (晋升老年代年龄)</code></li><li>和ParNew不太一样，ParNew追求的是尽可能缩短垃圾收集时用户线程的停顿时间，Parallel Scavenge的目标是达到一个可控制的吞吐量，可能单次回收时间还略高于ParNew</li></ol></blockquote><h4 id="2-老年代收集器">2. 老年代收集器</h4><ul><li>Serial Old 收集器（老年代单线程Client模式）</li></ul><blockquote><p>Serial收集器的老年代版本基于单线程，标记合并算法与 Parallel Scavenge 收集器搭配；作为 CMS 收集器的后备预案</p></blockquote><ul><li>Parallel Old 收集器（老年代多线程）</li></ul><blockquote><p>是Parallel Scavenge收集器的老年代版本使用 <code>-XX:+UseParallelOldGC</code> 来指定使用 Paralle Old 收集器dk7、jdk8 默认使用该收集器作为老年代收集器</p></blockquote><ul><li>CMS收集器（老年代 最短回收停顿时间）</li></ul><p>很适合B/S系统的服务端上</p><blockquote><p>老年代收集器唯一一个使用<code>标记-清除</code>算法的，所以有内存碎片</p><ol><li>以获取最短回收停顿时间为目标</li><li>分为4个步骤：<code>初始标记</code>: 标记一下 GC Roots 能直接关联到的对象，速度较快<code>并发标记</code>: 进行 GC Roots Tracing，标记出全部的垃圾对象，耗时较长<code>重新标记</code>: 修正并发标记阶段引用户程序继续运行而导致变化的对象的标记记录，耗时较短<code>并发清除</code>: 用标记-清除算法清除垃圾对象，耗时较长</li><li>耗时最长的并发标记和并发清除都是和用户线程一起工作，总体上来说，CMS收集器垃圾收集可以看做是和用户线程并发执行的</li></ol></blockquote><blockquote><p>缺点:</p><ol><li><code>对CPU资源敏感</code>：默认分配的垃圾收集线程数为(CPU 数+3)/4，随着 CPU 数量下降，占用 CPU 资源越多，吞吐量越小</li><li><code>无法处理浮动垃圾</code>： 在并发清理阶段，由于用户线程还在运行，还会不断产生新的垃圾，CMS当次无法清除；同时由于在垃圾收集阶段用户线程也在并发执行，CMS 收集器不能像其他收集器那样等老年代被填满时再进行收集，需要预留一部分空间提供用户线程运行使用。当 CMS 运行时，预留的内存空间无法满足用户线程的需要，就会出现 “ Concurrent Mode Failure ”的错误，这时将会启动后备预案，临时用 Serial Old 来重新进行老年代的垃圾收集。</li></ol></blockquote><ol start="3"><li><code>产生内存碎片</code>：基于标记-清除算法<code>XX:UserCMSCompactAtFullCollection</code>开启碎片整理（默认开启），在 CMS 进行 Full GC 之前，会进行内存碎片的整理<code>-XX:CMSFullGCsBeforeCompaction</code>设置执行多少次不压缩的 Full GC 之后，跟着来一次带压缩的 Full GC（默认0）<code>XX:+UserConMarkSweepGC</code> 选择 CMS 作为老年代收集器</li></ol><h4 id="3-堆内存垃圾收集器">3. 堆内存垃圾收集器</h4><ul><li>G1收集器</li></ul><p><font color="orange">G1 收集器是 jdk1.7 才正式引用的商用收集器，现在已经成为 jdk9 默认的收集器。前面几款收集器收集的范围都是新生代或者老年代，G1 进行垃圾收集的范围是整个堆内存，它采用 “ 化整为零 ” 的思路，把整个堆内存划分为多个大小相等的独立区域（Region），在 G1 收集器中还保留着新生代和老年代的概念，它们分别都是一部分 Region</font><img src="http://pic1.zhimg.com/80/v2-62d471e0ba563d1d10c53114488c47b8_hd.jpg" alt></p><p><font color="orange">每一个方块就是一个区域，每个区域可能是 Eden、Survivor、老年代，每种区域的数量也不一定。JVM 启动时会自动设置每个区域的大小（1M ~ 32M，必须是 2 的次幂），最多可以设置 2048 个区域（即支持的最大堆内存为 32M*2048 = 64G），假如设置 -Xmx8g -Xms8g，则每个区域大小为 8g/2048=4M</font></p><p>为了在 GC Roots Tracing 的时候避免扫描全堆，在每个 Region 中，都有一个 Remembered Set 来实时记录该区域内的引用类型数据与其他区域数据的引用关系（在前面的几款分代收集中，新生代、老年代中也有一个 Remembered Set 来实时记录与其他区域的引用关系），在标记时直接参考这些引用关系就可以知道这些对象是否应该被清除，而不用扫描全堆的数据。</p><p>G1 收集器可以 “ 建立可预测的停顿时间模型 ”，它维护了一个列表用于记录每个 Region 回收的价值大小（回收后获得的空间大小以及回收所需时间的经验值），这样可以保证 G1 收集器在有限的时间内可以获得最大的回收效率。</p><blockquote><p>初始标记并发标记最终标记筛选回收</p></blockquote><h3 id="2-jvm参数调优">(2) JVM参数调优</h3><h4 id="垃圾收集器相关jvm参数">垃圾收集器相关jvm参数</h4><blockquote><p>-XX:+UseSerialGC：在新生代和老年代使用串行收集器-XX:+UseParNewGC：在新生代使用并行收集器-XX:+UseParallelGC ：新生代使用并行回收收集器，更加关注吞吐量-XX:+UseParallelOldGC：老年代使用并行回收收集器-XX:ParallelGCThreads：设置用于垃圾回收的线程数-XX:+UseConcMarkSweepGC：新生代使用并行收集器，老年代使用CMS+串行收集器-XX:ParallelCMSThreads：设定CMS的线程数量-XX:+UseG1GC：启用G1垃圾回收器</p></blockquote><h3 id="3-调优工具的使用">(3) 调优工具的使用</h3><h4 id="1-jvm调优-监控和故障处理-命令-6个">1. jvm调优(监控和故障处理)命令(6个)</h4><table><thead><tr><th style="text-align:center">- 命令</th><th style="text-align:left">- 作用</th></tr></thead><tbody><tr><td style="text-align:center"><strong><code>jstat</code></strong></td><td style="text-align:left"><font color="orange">监视虚拟机运行时状态信息(类装载、内存、垃圾收集、JIT编译等运行数据)</font></td></tr><tr><td style="text-align:center"><strong><code>jps</code></strong></td><td style="text-align:left"><font color="orange">显示指定系统内所有的HotSpot虚拟机进程</font></td></tr><tr><td style="text-align:center"><strong><code>jmap</code></strong></td><td style="text-align:left"><font color="orange">内存映射工具, 用于生成heap dump文件</font></td></tr><tr><td style="text-align:center"><strong><code>jhat</code></strong></td><td style="text-align:left"><font color="orange">与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看; 注意，一般不会直接在服务器上进行分析，因为jhat是一个耗时并且耗费硬件资源的过程，一般把服务器生成的dump文件复制到本地或其他机器上进行分析</font></td></tr><tr><td style="text-align:center"><strong><code>jstack</code></strong></td><td style="text-align:left"><font color="orange">生成java虚拟机当前时刻的线程快照; 目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等</font></td></tr><tr><td style="text-align:center"><strong><code>jinfo</code></strong></td><td style="text-align:left"><font color="orange">实时查看和调整虚拟机运行参数</font></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看gc情况 1000表示1秒展示一次, 10表示最多展示10次</span></span><br><span class="line">jstat -gc pid <span class="number">1000</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JVM在性能优化时是必备知识点, 则必须知道JVM内存的结构, 如何GC回收, 如何使用工具和参数来实现调优;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;JVM内存结构&lt;/strong&gt;
&lt;strong&gt;GC回收机制与算法&lt;/strong&gt;
&lt;strong&gt;垃
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JVM调优详解</title>
    <link href="https://doooyo.github.io/2019/04/22/JVM%E8%B0%83%E4%BC%98%E8%AF%A6%E8%A7%A3/"/>
    <id>https://doooyo.github.io/2019/04/22/JVM调优详解/</id>
    <published>2019-04-21T16:32:29.225Z</published>
    <updated>2019-04-21T16:32:29.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-jvm调优-监控和故障处理-6个命令">一 jvm调优(监控和故障处理)6个命令</h2><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:center"><strong><code>jstat</code></strong></td><td style="text-align:left"><font color="orange">监视虚拟机运行时状态信息(类装载、内存、垃圾收集、JIT编译等运行数据)</font></td></tr><tr><td style="text-align:center"><strong><code>jps</code></strong></td><td style="text-align:left"><font color="orange">显示指定系统内所有的HotSpot虚拟机进程</font></td></tr><tr><td style="text-align:center"><strong><code>jmap</code></strong></td><td style="text-align:left"><font color="orange">内存映射工具, 用于生成heap dump文件</font></td></tr><tr><td style="text-align:center"><strong><code>jhat</code></strong></td><td style="text-align:left"><font color="orange">与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看; 注意，一般不会直接在服务器上进行分析，因为jhat是一个耗时并且耗费硬件资源的过程，一般把服务器生成的dump文件复制到本地或其他机器上进行分析</font></td></tr><tr><td style="text-align:center"><strong><code>jstack</code></strong></td><td style="text-align:left"><font color="orange">生成java虚拟机当前时刻的线程快照; 目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等</font></td></tr><tr><td style="text-align:center"><strong><code>jinfo</code></strong></td><td style="text-align:left"><font color="orange">实时查看和调整虚拟机运行参数</font></td></tr></tbody></table><h3 id="1-jps">1. jps</h3><p><font color="red">查看主机所有运行的HotSpot进程</font></p><blockquote><p><code>-l</code> 输出主类全名或jar路径<code>-m</code> 输出JVM启动时传递给main()的参数<code>-v</code> 输出JVM启动时显示指定的JVM参数（注意只是显式指定的参数）<code>-q</code> 只输出进程pid</p></blockquote><p>示例如下：<code>pid | 主类全名 | 传递给主类的参数</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ jps -l -m</span><br><span class="line">---------</span><br><span class="line"><span class="number">469</span> org.apache.zookeeper.server.quorum.QuorumPeerMain /usr/local/etc/zookeeper/zoo.cfg</span><br><span class="line"><span class="number">79751</span> sun.tools.jps.Jps -l -m</span><br><span class="line"><span class="number">79244</span> org.jetbrains.idea.maven.server.RemoteMavenServer</span><br><span class="line"><span class="number">79742</span> whayer.cloud.imageanalysis.service.rest.userauthorization-<span class="number">0.0</span>.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><h3 id="2-jstat">2. jstat</h3><p><font color="red">用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据</font></p><table><thead><tr><th style="text-align:center">- 选项</th><th style="text-align:left">- 作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>-class</code></td><td style="text-align:left">监视类装载卸载数量，总空间以及类装载所耗时</td></tr><tr><td style="text-align:center"><code>-gc</code></td><td style="text-align:left">监视java堆情况，Eden，两个Survivor，老年代，永久代，已用空间，GC时间合计等等信息</td></tr><tr><td style="text-align:center"><code>-gccapacity</code></td><td style="text-align:left">基本同<code>-gc</code>，主要关注堆各个区域使用最大最小空间</td></tr><tr><td style="text-align:center"><code>-gcutil</code></td><td style="text-align:left">基本同<code>-gc</code>，主要关注已使用空间占总空间百分比</td></tr><tr><td style="text-align:center"><code>-gccause</code></td><td style="text-align:left">同<code>-gcutil</code>，会额外输出导致上次GC的原因</td></tr><tr><td style="text-align:center"><code>-gcnew</code></td><td style="text-align:left">监视新生代GC状况</td></tr><tr><td style="text-align:center"><code>-gcnewcapacity</code></td><td style="text-align:left">基本同<code>-gcnew</code>，主要关注新生代使用到的最大最小空间</td></tr><tr><td style="text-align:center"><code>-gcold</code></td><td style="text-align:left">监视老年代GC状况</td></tr><tr><td style="text-align:center"><code>-gcoldcapacity</code></td><td style="text-align:left">基本同<code>-gcold</code>，主要关注老年代使用到的最大最小空间</td></tr><tr><td style="text-align:center"><code>-gcpermcapacity</code></td><td style="text-align:left">输出永久代 (方法区)使用到的最大最小空间</td></tr><tr><td style="text-align:center"><code>-compiler</code></td><td style="text-align:left">输出JIT编译器编译过的方法，耗时等信息</td></tr><tr><td style="text-align:center"><code>-printcomplilation</code></td><td style="text-align:left">输出已经被JIT编译过的方法</td></tr></tbody></table><p>示例1: 查看Idea类加载情况</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -<span class="class"><span class="keyword">class</span> 79245</span></span><br><span class="line"><span class="class">------------------</span></span><br><span class="line"><span class="class"><span class="title">Loaded</span>  <span class="title">Bytes</span>   <span class="title">Unloaded</span>  <span class="title">Bytes</span>     <span class="title">Time</span></span></span><br><span class="line"><span class="class">  3272  6178.4  0         0.0       6.15</span></span><br><span class="line"><span class="class"></span></span><br><span class="line">Loaded: 加载class的数量</span><br><span class="line">Bytes: <span class="class"><span class="keyword">class</span>字节大小</span></span><br><span class="line">Unloaded: 未加载class的数量</span><br><span class="line">Bytes: 未加载<span class="class"><span class="keyword">class</span>的字节大小</span></span><br><span class="line">Time: 加载时间</span><br></pre></td></tr></table></figure><p>示例2: 下面查看Idea编辑器的虚拟机堆状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看gc情况 1000表示1秒展示一次, 10表示最多展示10次</span></span><br><span class="line">$ jstat -gc pid <span class="number">1000</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line"><span class="number">5120.0</span> <span class="number">5120.0</span> <span class="number">3552.0</span>  <span class="number">0.0</span>   <span class="number">33280.0</span>  <span class="number">25220.3</span>   <span class="number">87552.0</span>      <span class="number">88.0</span>    <span class="number">17280.0</span> <span class="number">16788.2</span> <span class="number">2176.0</span> <span class="number">2050.5</span>      <span class="number">2</span>    <span class="number">0.047</span>   <span class="number">0</span>      <span class="number">0.000</span>    <span class="number">0.047</span></span><br><span class="line"></span><br><span class="line">S0C: survivor0区的总容量</span><br><span class="line">S1C: survivor1区的总容量</span><br><span class="line">S0U: survivor0区已使用的容量</span><br><span class="line">S1U: survivor1区已使用的容量</span><br><span class="line">EC: Eden区的总容量</span><br><span class="line">EU: Eden区已使用的容量</span><br><span class="line">OC: Old区的总容量</span><br><span class="line">OU: Old区已使用的容量</span><br><span class="line">PC:当前perm的容量 (KB)</span><br><span class="line">PU:perm的已使用 (KB)</span><br><span class="line">YGC: 新生代垃圾回收次数</span><br><span class="line">YGCT: 新生代垃圾回收时间</span><br><span class="line">FGC: 老年代垃圾回收次数</span><br><span class="line">FGCT: 老年代垃圾回收时间</span><br><span class="line">GCT: 垃圾回收总消耗时间</span><br></pre></td></tr></table></figure><h3 id="3-jmap">3. jmap</h3><p><font color="red">生成堆转储快照</font></p><table><thead><tr><th style="text-align:center">- 选项</th><th style="text-align:left">- 作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>-heap</code></td><td style="text-align:left">看整体堆信息</td></tr><tr><td style="text-align:center"><code>-histo</code></td><td style="text-align:left">看所有对象所占内存情况和对象数量</td></tr><tr><td style="text-align:center"><code>-dump:live,format=b,file=dump.hprof</code></td><td style="text-align:left">导出内存使用详细情况到dump.hprof文件（生成堆转储快照），format指定输出格式，live指明是活着的对象，file指定文件名，<code>hprof</code>后缀指明可以直接用MAT(Memory Anlysis Tool)打开</td></tr><tr><td style="text-align:center"><code>-finalizerinfo</code></td><td style="text-align:left">显示在F-Queue队列等待Finalizer线程执行finalizer方法的对象（打印等待回收对象的信息）；或者<code>-XX:+HeapDumpOnOutOfMemoryError</code>参数来让虚拟机出现OOM的时候·自动生成dump文件</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看整体堆信息</span></span><br><span class="line">$ jmap -heap pid</span><br><span class="line">---------------</span><br><span class="line">  Attaching to process ID <span class="number">28920</span>, please wait...</span><br><span class="line">  Debugger attached successfully.</span><br><span class="line">  Server compiler detected.</span><br><span class="line">  JVM version is <span class="number">24.71</span>-b01</span><br><span class="line"></span><br><span class="line">  using thread-local object allocation.</span><br><span class="line">  Parallel GC with <span class="number">4</span> thread(s)<span class="comment">//GC 方式</span></span><br><span class="line"></span><br><span class="line">  Heap Configuration: <span class="comment">//堆内存初始化配置</span></span><br><span class="line">     MinHeapFreeRatio = <span class="number">0</span> <span class="comment">//对应jvm启动参数-XX:MinHeapFreeRatio设置JVM堆最小空闲比率(default 40)</span></span><br><span class="line">     MaxHeapFreeRatio = <span class="number">100</span> <span class="comment">//对应jvm启动参数 -XX:MaxHeapFreeRatio设置JVM堆最大空闲比率(default 70)</span></span><br><span class="line">     MaxHeapSize      = <span class="number">2082471936</span> (<span class="number">1986.0</span>MB) <span class="comment">//对应jvm启动参数-XX:MaxHeapSize=设置JVM堆的最大大小</span></span><br><span class="line">     NewSize          = <span class="number">1310720</span> (<span class="number">1.25</span>MB)<span class="comment">//对应jvm启动参数-XX:NewSize=设置JVM堆的‘新生代’的默认大小</span></span><br><span class="line">     MaxNewSize       = <span class="number">17592186044415</span> MB<span class="comment">//对应jvm启动参数-XX:MaxNewSize=设置JVM堆的‘新生代’的最大大小</span></span><br><span class="line">     OldSize          = <span class="number">5439488</span> (<span class="number">5.1875</span>MB)<span class="comment">//对应jvm启动参数-XX:OldSize=&lt;value&gt;:设置JVM堆的‘老生代’的大小</span></span><br><span class="line">     NewRatio         = <span class="number">2</span> <span class="comment">//对应jvm启动参数-XX:NewRatio=:‘新生代’和‘老生代’的大小比率</span></span><br><span class="line">     SurvivorRatio    = <span class="number">8</span> <span class="comment">//对应jvm启动参数-XX:SurvivorRatio=设置年轻代中Eden区与Survivor区的大小比值</span></span><br><span class="line">     PermSize         = <span class="number">21757952</span> (<span class="number">20.75</span>MB)  <span class="comment">//对应jvm启动参数-XX:PermSize=&lt;value&gt;:设置JVM堆的‘永生代’的初始大小</span></span><br><span class="line">     MaxPermSize      = <span class="number">85983232</span> (<span class="number">82.0</span>MB)<span class="comment">//对应jvm启动参数-XX:MaxPermSize=&lt;value&gt;:设置JVM堆的‘永生代’的最大大小</span></span><br><span class="line">     G1HeapRegionSize = <span class="number">0</span> (<span class="number">0.0</span>MB)</span><br><span class="line"></span><br><span class="line">  Heap Usage:<span class="comment">//堆内存使用情况</span></span><br><span class="line">  PS Young Generation</span><br><span class="line">  Eden Space:<span class="comment">//Eden区内存分布</span></span><br><span class="line">     capacity = <span class="number">33030144</span> (<span class="number">31.5</span>MB)<span class="comment">//Eden区总容量</span></span><br><span class="line">     used     = <span class="number">1524040</span> (<span class="number">1.4534378051757812</span>MB)  <span class="comment">//Eden区已使用</span></span><br><span class="line">     free     = <span class="number">31506104</span> (<span class="number">30.04656219482422</span>MB)  <span class="comment">//Eden区剩余容量</span></span><br><span class="line">     <span class="number">4.614088270399305</span>% used <span class="comment">//Eden区使用比率</span></span><br><span class="line">  From Space:  <span class="comment">//其中一个Survivor区的内存分布</span></span><br><span class="line">     capacity = <span class="number">5242880</span> (<span class="number">5.0</span>MB)</span><br><span class="line">     used     = <span class="number">0</span> (<span class="number">0.0</span>MB)</span><br><span class="line">     free     = <span class="number">5242880</span> (<span class="number">5.0</span>MB)</span><br><span class="line">     <span class="number">0.0</span>% used</span><br><span class="line">  To Space:  <span class="comment">//另一个Survivor区的内存分布</span></span><br><span class="line">     capacity = <span class="number">5242880</span> (<span class="number">5.0</span>MB)</span><br><span class="line">     used     = <span class="number">0</span> (<span class="number">0.0</span>MB)</span><br><span class="line">     free     = <span class="number">5242880</span> (<span class="number">5.0</span>MB)</span><br><span class="line">     <span class="number">0.0</span>% used</span><br><span class="line">  PS Old Generation <span class="comment">//当前的Old区内存分布</span></span><br><span class="line">     capacity = <span class="number">86507520</span> (<span class="number">82.5</span>MB)</span><br><span class="line">     used     = <span class="number">0</span> (<span class="number">0.0</span>MB)</span><br><span class="line">     free     = <span class="number">86507520</span> (<span class="number">82.5</span>MB)</span><br><span class="line">     <span class="number">0.0</span>% used</span><br><span class="line">  PS Perm Generation<span class="comment">//当前的 “永生代” 内存分布</span></span><br><span class="line">     capacity = <span class="number">22020096</span> (<span class="number">21.0</span>MB)</span><br><span class="line">     used     = <span class="number">2496528</span> (<span class="number">2.3808746337890625</span>MB)</span><br><span class="line">     free     = <span class="number">19523568</span> (<span class="number">18.619125366210938</span>MB)</span><br><span class="line">     <span class="number">11.337498256138392</span>% used</span><br><span class="line"></span><br><span class="line">  <span class="number">670</span> interned Strings occupying <span class="number">43720</span> bytes.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印堆的对象统计，包括对象数、内存大小等等</span></span><br><span class="line">$ jmap -histo:live <span class="number">28920</span> | more</span><br><span class="line"></span><br><span class="line"> num     #instances         #bytes  class name</span><br><span class="line">----------------------------------------------</span><br><span class="line">   <span class="number">1</span>:           <span class="number">965</span>       <span class="number">17539080</span>  [B</span><br><span class="line">   <span class="number">2</span>:         <span class="number">10436</span>         <span class="number">941096</span>  [C</span><br><span class="line">   <span class="number">3</span>:          <span class="number">3519</span>         <span class="number">393384</span>  java.lang.Class</span><br><span class="line">   <span class="number">4</span>:          <span class="number">3122</span>         <span class="number">320104</span>  [Ljava.lang.Object;</span><br><span class="line">   <span class="number">5</span>:         <span class="number">10371</span>         <span class="number">248904</span>  java.lang.String</span><br><span class="line">   <span class="number">6</span>:          <span class="number">6922</span>         <span class="number">221504</span>  java.util.concurrent.ConcurrentHashMap$Node</span><br><span class="line">   <span class="number">7</span>:          <span class="number">6500</span>         <span class="number">104000</span>  java.lang.Object</span><br><span class="line">   <span class="number">8</span>:            <span class="number">41</span>          <span class="number">56496</span>  [Ljava.util.concurrent.ConcurrentHashMap$Node;</span><br><span class="line">   <span class="number">9</span>:          <span class="number">1375</span>          <span class="number">55528</span>  [I</span><br><span class="line">  <span class="number">10</span>:          <span class="number">1513</span>          <span class="number">48416</span>  java.util.HashMap$Node</span><br><span class="line"></span><br><span class="line"><span class="comment">// [B 表示 byte</span></span><br><span class="line"><span class="comment">// [C 表示 char</span></span><br><span class="line"><span class="comment">// [D 表示 double</span></span><br><span class="line"><span class="comment">// [F 表示 float</span></span><br><span class="line"><span class="comment">// [I 表示 int</span></span><br><span class="line"><span class="comment">// [J 表示 long</span></span><br><span class="line"><span class="comment">// [Z 表示 boolean</span></span><br><span class="line"><span class="comment">// [L+类名 表示自定义对象</span></span><br></pre></td></tr></table></figure><h3 id="4-jhat">4. jhat</h3><p><font color="red">与jmap搭配使用，用来分析jmap生成的dump，自带微型Http服务器用网页来展示，注意不要在生产环境使用此命令，是一个耗时且耗资源的过程，一般使用<code>jmap -dump</code> 来生成dump文件导出来分析</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -J: jhat是会单独启动一个JVM来执行, 可以指定jvm堆大小来分析一个很大的dump文件</span></span><br><span class="line">$ jhat -J-Xmx512m dump.hprof</span><br><span class="line"></span><br><span class="line">  eading from dump.hprof...</span><br><span class="line">  Dump file created Fri Mar <span class="number">11</span> <span class="number">17</span>:<span class="number">13</span>:<span class="number">42</span> CST <span class="number">2016</span></span><br><span class="line">  Snapshot read, resolving...</span><br><span class="line">  Resolving <span class="number">271678</span> objects...</span><br><span class="line">  Chasing references, expect <span class="number">54</span> dots......................................................</span><br><span class="line">  Eliminating duplicate references......................................................</span><br><span class="line">  Snapshot resolved.</span><br><span class="line">  Started HTTP server on port <span class="number">7000</span></span><br><span class="line">  Server is ready.</span><br></pre></td></tr></table></figure><p>具体请查阅 <a href="https://zhuanlan.zhihu.com/p/59411254" target="_blank" rel="noopener">jvm系列(四)jvm调优 命令</a></p><h3 id="5-jstack">5. jstack</h3><p><font color="red">用于生成java虚拟机当前时刻的线程快照，用于定位线程长时间停顿 (挂起)的原因，比如死锁，hang；可以检查到线程在什么状态</font></p><table><thead><tr><th style="text-align:center">- 选项</th><th style="text-align:left">- 作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>-F</code></td><td style="text-align:left">当正常输出请求不被响应时，强制输出线程堆栈</td></tr><tr><td style="text-align:center"><code>-m</code></td><td style="text-align:left">如果调用到本地方法的话，可以显示C/C++的堆栈</td></tr><tr><td style="text-align:center"><code>-l</code></td><td style="text-align:left">除堆栈外，显示关于锁的附加信息</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看QuorumPeerMain (Zookeeper)的线程快照</span></span><br><span class="line"><span class="comment">// 可以看到2个线程处于WAITING,一个线程处于TIMED_WAITING</span></span><br><span class="line">$ jstack -l <span class="number">469</span>|more</span><br><span class="line"></span><br><span class="line">"Attach Listener" #15 daemon prio=9 os_prio=31 tid=0x00007febe98cd800 nid=0x1047 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">        - None</span><br><span class="line"></span><br><span class="line">"ProcessThread(sid:0 cport:2181):" #14 prio=5 os_prio=31 tid=0x00007febe911e000 nid=0x4203 waiting on condition [0x000070000a561000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">        at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">        - parking to wait <span class="keyword">for</span>  &lt;<span class="number">0x0000000797b00190</span>&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:<span class="number">175</span>)</span><br><span class="line">        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:<span class="number">2039</span>)</span><br><span class="line">        at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:<span class="number">442</span>)</span><br><span class="line">        at org.apache.zookeeper.server.PrepRequestProcessor.run(PrepRequestProcessor.java:<span class="number">122</span>)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">        - None</span><br><span class="line"></span><br><span class="line">"SyncThread:0" #13 prio=5 os_prio=31 tid=0x00007febe98c0000 nid=0x4303 waiting on condition [0x000070000a45e000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">        at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">        - parking to wait <span class="keyword">for</span>  &lt;<span class="number">0x0000000797b10758</span>&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:<span class="number">175</span>)</span><br><span class="line">        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:<span class="number">2039</span>)</span><br><span class="line">        at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:<span class="number">442</span>)</span><br><span class="line">        at org.apache.zookeeper.server.SyncRequestProcessor.run(SyncRequestProcessor.java:<span class="number">127</span>)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">        - None</span><br><span class="line"></span><br><span class="line">"SessionTracker" #12 prio=5 os_prio=31 tid=0x00007febea15a000 nid=0x4003 in Object.wait() [0x000070000a35b000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        at org.apache.zookeeper.server.SessionTrackerImpl.run(SessionTrackerImpl.java:<span class="number">146</span>)</span><br><span class="line">        - locked &lt;<span class="number">0x0000000797b08700</span>&gt; (a org.apache.zookeeper.server.SessionTrackerImpl)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">        - None</span><br></pre></td></tr></table></figure><h3 id="6-jinfo">6. jinfo</h3><p><font color="orange">实时查看和调整虚拟机运行参数，<code>jps -v</code>只能查看到显式指定的参数，jinfo则能查看未被显式指定的参数的值</font>看一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看zookeeper的启动参数</span></span><br><span class="line">$ jinfo -flags <span class="number">469</span></span><br><span class="line"></span><br><span class="line">Non-<span class="keyword">default</span> VM flags: -XX:CICompilerCount=<span class="number">3</span> -XX:InitialHeapSize=<span class="number">134217728</span> -XX:+ManagementServer -XX:MaxHeapSize=<span class="number">2147483648</span> -XX:MaxNewSize=<span class="number">715653120</span> -XX:MinHeapDeltaBytes=<span class="number">524288</span> -XX:NewSize=<span class="number">44564480</span> -XX:OldSize=<span class="number">89653248</span> -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:+UseParallelGC</span><br><span class="line">Command line:  -Dzookeeper.log.dir=. -Dzookeeper.root.logger=INFO,CONSOLE -Dapple.awt.UIElement=<span class="keyword">true</span> -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.local.only=<span class="keyword">false</span></span><br></pre></td></tr></table></figure><p>查阅资料<a href="https://zhuanlan.zhihu.com/p/59411254" target="_blank" rel="noopener">jvm系列(四)jvm调优命令（jps jstat jmap jhat jstack jinfo）</a></p><h2 id="二-jvm调优可视化集成工具">二 jvm调优可视化集成工具</h2><h3 id="1-jconsole">1. jconsole</h3><p><font color="orange">Jconsole是JDK自带的监控工具，在JDK/bin目录下可以找到。它用于连接正在运行的本地或者远程的JVM，对运行在java应用程序的资源消耗和性能进行监控，并画出大量的图表，提供强大的可视化界面。而且本身占用的服务器内存很小，甚至可以说几乎不消耗</font></p><blockquote><ol><li>打开的两种方式命令行直接输入jconsoleGUI shell (jdk\bin下打开)中运行</li><li>java程序停止后，jconsole重连需要从外部重连，因为pid已经变化</li><li>基本是上述6个命令的集合，能根据实时图表方式查看<code>内存</code>,<code>线程</code>,<code>类</code>,<code>MBean</code>,<code>VM虚拟机概要</code>，比visualVM功能稍微弱一些，因为无法查看回收次数等详细信息</li><li>可追踪内存溢出 (配合jstat)，线程死锁 (jstack也可以)</li><li>jconsole本身占用资源少</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命令行启动</span></span><br><span class="line">$ jconsole</span><br></pre></td></tr></table></figure><ul><li>远程监控tomcat</li></ul><p>远程连接需要配置远程的java进程启动jvm参数，主要是rmi的远程调用消息通信请参考: <a href="http://www.cnblogs.com/kongzhongqijing/articles/3621441.html" target="_blank" rel="noopener">JConsole远程连接配置</a></p><h3 id="2-visualvm">2. visualVM</h3><p>jconsole是1.5提供的，visualVM是1.6提供的，jconsole相当于是visualVM的子集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命令行即可启动</span></span><br><span class="line">$ jvisualvm</span><br></pre></td></tr></table></figure><h2 id="三-jvm调优参数">三 jvm调优参数</h2><p>待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-jvm调优-监控和故障处理-6个命令&quot;&gt;一 jvm调优(监控和故障处理)6个命令&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;命令&lt;/th&gt;
&lt;th style=&quot;text-align:lef
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>FastDFS Linux 单节点安装</title>
    <link href="https://doooyo.github.io/2019/04/22/FastDFS%20Linux%20%E5%8D%95%E8%8A%82%E7%82%B9%E5%AE%89%E8%A3%85/"/>
    <id>https://doooyo.github.io/2019/04/22/FastDFS Linux 单节点安装/</id>
    <published>2019-04-21T16:31:51.686Z</published>
    <updated>2019-04-21T16:31:51.687Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>备注: mac安装由于SIP(System Integrity Protection, 系统完整性保护功能), 无法在/usr/目录下创建文件, 所以需要关闭SIP</p><ul><li>重启 Mac, 按住 Command + R, 进入 recovery 模式</li><li>选择打开 Utilities下的终端, 输入 csrutil disable 并回车</li><li>重启 Mac 即可</li></ul></blockquote><h3 id="1-准备">1.准备</h3><ul><li>libfastcommon: 从 FastDFS和FastDHT中提取出来的公共C 函数库，基础环境<a href="https://github.com/happyfish100/libfastcommon.git" target="_blank" rel="noopener">https://github.com/happyfish100/libfastcommon.git</a></li><li>fastdfs: 主程序<a href="https://github.com/happyfish100/fastdfs.git" target="_blank" rel="noopener">https://github.com/happyfish100/fastdfs.git</a></li><li>fastdfs-nginx-module: nginx扩展支持模块<a href="https://github.com/happyfish100/fastdfs-nginx-module.git" target="_blank" rel="noopener">https://github.com/happyfish100/fastdfs-nginx-module.git</a></li></ul><h3 id="2-编译安装">2.编译安装</h3><ul><li>libfastcommon安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yum -y install libevent</span><br><span class="line"><span class="meta">#</span> 首先安装libfastcommon，是一些公共库函数</span><br><span class="line">./make</span><br><span class="line">./make install</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> uname查看linux系统 Centos为Linux</span><br><span class="line"><span class="meta">#</span> 会将库函数安装进/usr/lib64，需要将libfastcommon.so 拷贝到/usr/lib; 最新版本已经拷贝到/usr/lib并软链到/usr/lib64</span><br><span class="line">cd /usr/lib64</span><br><span class="line">cp libfastcommon.so /usr/lib</span><br></pre></td></tr></table></figure><ul><li>fastdfs安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 1.安装</span><br><span class="line">./make</span><br><span class="line">./make install</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 会安装在/usr/bin目录下</span><br><span class="line">cd /usr/bin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查看可执行文件</span><br><span class="line">ll fdfs*</span><br><span class="line"><span class="meta">#</span>fdfs_append_file</span><br><span class="line"><span class="meta">#</span>fdfs_appender_test</span><br><span class="line"><span class="meta">#</span>fdfs_appender_test1</span><br><span class="line"><span class="meta">#</span>fdfs_crc32</span><br><span class="line"><span class="meta">#</span>fdfs_delete_file</span><br><span class="line"><span class="meta">#</span>fdfs_download_file</span><br><span class="line"><span class="meta">#</span>fdfs_file_info</span><br><span class="line"><span class="meta">#</span>fdfs_monitor</span><br><span class="line"><span class="meta">#</span>fdfs_storaged</span><br><span class="line"><span class="meta">#</span>fdfs_test</span><br><span class="line"><span class="meta">#</span>fdfs_test1</span><br><span class="line"><span class="meta">#</span>fdfs_trackerd</span><br><span class="line"><span class="meta">#</span>fdfs_upload_appender</span><br><span class="line"><span class="meta">#</span>fdfs_upload_file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 生成的配置文件在/etc/fdfs</span><br><span class="line">cd /etc/fdfs</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 2.将fastdfs源码目录下的conf里的配置文件拷贝到/etc/fdfs</span><br><span class="line">cp -r /home/fastdfs/fastdfs-5.11/conf/* /etc/fdfs/</span><br></pre></td></tr></table></figure><h3 id="3-修改-etc-fdfs配置文件">3.修改/etc/fdfs配置文件</h3><ul><li>修改 tracker.conf</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> tracker 服务端口</span><br><span class="line">  port=22122 ####注意开放tracker的22122端口</span><br><span class="line"><span class="meta">#</span> base_path 数据及日志存储路径</span><br><span class="line"><span class="meta">#</span> /fastdfs/tracker，/fastdfs/storage，/fastdfs/client</span><br><span class="line">  base_path=/fastdfs/tracker</span><br></pre></td></tr></table></figure><ul><li>修改 storage.conf</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> storage 服务端口</span><br><span class="line">port=23000 ####注意开放storage的23000端口</span><br><span class="line"><span class="meta">#</span> base_path 数据及日志存储路径</span><br><span class="line">base_path=/fastdfs/storage</span><br><span class="line"><span class="meta">#</span> group_name 逻辑分组名</span><br><span class="line">group_name=doyo</span><br><span class="line"><span class="meta">#</span> store_path0 实际存放文件路径</span><br><span class="line">store_path0=/fastdfs/storage</span><br><span class="line"><span class="meta">#</span> tracker_server tracker服务地址</span><br><span class="line">tracker_server=&#123;本机公网地址&#125;:22122 ####注意此处必须是公网地址（教程上说必须是内网地址，但实际部署是公网地址也能访问，只是需要开放相应端口）</span><br></pre></td></tr></table></figure><ul><li>修改 client.conf</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> base_path 数据及日志存储路径</span><br><span class="line">base_path=/fastdfs/client</span><br><span class="line"><span class="meta">#</span> tracker_server tracker服务地址</span><br><span class="line">tracker_server=&#123;本机公网地址/内网地址&#125;:22122</span><br></pre></td></tr></table></figure><h3 id="4-启动tracker和storage">4.启动tracker和storage</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 1. 启动tracker服务，指定配置文件</span><br><span class="line">/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf</span><br><span class="line"><span class="meta">#</span> 重启</span><br><span class="line">/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 2. 启动storage服务，指定配置文件</span><br><span class="line">/usr/bin/fdfs_storaged /etc/fdfs/storage.conf</span><br><span class="line"><span class="meta">#</span> 重启</span><br><span class="line">/usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 3. 查看是否启动成功</span><br><span class="line">ps aux|grep tracker</span><br><span class="line">ps aux|grep storage</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 4. 测试上传文件</span><br><span class="line">/usr/bin/fdfs_test /etc/fdfs/client.conf upload &#123;文件路径&#125;</span><br><span class="line"><span class="meta">#</span> 得到上传地址 http://172.31.248.16/doyo/M00/00/00/rB_4EFwjukSAIVoiAAAIiUi81wg307_big.svg</span><br><span class="line"><span class="meta">#</span> 查看/fastdfs/storage，发现会有2层目录，每层256个，一共65536个文件夹；第三版避免小文件占用大量inode，采用合并小文件方式解决，但删除文件后不能compact，但可重新利用空间</span><br></pre></td></tr></table></figure><h3 id="5-添加nginx扩展模块">5.添加nginx扩展模块</h3><ul><li>修改src/config配置(nginx编译会用到)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 主要是将/usr/local/include 改为 /usr/include/fastdfs /usr/include/fastcommon/</span><br><span class="line"><span class="meta">#</span> 低版本改为/usr/include就可以了，但是高版本会在编译nginx的时候报 【common_define.h：没有那个文件或目录】</span><br></pre></td></tr></table></figure><ul><li>拷贝fastdfs-nginx-module扩展模块下的mod_fastdfs.conf到/etc/fdfs目录，并修改</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 拷贝</span><br><span class="line">cp src/mod_fastdfs.conf /etc/fdfs</span><br><span class="line"><span class="meta">#</span> 修改内容</span><br><span class="line">base_path=/fastdfs/tmp</span><br><span class="line">tracker_server=&#123;本机公网地址/内网地址&#125;:22122 #mod——fastdfs.conf 的tracker_server必须是内网地址</span><br><span class="line">group_name=doyo #分组</span><br><span class="line">url_have_group_name = true #url加上doyo分组前缀</span><br><span class="line">store_path0=/fastdfs/storage #必须和/etc/fdfs/storage.conf中配置的一样</span><br></pre></td></tr></table></figure><h3 id="6-安装与配置nginx">6.安装与配置nginx</h3><ul><li>安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 1.安装nginx的依赖包</span><br><span class="line">yum -y install gcc automake autoconf libtool make # 安装make</span><br><span class="line">yum install -y gcc-c++ # c与c++编译器</span><br><span class="line">yum install -y pcre pcre-devel # 正则表达式库</span><br><span class="line">yum install -y zlib zlib-devel # 数据压缩函数库</span><br><span class="line">yum install -y openssl openssl-devel # 是实现了SSL的工具集，一般用于加密通信；HTTPS=HTTP+TLS</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 2. ./config</span><br><span class="line">./configure \</span><br><span class="line">--prefix=/usr/local/nginx \</span><br><span class="line">--add-module=/home/fastdfs/fastdfs-nginx-module-1.20/src \</span><br><span class="line">--with-http_stub_status_module \</span><br><span class="line">--with-http_gzip_static_module \</span><br><span class="line">--with-http_ssl_module</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 3. 编译与安装</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 4. 配置nginx.conf</span><br><span class="line">server &#123;</span><br><span class="line">    listen 88; #80端口给其他网站使用</span><br><span class="line">    server_name localhost;</span><br><span class="line">    location /doyo/M00 &#123;</span><br><span class="line">        ngx_fastdfs_module; # fastdfs模块</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 5. 测试nginx配置并启动/重启</span><br><span class="line">cd sbin/ #进入可执行文件目录</span><br><span class="line">./nginx -t #检测配置是否正确</span><br><span class="line">./nginx -c /usr/local/nginx/conf/nginx.conf #指定配置文件启动</span><br><span class="line">./nginx -s reload #重启</span><br><span class="line">./nginx -s stop #快速停止</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>########## 注意 ##########</span><br><span class="line">如果之前通过yum安装了nginx，会全局注册nginx命令，所以启动nginx时需要到/usr/local/nginx/sbin目录下执行「./nginx」</span><br><span class="line"><span class="meta">#</span>##########################</span><br></pre></td></tr></table></figure><p>###7. 全部重启(由于添加了fastdfs-nginx扩展模块)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 重启tracker</span><br><span class="line">/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart</span><br><span class="line"><span class="meta">#</span> 重启storage</span><br><span class="line">/usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart</span><br><span class="line"><span class="meta">#</span> 重启nginx</span><br><span class="line">/usr/local/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure><p>###8.部署</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 配置nginx反向代理</span><br><span class="line"></span><br><span class="line">upstream servers &#123;</span><br><span class="line">    server 47.244.137.61:8088;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log logs/host.access.log main;</span><br><span class="line"></span><br><span class="line">        # 博客地址已经占用80端口</span><br><span class="line">        location / &#123;</span><br><span class="line">            root /home/doyo-blog/public/;</span><br><span class="line">            index index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # 聊天室服务</span><br><span class="line">        location /chat &#123;</span><br><span class="line">            proxy_pass http://servers; # 代理到upstream集群</span><br><span class="line">            index index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # fastdfs图片服务地址,也使用80端口</span><br><span class="line">        location /doyo/M00 &#123;</span><br><span class="line">            ngx_fastdfs_module;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;备注: mac安装由于SIP(System Integrity Protection, 系统完整性保护功能), 无法在/usr/目录下创建文件, 所以需要关闭SIP&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重启 Mac, 按住 Command + R, 进入 r
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Disruptor, Amino, JCTools</title>
    <link href="https://doooyo.github.io/2019/04/22/Disruptor,%20Amino,%20JCTools/"/>
    <id>https://doooyo.github.io/2019/04/22/Disruptor, Amino, JCTools/</id>
    <published>2019-04-21T16:31:51.681Z</published>
    <updated>2019-04-21T16:31:51.681Z</updated>
    
    <content type="html"><![CDATA[<h2 id="disruptor">Disruptor</h2><p><img src="https://upload-images.jianshu.io/upload_images/3370771-b0549337cee52d41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/774/format/webp" alt></p><p>看一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 高并发且线程安全的生产消费环形缓冲队列, 且基于发布订阅模式(Event)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 性能: Disruptor是高性能异步处理框架,是线程间通信的高效低延时的内存消息组件; 其LMAX架构可以获得每秒6百万订单</span></span><br><span class="line"><span class="comment"> * 1. 环形数据结构 RingBuffer --&gt; 避免垃圾回收</span></span><br><span class="line"><span class="comment"> * 2. 元素索引定位 --&gt; 2^N次幂使得可通过位运算, 加快索引计算速度; 下标递增,且为long型是[百亿亿]级别, 几百万年都不会溢出</span></span><br><span class="line"><span class="comment"> * 3. 无锁设计 --&gt;</span></span><br><span class="line"><span class="comment"> *    读(生产者)写(消费者)线程会先申请可以操作的元素在数组中的位置, 申请到后直接CAS写入</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 分如下几个步骤:</span></span><br><span class="line"><span class="comment"> * 1. 启动disruptor</span></span><br><span class="line"><span class="comment"> *   1.1 定义元素, 也可以称为Event事件 (即Event可携带何种数据结构)  --&gt; LongEvent</span></span><br><span class="line"><span class="comment"> *   1.2 定义元素的创建工厂, 定义如何创建Event元素</span></span><br><span class="line"><span class="comment"> *   1.3 指定线程池, 比如newSingleThreadExecutor缓存线程池</span></span><br><span class="line"><span class="comment"> *       但也可以直接传入ThreadFactory, 定义如何创建线程, 内部使用BasicExecutor来创建线程池(类似ThreadPoolExecutor)</span></span><br><span class="line"><span class="comment"> *   1.4 定义环形缓冲RingBuffer的大小, 注意必须是2的N次幂, 主要是为了计算</span></span><br><span class="line"><span class="comment"> *   1.5 消费者等待策略(没有事件Event到来的策略)</span></span><br><span class="line"><span class="comment"> *       BlockingWaitStrategy:       | 加锁                     | 性能最差</span></span><br><span class="line"><span class="comment"> *       BusySpinWaitStrategy:       | 自旋                     |</span></span><br><span class="line"><span class="comment"> *       PhasedBackoffWaitStrategy:  | 自旋 + yield + 自定义策略  |</span></span><br><span class="line"><span class="comment"> *       SleepingWaitStrategy:       | 自旋 + yield + sleep     |</span></span><br><span class="line"><span class="comment"> *       TimeoutBlockingWaitStrategy:| 加锁, 有超时限制           |</span></span><br><span class="line"><span class="comment"> *       YieldingWaitStrategy:       | 自旋 + yield + 自旋       | 性能最好</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   1.6 指定单生产者/多生产者</span></span><br><span class="line"><span class="comment"> * 2. 生产者 publish Event</span></span><br><span class="line"><span class="comment"> * 3. 消费者处理Event, 定义Handler处理器</span></span><br><span class="line"><span class="comment"> * 4. 关闭disruptor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DisruptorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EventFactory&lt;LongEvent&gt; eventFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> ringBufferSize = <span class="number">2</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// 必须是2的N次幂</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Disruptor&lt;LongEvent&gt; disruptor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Translator translator = <span class="keyword">new</span> Translator();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        eventFactory = <span class="keyword">new</span> LongEventFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 也可以传入线程工厂, 内部会创建线程池</span></span><br><span class="line">        executor = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        disruptor = <span class="keyword">new</span> Disruptor&lt;LongEvent&gt;(</span><br><span class="line">                eventFactory, <span class="comment">//Event工厂</span></span><br><span class="line">                ringBufferSize, <span class="comment">//环形缓冲大小</span></span><br><span class="line">                executor, <span class="comment">// 执行线程池, 也可以直接传入ThreadFactory, 内部使用BasicExecutor来创建线程池</span></span><br><span class="line">                ProducerType.SINGLE,</span><br><span class="line">                <span class="keyword">new</span> YieldingWaitStrategy()); <span class="comment">// 策略</span></span><br><span class="line">        EventHandler&lt;LongEvent&gt; handler = <span class="keyword">new</span> LongEventHandler();</span><br><span class="line"></span><br><span class="line">        disruptor.handleEventsWith(handler);</span><br><span class="line">        disruptor.setDefaultExceptionHandler(<span class="keyword">new</span> LongExceptionHandler());</span><br><span class="line"></span><br><span class="line">        disruptor.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布必须在finally中 (所以要求EventHandler处理器来判断是否有数据, 以及正确性)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publishV1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RingBuffer&lt;LongEvent&gt; ringBuffer = disruptor.getRingBuffer();</span><br><span class="line">        <span class="keyword">long</span> sequence = ringBuffer.next(); <span class="comment">// 请求下一个事件序号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            LongEvent event = ringBuffer.get(sequence); <span class="comment">//获取该序号对应的事件对象</span></span><br><span class="line">            <span class="keyword">long</span> data = ThreadLocalRandom.current().nextLong(<span class="number">1000</span>);</span><br><span class="line">            event.setValue(data); <span class="comment">// 填充数据</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ringBuffer.publish(sequence); <span class="comment">// 发布必须在finally中确保发送, 如果某个请求的sequence未被提交, 会堵塞后续publish或者其他producer</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用translator确保发布 (所以要求EventHandler处理器来判断是否有数据, 以及正确性)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publishV2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RingBuffer&lt;LongEvent&gt; ringBuffer = disruptor.getRingBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> data = ThreadLocalRandom.current().nextLong(<span class="number">1000</span>); <span class="comment">// 需要填充的数据</span></span><br><span class="line"></span><br><span class="line">        ringBuffer.publishEvent(translator, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        disruptor.shutdown(); <span class="comment">//方法会堵塞直到所有事件都得到处理</span></span><br><span class="line">        executor.shutdown(); <span class="comment">//如果有线程池, 则必须手动关闭, 因为disruptor.shutdown不会自动关闭线程池</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        start(); <span class="comment">//启动Disruptor</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 每500毫秒向RingBuffer生产一个event</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">            publishV2();</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>待续</p><h2 id="amino">Amino</h2><p>待续</p><h2 id="jctool">JcTool</h2><p>待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;disruptor&quot;&gt;Disruptor&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3370771-b0549337cee52d41.png?imageMogr2/auto-o
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ELK部署与使用</title>
    <link href="https://doooyo.github.io/2019/04/22/ELK%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>https://doooyo.github.io/2019/04/22/ELK部署与使用/</id>
    <published>2019-04-21T16:31:51.675Z</published>
    <updated>2019-04-21T16:31:51.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="zipkin使用">zipkin使用</h2><p><font color="orange">zipkin在<code>springcloud2.x</code>已不推荐自己创建<code>Zipkin Server</code>服务, 需要使用编译好的jar</font></p><ul><li>安装zipkin docker</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9411:9411 openzipkin/zipkin</span><br></pre></td></tr></table></figure><ul><li>添加依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>yml配置</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  sleuth:</span></span><br><span class="line"><span class="attr">    feign:</span></span><br><span class="line"><span class="attr">      enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    sampler:</span></span><br><span class="line">      <span class="comment"># 采样率, 1.0表示全量采集</span></span><br><span class="line"><span class="attr">      probability:</span> <span class="number">1.0</span></span><br><span class="line"><span class="attr">    web:</span></span><br><span class="line"><span class="attr">      client:</span></span><br><span class="line"><span class="attr">        enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  zipkin:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># zipkin的部署地址</span></span><br><span class="line"><span class="attr">    base-url:</span> <span class="attr">http://192.168.80.81:9411/</span></span><br><span class="line"><span class="attr">    service:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br><span class="line"><span class="attr">    sender:</span></span><br><span class="line">      <span class="comment"># 支持http, rabbitmq, kafka, 后期采用kafka</span></span><br><span class="line"><span class="attr">      type:</span> <span class="string">web</span></span><br></pre></td></tr></table></figure><ul><li>zipkin访问地址</li></ul><p>部署在哪台机器请自行修改IP</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http:</span><span class="string">//192.168.80.81:9411/</span></span><br></pre></td></tr></table></figure><h2 id="elk部署安装">ELK部署安装</h2><ul><li>下载镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull sebp/elk</span><br></pre></td></tr></table></figure><ul><li>运行条件</li></ul><p>这是一个聚合镜像, 要求Docker至少得分配3GB的内存; Elasticsearch至少需要单独2G的内存; <code>vm.max_map_count</code>至少需要<code>262144</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> linux按如下操作, 后期重新制作镜像</span><br><span class="line">sudo vi /etc/sysctl.conf</span><br><span class="line"><span class="meta">#</span> 添加如下</span><br><span class="line">vm.max_map_count=262144</span><br><span class="line"><span class="meta">#</span> 查看是否生效</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><ul><li>启动<code>ELK</code></li></ul><table><thead><tr><th style="text-align:center">- 端口</th><th style="text-align:left">- 作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>5601</code></td><td style="text-align:left">Kibana映射地址</td></tr><tr><td style="text-align:center"><code>9200</code></td><td style="text-align:left">ES映射地址</td></tr><tr><td style="text-align:center"><code>5044</code></td><td style="text-align:left">Logstash Beats界面映射地址</td></tr><tr><td style="text-align:center"><code>9250</code></td><td style="text-align:left">Logstash监听搜集日志的端口(可自行随意指定)<br>目前使用tcp方式从服务节点发送日志到logstash, 不采用物理文件日志搜集方式, 后期会添加kafka队列作为缓冲</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>## 注意挂载配置文件目录</span><br><span class="line">docker run -itd -p 9250:9250 -p 5601:5601 -p 9200:9200 -p 5044:5044 -v /Users/apple/idea/spring-cloud-bingo/config:/data --name elk sebp/elk:latest</span><br></pre></td></tr></table></figure><p>稍微注意下, 由于需要配置<code>logstash</code>如何在<code>elasticsearch</code>创建索引, 所以需要定义<code>logstash.conf</code>文件, 在<code>ELK</code>启动时需要指定, 配置文件如下</p><ul><li><code>logstash.conf</code> 配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># For detail structure of this file</span><br><span class="line"># Set: https://www.elastic.co/guide/en/logstash/current/configuration-file-structure.html</span><br><span class="line">input &#123;</span><br><span class="line">  # For detail config for log4j as input,</span><br><span class="line">  # See: https://www.elastic.co/guide/en/logstash/current/plugins-inputs-log4j.html</span><br><span class="line">  tcp &#123;</span><br><span class="line">    mode =&gt; &quot;server&quot;</span><br><span class="line">    host =&gt; &quot;127.0.0.1&quot;</span><br><span class="line">    port =&gt; 9250 #logstash监听地址</span><br><span class="line">    codec =&gt; &quot;json&quot; #发送格式需是json</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  ## 过滤条件后期添加, 也可以在logback.xml中预先过滤一次</span><br><span class="line">  #Only matched data are send to output.</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  # For detail config for elasticsearch as output,</span><br><span class="line">  # See: https://www.elastic.co/guide/en/logstash/current/plugins-outputs-elasticsearch.html</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    action =&gt; &quot;index&quot;          #The operation on ES</span><br><span class="line">    hosts  =&gt; [&quot;127.0.0.1:9200&quot;] #ElasticSearch host, can be array.</span><br><span class="line">    index  =&gt; &quot;applog&quot;         #The index to write data to.</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进入容器重启<code>logstash</code>目的是让<code>logstash</code>应用<code>logstash.conf</code>配置文件<font color="red"> 此处需要重新制作镜像, 将启动配置<code>logstash.conf</code>写入Dockerfile</font></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it elk /bin/bash</span><br><span class="line"><span class="meta">#</span>停止logstash</span><br><span class="line">service logstash stop</span><br><span class="line"><span class="meta">#</span>启动测试是否与es连接</span><br><span class="line">/opt/logstash/bin/logstash -e 'input &#123; stdin &#123; &#125; &#125; output &#123; elasticsearch &#123; hosts =&gt; ["localhost"] &#125; &#125;'</span><br><span class="line"><span class="meta">#</span>随便在控制台输入字符, 然后进es地址查看</span><br><span class="line"><span class="meta">#</span>localhost:9200/_search?pretty</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>最后带配置启动logstash</span><br><span class="line">/opt/logstash/bin/logstash --path.data /tmp/logstash/data -f /data/logstash.conf</span><br></pre></td></tr></table></figure><h2 id="springcloud与logstash集成">SpringCloud与Logstash集成</h2><p>通过将日志模块搜集的日志以</p><ul><li>依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 支持tcp和udp --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.logstash.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logstash-logback-encoder<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>logback.xml</li></ul><p>详情请见工程</p><ul><li>配置</li></ul><p><font color="red">注意此节点需要配置到 <code>bootstrap.yml</code>;同时<code>logback.remote.xml</code>名字固定, 否则导致日志xml配置提前解析, 会找不到<code>logstash.tcp.destination</code>填写的值</font></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logstash:</span></span><br><span class="line"><span class="attr">  tcp:</span></span><br><span class="line"><span class="attr">    destination:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9250</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">  config:</span> <span class="attr">classpath:logback.remote.xml</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;zipkin使用&quot;&gt;zipkin使用&lt;/h2&gt;
&lt;p&gt;&lt;font color=&quot;orange&quot;&gt;zipkin在&lt;code&gt;springcloud2.x&lt;/code&gt;已不推荐自己创建&lt;code&gt;Zipkin Server&lt;/code&gt;服务, 需要使用编译好的jar&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>concurrent并发包讲解(三)</title>
    <link href="https://doooyo.github.io/2019/04/22/Concurrent%E5%B9%B6%E5%8F%91%E5%8C%85%E8%AE%B2%E8%A7%A3(%E4%B8%89)/"/>
    <id>https://doooyo.github.io/2019/04/22/Concurrent并发包讲解(三)/</id>
    <published>2019-04-21T16:23:39.203Z</published>
    <updated>2019-04-21T16:23:39.203Z</updated>
    
    <content type="html"><![CDATA[<h2 id="aqs与synchronized优化">AQS与Synchronized优化</h2><h3 id="synchronized偏向锁-轻量级锁-重量级锁">synchronized偏向锁,轻量级锁,重量级锁</h3><p>synchronized在之前一直是重量级悲观锁的代名词, 这种情况在java1.6时得到改善, 性能上已不输于Lock</p><blockquote><ol><li>加锁代码块使用<code>monitorenter</code>, <code>monitorexit</code>;加锁:1.1 尝试获取monitor, 如果为0则说明锁可用, 加11.2 同一线程再次尝试获取该锁, 加1, 表明可重入1.3 不同线程尝试获取该锁, 则阻塞, 等待monitor进入数为0解锁:1.1 monitor的进入数减1，如果减1后进入数为0，那线程退出monitor</li><li>锁优化5种方式2.1 <code>减少锁持有时间</code>: 即减小锁范围2.2 <code>减小锁粒度</code>: 比如ConcurrentHashMap的Segment2.3 <code>锁分离</code>: 比如ReadWriteLock读写锁; LinkedBlockingQueue(使用了入队锁和出队锁)2.4 <code>锁粗化</code>: 在多个不连续同步代码块多次加解锁会很低效, 可以扩大为只加解锁一次2.5 <code>锁消除</code>: 在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作; 比如StringBuffer是线程安全的, 如果变量sb本就是局部变量并非共享, 则JVM根据逃逸分析sb变量是否会超过作用域变得全局共有共享(其他线程可访问),</li></ol></blockquote><ul><li>对象存储结构, markword</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对象头: markword/ klass/ length(如果是数组的话)</span><br><span class="line">数据区</span><br><span class="line">对齐填充</span><br></pre></td></tr></table></figure><p>如下图, 对象头<code>哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等</code></p><blockquote><p><code>轻量级加锁</code>:条件1: 是否偏向锁为&quot;0&quot;(无锁状态)条件2: 锁标志位为“01”状态步骤1: 开始在当前栈帧中创建<code>Lock Record</code>空间, 用于保存拷贝的Mark Word - 官方叫<code>Displaced Mark Word</code>步骤2: 拷贝对象头中的Mark Word复制到锁记录中; <code>Mark Word -&gt; Lock Record</code>, 开始CAS更新对象的Mark Record为指向Lock Record的指针; 成功则将锁标志位置为00失败说明CAS有竞争, 则直接升级为系统Mutex互斥量<code>偏向锁加锁</code>:步骤1: 对象头处于无锁状态, 将锁标志位置为01(偏向模式)步骤2: CAS操作将获得锁的线程ID记录到Mark Word中的偏向线程ID步骤3: 将是否偏向锁标记置为1以后每次进入同步代码块时都会检查线程ID是否和偏向线程ID是否一致, 一致则表明无竞争, 直接执行无须加锁; 否则转为轻量级锁流程</p></blockquote><p><img src="http://img.blog.csdn.net/20151217151455512?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p><blockquote><ol><li><code>偏向锁</code>: 某些情况下只有一个线程在获取锁, 所以synchronized代码块所在临界区不存在竞争, 则默认进入偏向锁, 可以看作无锁</li><li><code>轻量级锁</code>: 一旦有其他线程加入竞争, 则立马<code>不可逆</code>的升级为轻量级锁, 即CAS自旋锁; <code>自适应自选锁</code>即JVM在运行时搜集统计信息, 动态调整自选锁的自选次数上界.</li><li><code>重量级锁</code>: 一旦CAS自旋操作还是未成功, 则升级为系统级mutex互斥锁; 因为自旋会消耗cpu时间片</li></ol></blockquote><p>锁升级的逻辑图:<img src="http://ifeve.com/wp-content/uploads/2012/10/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81.png" alt></p><p>MarkWord是如何操作的, 可以参考如下文章:<a href="https://www.cnblogs.com/xudilei/p/6840061.html" target="_blank" rel="noopener">synchronized优化</a></p><h3 id="aqs同步器">AQS同步器</h3><p>是一个同步队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractOwnAQS</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractOwnAQS</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维持一个双向队列</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用于指示节点正在共享模式下等待的标记</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="comment">// 用于指示节点正在独占模式下等待的标记</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 表示当前节点从同步队列中取消</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 表示当前节点的的后继节点将要或者已经被阻塞, 在当前节点释放的时候需要unpark后继节点</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 表示当前节点在等待condition, 即在condition队列中进行等待</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 表示releaseShared需要被传播给后续节点（仅在共享模式下使用）</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 节点状态(状态如上所示)</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前继节点</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line">        <span class="comment">// 后继节点</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line">        <span class="comment">// 存储condition队列中的后继节点</span></span><br><span class="line">        Node nextWaiter;</span><br><span class="line">        <span class="comment">// 当前线程</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回前继节点(注意处理为空, 因为? TODO )</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">            Node p = prev;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用于构造添加到等待队列的线程节点</span></span><br><span class="line">        Node(Thread thread, Node mode) &#123;</span><br><span class="line">            <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// TODO Used by Condition</span></span><br><span class="line">        Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123;</span><br><span class="line">            <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加锁的计数器, state=0表示无锁, 大于0表示有锁, 重入一次加1, 退出一次减1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得独享锁的线程(如果获得锁成功, 即state变量CAS设置1成功, 则设置此变量为当前线程)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得独享锁线程的getter,setter</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setExclusiveOwnerThread</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        exclusiveOwnerThread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Thread <span class="title">getExclusiveOwnerThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exclusiveOwnerThread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头结点不存储Thread, 仅保存next结点的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">    <span class="comment">// 尾节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> spinForTimeoutThreshold = <span class="number">1000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">        state = newState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通用CAS自旋入队方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="comment">// 如果尾节点是空, 表明队列还未创建, 则初始化队列头节点,同时尾节点也指向head: tail=head</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加入等待队列(获取锁不成功时)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// FIXME 这里意思是队列不为空就快速尝试一次入队的意思, 但enq入队也只是多了CAS自旋而已, 实在没看出来效率有很高提升</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="comment">// 注意: 此处可能产生A线程tryAcquired失败后调用addWaiter入队前, B线程刚好释放锁, 且C线程刚好又进来, 判断锁空闲且队列也还是空的, 则会产生C线程先于A线程</span></span><br><span class="line">            <span class="comment">// 说明公平锁也不是绝对的公平</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试快速方式直接放到队尾(入队)失败后, 则CAS自旋入队</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CAS更新state, 即独享锁的重入次数, 进入一次加1, 退出一次减1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试再一次获取锁(子类实现)</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置队列头节点(head的线程和前继节点都是空)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        head = node;</span><br><span class="line">        node.thread = <span class="keyword">null</span>;</span><br><span class="line">        node.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.ReentrantLock第一次设置state不成功,则开始调用acquire,开始第一次重试;</span></span><br><span class="line"><span class="comment">     * 2.addWaiter加入等待队列后, 判断队列如果只有一个节点(head不算),说明只有一个线程在等待,开始第二次重试(acquireQueued);</span></span><br><span class="line"><span class="comment">     * 3.第二次重试加锁不成功, 则开始判断是否中断线程, 只有前继节点的线程状态为SIGNAL时可以允许当前节点的线程被中断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// (独占模式获取锁顶层入口)当调用lock.lock()时, CAS设置state不成功则会再调用一次acquire, 意味着再次尝试(有几率可能其他线程正好释放了锁, 也可能是重入)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">                <span class="comment">// 表明锁真没有获取到, 则开始加入等待队列</span></span><br><span class="line">                acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            <span class="comment">// 补上中断标记的意思</span></span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源</span></span><br><span class="line">    <span class="comment">// 1. 结点进入队尾后，检查状态，找到安全休息点</span></span><br><span class="line">    <span class="comment">// 2. 调用park()进入waiting状态，等待unpark()或interrupt()唤醒自己</span></span><br><span class="line">    <span class="comment">// 3. 被唤醒后，看自己是不是有资格能拿到号。如果拿到，head指向当前结点，并返回从入队到拿到号的整个过程中是否被中断过；如果没拿到，继续流程1</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//标记等待过程中是否被中断过</span></span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 自旋直到等待队列剩下最后一个线程(其实在等外部的unlock/interrupt)</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 拿到前继节点</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">// 1. 如果是除了头节点后的第一个节点, 说明已经轮到自己被唤醒(可能是被前继节点唤醒, 也可能是自己被中断)</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    <span class="comment">// 终于拿到锁了, 则等待队列里的节点已无效, 将自己设置为头节点head</span></span><br><span class="line">                    <span class="comment">// 意思就是拿到资源了, 就可以出队了</span></span><br><span class="line">                    <span class="comment">// TODO 参考 https://www.jianshu.com/p/01f2046aab64</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//表明已成功拿到资源</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">//返回等待过程中是否被中断过</span></span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 2.如果自己可以休息了，就进入waiting状态，直到被unpark()</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node)</span><br><span class="line">                        <span class="comment">// 在这里已经被park阻塞住, 等待被unpark/interrupt来唤醒,唤醒后继续执行此循环</span></span><br><span class="line">                        &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                    <span class="comment">//如果等待过程中被中断过，哪怕只有那么一次，就将interrupted标记为true</span></span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 出现异常或者出现中断，就会执行finally的取消线程的请求操作, 主要是将 node.waitStatus = Node.CANCELLED;不参与竞争了</span></span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// //调用park()使线程进入waiting状态</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// //如果被唤醒, 查看自己是不是被中断唤醒的, 注意会清除线程中断标记</span></span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出现异常或者出现中断, 取消线程的请求操作</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不再关联任何线程</span></span><br><span class="line">        node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过CANCEL状态的前继节点, 找到一个有效节点(这里在调整prev指针)</span></span><br><span class="line">        Node pred = node.prev;</span><br><span class="line">        <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">            node.prev = (pred = pred.prev);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此节点可能是一个CANCEL节点</span></span><br><span class="line">        Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 出现异常或者出现中断, 则设置线程为取消状态, 不再参与竞争</span></span><br><span class="line">        node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.自己是tail,则移除自己</span></span><br><span class="line">        <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">            <span class="comment">// 断开pred变量的next引用, 因为pred已成为新的tail, 好让跳过的CANCEL节点进行GC</span></span><br><span class="line">            compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2.不是head后继节点也不是tail, 则将node的前继节点的waitStatus置为SIGNAL, 并使node的前继节点指向node的后继节点</span></span><br><span class="line">            <span class="comment">// 注意这里还有prev指针没有断开, 会不会内存溢出? 其实这里是其他线程调用cancelAcquire/shouldParkAfterFailedAcquire时,</span></span><br><span class="line">            <span class="comment">// 会自动调整prev指针, 以保证CANCEL节点的GC</span></span><br><span class="line">            <span class="keyword">int</span> ws;</span><br><span class="line">            <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">                    ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">                            (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">                    pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Node next = node.next;</span><br><span class="line">                <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// node的前继节点指向node的后继节点, 即将node前驱节点的next指针断开, prev指针会由其他线程断开, 即node出队</span></span><br><span class="line">                    compareAndSetNext(pred, predNext, next);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//3. node是head的后继节点, 则直接唤醒node的后继节点(唤醒下一个线程, 注意是从队尾开始遍历的, 因为next指针链已被上面步骤2给破坏)</span></span><br><span class="line">                unparkSuccessor(node);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 断开node前驱节点的next指针, 但是node自身的next指针还指向node.next, 所以此处将node.next也断开引用, 让其只剩下prev引用链</span></span><br><span class="line">            node.next = node; <span class="comment">// help GC</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒下一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">        <span class="comment">//置零当前线程所在的结点状态, 允许失败</span></span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到下一个需要唤醒的结点s</span></span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="comment">//如果为空或已取消</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 注意这里是从队尾开始唤醒, 因为节点为CANCEL状态时, node.next已经设置指向了自己, next指针链已经被破坏, 现在只剩下prev指针链完整</span></span><br><span class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 唤醒下一个节点</span></span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此方法主要用于检查状态，看看自己是否真的可以去休息了(调用park进入waiting)</span></span><br><span class="line"><span class="comment">     * 出队操作也是在此处真正的执行（破除了prev前置指针, 后置指针在cancelAcquire方法里已破除）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2次重试加锁都失败后, 判断是否可以阻塞线程</span></span><br><span class="line"><span class="comment">     * waitStatus&gt;0表示取消状态; waitStatus&lt;0表示有效状态</span></span><br><span class="line"><span class="comment">     * 判断条件:</span></span><br><span class="line"><span class="comment">     *    1.允许被阻塞, 前继节点waitStatus=SIGNAL, 表示允许在自身释放锁时通知后继节点进行unpark; 用以证明后继节点允许被park阻塞</span></span><br><span class="line"><span class="comment">     *      说白了, 就是处于唤醒状态, 只要前继结点释放锁, 就会通知标识为SIGNAL状态的后继结点的线程执行</span></span><br><span class="line"><span class="comment">     *    2.不允许被阻塞, 前继节点waitStatus=CANCELLED, 表示将等待队列里为取消状态的线程进行移除</span></span><br><span class="line"><span class="comment">     *    3.不允许被阻塞,</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">        <span class="comment">// //如果已经告诉前驱拿完号后通知自己一下，那就可以安心休息了</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 表示ws = Node.CANCELLED, 如果前驱放弃了, 那就一直往前找，直到找到最近一个正常等待的状态, 并排在它的后边</span></span><br><span class="line">        <span class="comment">// 放弃的结点, 由于被自己“加塞”到它们前边, 它们相当于形成一个无引用链, 稍后就会被保安大叔赶走了(GC回收)！</span></span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// A=B=C =&gt; A=C;B=C;</span></span><br><span class="line">                <span class="comment">// 这里是在调整prev指针, next指针是cancelAcquire做的, 以保证队列不会内存溢出, 即这里将会真正的GC</span></span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果前驱正常，那就把前驱的状态设置成SIGNAL，告诉它拿完号后通知自己一下。有可能失败，人家说不定刚刚释放完呢！</span></span><br><span class="line">            <span class="comment">// 初始化的新节点waitStatus是0</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放排他锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 尝试释放锁, 其实就是state-1</span></span><br><span class="line">        <span class="comment">// Thread.currentThread() != getExclusiveOwnerThread() 如果没有加锁就开始释放锁, 会抛出异常</span></span><br><span class="line">        <span class="comment">// state=state-1 即可, 如果state为0说明释放锁, 则设置clusiveOwnerThread = null</span></span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 唤醒后继节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体子类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------------------------ 公平锁部分 ------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在每次tryAcquired的时候,都会判断是否有等待线程, 若有则等待, 没有才能获取锁（返回false表明队列为空才能获取锁）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1. h.next为空表明表明已有线程在排队</span></span><br><span class="line"><span class="comment">         *   1.1 当前线程进入hasQueuedPredecessors的同时，另一个线程已经更改了tail（在enq中），但还没有将head的next指向自己，这中情况表明队列不为空</span></span><br><span class="line"><span class="comment">         *   1.2 当前线程将head赋予h后，head被另一个线程移出队列，导致h的next为空，这种情况说明锁已经被占用</span></span><br><span class="line"><span class="comment">         * 2.head.next的线程不是当前线程，则表示队列不为空, 即已有线程在排队</span></span><br><span class="line"><span class="comment">         * 队列不空则返回true, 导致进入等待队列（后面则和非公平锁一致）</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 问题:</span></span><br><span class="line"><span class="comment">         * 步骤1: 线程A调用tryAcquire获取锁失败后, 并在调用addWaiter进入等待队列之前,</span></span><br><span class="line"><span class="comment">         * 步骤2: 线程B释放了锁</span></span><br><span class="line"><span class="comment">         * 步骤3: 此时C线程进来判断到锁空闲, 进入hasQueuedPredecessors返回false（等待队列为空）, C先于A获得锁</span></span><br><span class="line"><span class="comment">         * 表明公平锁也不是绝对的公平</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 公平锁会导致后来线程一定会进入等待队列, 就算其他线程碰巧释放了锁也不允许越级获取锁, 并发效率将降低很多</span></span><br><span class="line"><span class="comment">         * 一个入队等待可能耗时几十毫秒, 上千的线程将导致延时几十秒的数量级</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">                ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------------------------ 共享锁部分 ------------------------------------</span></span><br><span class="line">    <span class="comment">// 这部分等查阅Semaphore(信号量)/CountdownLatch(同步计数器)/CyclicBarrier(循环屏障)时再补充</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ====================== CAS支持 ============================</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> stateOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> headOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> tailOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> waitStatusOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stateOffset = unsafe.objectFieldOffset</span><br><span class="line">                    (AbstractOwnAQS.class.getDeclaredField(<span class="string">"state"</span>));</span><br><span class="line">            headOffset = unsafe.objectFieldOffset</span><br><span class="line">                    (AbstractOwnAQS.class.getDeclaredField(<span class="string">"head"</span>));</span><br><span class="line">            tailOffset = unsafe.objectFieldOffset</span><br><span class="line">                    (AbstractOwnAQS.class.getDeclaredField(<span class="string">"tail"</span>));</span><br><span class="line">            waitStatusOffset = unsafe.objectFieldOffset</span><br><span class="line">                    (Node.class.getDeclaredField(<span class="string">"waitStatus"</span>));</span><br><span class="line">            nextOffset = unsafe.objectFieldOffset</span><br><span class="line">                    (Node.class.getDeclaredField(<span class="string">"next"</span>));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CAS更新头节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetHead</span><span class="params">(Node update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, headOffset, <span class="keyword">null</span>, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CAS更新尾节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetTail</span><span class="params">(Node expect, Node update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, tailOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CAS更新节点内部状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetWaitStatus</span><span class="params">(Node node,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                         <span class="keyword">int</span> expect,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                         <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(node, waitStatusOffset,</span><br><span class="line">                expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CAS更新节点的后继节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetNext</span><span class="params">(Node node,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   Node expect,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   Node update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapObject(node, nextOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;aqs与synchronized优化&quot;&gt;AQS与Synchronized优化&lt;/h2&gt;
&lt;h3 id=&quot;synchronized偏向锁-轻量级锁-重量级锁&quot;&gt;synchronized偏向锁,轻量级锁,重量级锁&lt;/h3&gt;
&lt;p&gt;synchronized在之前一直是重
      
    
    </summary>
    
      <category term="concurrent" scheme="https://doooyo.github.io/categories/concurrent/"/>
    
    
      <category term="锁" scheme="https://doooyo.github.io/tags/%E9%94%81/"/>
    
      <category term="队列" scheme="https://doooyo.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="线程池" scheme="https://doooyo.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>concurrent并发包讲解(二)</title>
    <link href="https://doooyo.github.io/2019/04/22/Concurrent%E5%B9%B6%E5%8F%91%E5%8C%85%E8%AE%B2%E8%A7%A3(%E4%BA%8C)/"/>
    <id>https://doooyo.github.io/2019/04/22/Concurrent并发包讲解(二)/</id>
    <published>2019-04-21T16:23:39.188Z</published>
    <updated>2019-04-21T16:23:39.188Z</updated>
    
    <content type="html"><![CDATA[<h2 id="知识要点">知识要点</h2><p>写此篇只记录一些自己觉得比较重要的知识点, 其余查阅之前的篇幅</p><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:left">知识点</th></tr></thead><tbody><tr><td style="text-align:center"><code>Thread/Runable</code></td><td style="text-align:left"><code>线程状态机</code> <br> <code>join/wait</code> <br> <code>sleep</code> <br> <code>suspend/resume</code> <br> <code>interupt/interrupted/isInterrupted</code> <br> <code>notify/notifyAll</code> <br> <code>yield</code> <br></td></tr><tr><td style="text-align:center"><code>java内存模型</code></td><td style="text-align:left"><code>原子性/CAS</code> <br> <code>有序性/指令重排</code> <br> <code>可见性/volatile(内存屏障)</code> <br> <code>Happen-Before</code></td></tr><tr><td style="text-align:center"><code>Atomic包/CAS</code></td><td style="text-align:left"><code>AtomicInteger</code> <br> <code>AtomicReference</code> <br> <code>AtomicStampedReference</code> <br> <code>AtomicMarkableReference</code> <br> <code>AtomicIntegerArray</code>, <code>AtomicReferenceArray</code>  <br> <code>AtomicIntegerFieldUpdater</code> <br> <code>LockFreeVector</code> <br><code>LongAdder(JDK8)</code> <br> <code>ABA问题</code> <br></td></tr><tr><td style="text-align:center"><code>syncthroized/wait/notify</code></td><td style="text-align:left"><code>常用并发控制</code></td></tr><tr><td style="text-align:center"><code>Concurrent并发包</code></td><td style="text-align:left"><code>ReentrantLock</code><br> <code>Condition</code><br> <code>Semaphore</code><br> <code>ReadWriteLock</code>,<code>ReentrantReadWriteLock</code><br> <code>CountDownLatch</code><br> <code>CyclicBarrier</code><br> <code>CountDownLatch</code><br><code>ForkJoin</code><br><code>AQS</code><br><code>LockSupport</code></td></tr><tr><td style="text-align:center"><code>Amino(并发线程组件)</code></td><td style="text-align:left"><code>Master-Worker模式</code> <br> <code>Map-reduce模式</code> <br> <code>Divide and conquer模式</code> <br> <code>Pipeline模式</code> <br></td></tr><tr><td style="text-align:center"><code>JCTool</code></td><td style="text-align:left"><code>增强型数据结构</code></td></tr><tr><td style="text-align:center"><code>Guava Concurrent</code></td><td style="text-align:left"><code>谷歌并发编程工具包</code></td></tr><tr><td style="text-align:center"><code>Disruptor</code></td><td style="text-align:left"><code>高并发循环事件队列</code></td></tr><tr><td style="text-align:center"><code>Reactor与Proactor</code></td><td style="text-align:left"><code>涉及操作系统IO模型, 同步与异步/阻塞与非阻塞</code></td></tr></tbody></table><h2 id="thread-runnable">Thread/Runnable</h2><p>Thread只能单继承, Runnable可以多继承, 内部都是重写run()方法</p><h3 id="状态机">状态机</h3><p>线程有6种状态, 请查阅<code>java多线程基础（一）</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    NEW,      <span class="comment">//初始态</span></span><br><span class="line">    RUNNABLE, <span class="comment">//就绪态/运行态</span></span><br><span class="line">    BLOCKED,  <span class="comment">//阻塞态</span></span><br><span class="line">    WAITING,  <span class="comment">//等待态</span></span><br><span class="line">    TIMED_WAITING, <span class="comment">//超时等待态</span></span><br><span class="line">    TERMINATED; <span class="comment">//终止态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RUNNABLE</code>状态在jvm里可以认为是运行态, 但对于操作系统来说, <code>RUNNABLE</code>=<code>Runnable</code>+<code>Running</code>; 只有分配到cpu时间片才叫Running, 对于java来说不用关心</p><h3 id="同时线程有三个队列">同时线程有三个队列:</h3><p><code>1. 就绪队列</code>:处于Runnable状态, 随时等待cpu调度; 调用<code>yelid</code>, <code>sleep到期</code>, <code>join等待完毕</code>后即处于此状态;<font color="red">注意:yelid是谦让cpu时间片; sleep和join也不会释放锁, 更不会进入「等待队列」。难理解的地方在于join, 它是由wait实现的, 居然不进入「等待队列」?这是由于join的是当前主线程, 而非调用线程, 主线程等待子线程调用完毕后由内部native方法去notify唤醒</font>参考: <a href="https://segmentfault.com/q/1010000007260477" target="_blank" rel="noopener">Java多线程里面join方法会使被阻塞线程释放对象锁吗？</a><code>2. 锁池队列</code>:处于竞争锁状态, <code>synchorized</code>, <code>Lock</code>, <code>...</code><code>3. 等待队列</code>:wait调用后即进入此队列, 一旦被唤醒则进入<code>锁池队列</code>去竞争锁, 一旦竞争到锁则进入<code>等待队列</code>, 等待被cpu时间片调度</p><blockquote><ol start="3"><li>notify/notifyAll, waitnotify是随机唤醒阻塞在锁(monitor)上的线程, 有可能会出现唤醒的线程竞争不到锁资源(进入临界区)而失败;notifyAll则是唤醒所有阻塞在其上的线程, 也可能出现<code>惊群效应</code>, 可以理解为活锁, 大家都竞争不到锁而往复的释放自己持有的资源</li></ol></blockquote><ul><li>interupt/interrupted/isInterrupted<code>suspend/resume</code>已不推荐使用, <code>stop</code>由于其强杀会导致不一致性问题, 也不推荐使用</li></ul><blockquote><p><code>interrupt()</code>:线程状态被置为&quot;中断&quot;状态<code>interrupted()</code>:静态方法, 内部返回当前执行线程是否中断, 同时清除中断标记<code>isInterrupted()</code> :实例方法, 判断指定线程的中断状态, 但不一定是当前线程, 可以是A线程去调用B线程的isInterrupted()方法; 不会清除中断标记<code>中断线程的两种方式</code>:<code>阻塞的定义是可能在访问磁盘IO,可能访问网络IO(HTTP请求),或者正在访问数据库, 也有可能调用了wait/sleep/join</code></p></blockquote><ol><li>如果子线程不会进入阻塞态, 则使用volatile修饰的布尔变量来控制子线程的退出</li><li>如果有阻塞, 则通过拦截异常进行退出<font color="red">注意如果调用了wait/sleep/join, 一旦再调用interrupt会出现中断异常, 同时JVM会<strong>清除中断标记</strong>, 所以再使用isInterrupted会得到false</font></li></ol><h2 id="java内存模型">Java内存模型</h2><p>这个请查阅之前写的篇幅, 这里只记录大纲</p><blockquote><ol><li><code>可见性</code>: 明白<code>工作内存</code>和<code>主存</code></li><li><code>有序性</code>: CPU指令流水, 为了减少时钟, 出现了指令重排序</li><li><code>原子性</code>: CAS(cmpxchg汇编指令)</li><li><code>Happen-Before</code>, 规约哪些是不能重排序的4.1 顺序原则: 有数据相关性, 重排不能改变语义(<code>as-if-serial</code>)4.2 监视器锁规则: 解锁必须先加锁4.3 volatile域规则: 写了才能读4.4 传递性规则: 通俗讲, 调用线程的join/wait/interrupt, 必须先start线程</li><li><code>java的内在实现</code>: 八条内存屏障指令<code>lock</code>：作用于主内存，把变量标识为线程独占状态。<code>unlock</code>：作用于主内存，解除独占状态。<code>read</code>：作用主内存，把一个变量的值从主内存传输到线程的工作内存。<code>load</code>：作用于工作内存，把read操作传过来的变量值放入工作内存的变量副本中。<code>use</code>：作用工作内存，把工作内存当中的一个变量值传给执行引擎。<code>assign</code>：作用工作内存，把一个从执行引擎接收到的值赋值给工作内存的变量。<code>store</code>：作用于工作内存的变量，把工作内存的一个变量的值传送到主内存中。<code>write</code>：作用于主内存的变量，把store操作传来的变量的值放入主内存的变量中</li><li><code>java的外在体现</code>: volatile, Atomic(CAS)</li><li><code>总结</code></li></ol></blockquote><ol><li>避免死锁的方式: 不要在锁代码块里再获取其他锁, 这是死锁的前提</li><li>synchronized保证了原子性/可见性; 但volatile只保证可见性(内部采用禁止重排序和内存屏障,每次都会读取主存而非寄存器的缓存), 所以volatile不适合getAndSet操作</li><li>1</li></ol><h2 id="atomic包-cas">Atomic包/CAS</h2><ul><li><code>Unsafe</code>它类似直接操作C语言, 可以获取变量在对象中的偏移量并赋值, 类似struct结构体</li><li><code>AtomicInteger</code>从下面可以看出, 主要使用了<code>unsafe.compareAndSwapInt</code>, CAS使用了原子汇编指令<code>cmpxchg</code>, 失败重试机制(乐观锁)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>AtomicIntegerArray</code>保证数组的每个元素操作都是线程安全, 比起<code>Collections.synchronizedList</code>使用<code>syncthorized</code>悲观锁性能要好一些。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndSetInt(array, checkedByteOffset(i), newValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终使用了如下代码</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">byteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * - base为数组在内存的基地址</span></span><br><span class="line"><span class="comment">     * int base = unsafe.arrayBaseOffset(int[].class);</span></span><br><span class="line"><span class="comment">     * - shift为数组每个元素在内存的偏移量bit</span></span><br><span class="line"><span class="comment">     * - scale指Integer的宽度, 4个字节(byte)</span></span><br><span class="line"><span class="comment">     * int scale = unsafe.arrayIndexScale(int[].class);</span></span><br><span class="line"><span class="comment">     * numberOfLeadingZeros计算前导零的个数</span></span><br><span class="line"><span class="comment">     * shift = 31 - Integer.numberOfLeadingZeros(scale);</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">long</span>) i &lt;&lt; shift) + base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>AtomicIntegerFieldUpdater</code>主要用于普通变量的原子操作, 但是它有四点前提:<code>可见且可变的非静态volatile变量</code></li></ul><blockquote><ol><li>可见: 即不能private</li><li>可变: 即不能以final修饰, 因为使用了反射不允许修改final已经初始化的值</li><li>非静态: 即不能使用static, 因为CAS不支持静态堆数据的赋值</li></ol></blockquote><ul><li><code>LongAdder</code>采用了热点分离的思想,采用了Cell[], 将value值分离为一个数组; 结果即数组的累加求和。和ConcurrentHashMap的Segment分段锁很类似;因为CAS是自旋方式, 所以可能会出现经常失败而导致cpu白白浪费(‘空转’)</li></ul><blockquote><ol><li>用long类型的base字段存储值</li><li>casBase()方法进行CAS递增</li><li>如果CAS失败,不会自旋, 会立即创建Cell[]</li><li>单个Cell上面出现了cell更新冲突，那么会尝试创建新的Cell, 当Cell[]数组不够了, 则扩容</li><li>AtomicLong效率比较, 在线程1000,10000次循环递增,大概差距在100+ms; 当1000线程,100w次大循环递增, 差距大致6倍<a href="https://blog.csdn.net/f641385712/article/details/84934085" target="_blank" rel="noopener">JDK8-LongAdder代替AtomicLong</a></li></ol></blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">      Cell[] as; <span class="keyword">long</span> b, v; <span class="keyword">int</span> m; Cell a;</span><br><span class="line">      <span class="comment">// 2. 对base字段进行CAS</span></span><br><span class="line">      <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">          <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">              (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">              <span class="comment">// 单个Cell上CAS失败, 新建Cell或者扩容数组</span></span><br><span class="line">              !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">              <span class="comment">// 初始化Cell[]数组/新建Cell/扩容数组</span></span><br><span class="line">              longAccumulate(x, <span class="keyword">null</span>, uncontended);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="/Users/apple/Desktop/test/LongAdder.png" alt="热点分离"></p><ul><li><p><code>ThreadLocalRandom</code>解决了Random类在多线程下多个线程竞争内部唯一的原子性种子变量而导致大量线程自旋重试的不足;如下代码所示, 虽然采用了<code>AtomicLong</code>, 解决了多线程计算出相同新种子的问题(获取了相同的随机数), 但是新种子是CAS运算, 线程堆积后则可能出现大量自旋;ThreadLocalRandom重写了nextInt, 利用ThreadLocal, 初始化Thread线程实例里的``threadLocalRandomSeed<code>变量</code>ThreadLocalRandom.current()`就是在初始化线程里的种子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Random的nextInt方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">(<span class="keyword">int</span> bound)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 检查区间是否负数</span></span><br><span class="line">    <span class="keyword">if</span> (bound &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(BadBound);</span><br><span class="line">    <span class="comment">// 2.计算新种子</span></span><br><span class="line">    <span class="comment">// 此处在多线程下可能会产生多个一样的种子</span></span><br><span class="line">    <span class="comment">// 所以seed采用了CAS原子类AtomicLong</span></span><br><span class="line">    <span class="keyword">int</span> r = next(<span class="number">31</span>);</span><br><span class="line">    <span class="keyword">int</span> m = bound - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 3.开始生成'随机数', seed=f(seed), 所以概率相等, 分布均匀</span></span><br><span class="line">    <span class="keyword">if</span> ((bound &amp; m) == <span class="number">0</span>)  <span class="comment">// i.e., bound is a power of 2</span></span><br><span class="line">        r = (<span class="keyword">int</span>)((bound * (<span class="keyword">long</span>)r) &gt;&gt; <span class="number">31</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = r;</span><br><span class="line">             u - (r = u % bound) + m &lt; <span class="number">0</span>;</span><br><span class="line">             u = next(<span class="number">31</span>))</span><br><span class="line">            ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>Random类的实现原理如下:</p><blockquote><ol><li>构造函数带种子或不带种子默认采用系统当前纳秒时间,因为代码执行速度在<code>[几百纳秒, 几十毫秒]</code>这个区间,整体递增, 所以精准(<code>this(seedUniquifier() ^ System.nanoTime())</code>)</li><li>种子的意义随机的起源数字, 目的就是为了足够&quot;随机&quot;</li><li>nextInt(100)返回<code>[0,100)</code>左闭右开内的一个随机数, 注意数字是一个线性函数生成出来的, 所以数字是均匀分布, 等概率事件这在数学上不能称之为随机, 所以我们称为<code>伪随机数</code></li><li>Math.random 生成[0,1)之间的double类型随机数, 它是Random的实例</li></ol></blockquote><ul><li><code>LockFreeVector</code>由Amino并发库实现, 大部分为无锁CAS设计;其存储结构为一个<code>AtomicReferenceArray</code>二维数组结构, 首个数组容量为8, 一共30个数组, 每次扩容都是前一个的2倍, 所以最大容量固定为<code>8*(2^30-1)</code>目的是避免扩容时修改之前的数据其数据形状很类似<code>九九乘法表</code>, 高度30, 长度为前一个元素2倍</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReferenceArray&lt;AtomicReferenceArray&lt;E&gt;&gt; buckets = <span class="keyword">new</span> AtomicReferenceArray(<span class="number">30</span>);</span><br></pre></td></tr></table></figure><blockquote><p><code>1.存储结构</code>定义为了CAS的二维数组<code>AtomicReferenceArray&lt;AtomicReferenceArray&lt;E&gt;&gt;</code>一共30个数组, 首个数组长度为8, 数组往后成倍递增, 8&lt;&lt;1, 8&lt;&lt;2 … 8&lt;&lt;29; 最大容量为<code>8*(2^30-1)</code><code>2.Descriptor静态内部类</code>目的是为了更好的有序读写数组, 是一个内部辅助类<code>3.总结</code>为何存储定义为二维数组, 由于一维数组必定会进行扩容, 扩容必定不是原子操作, 所以为了避开扩容来符合CAS, 所以如此设计。第一个数组装满, 则往第二个数组追加, 此时的重点就在于<code>计算二维坐标</code></p></blockquote><p>我们来看一下最重要的方法, 主要是计算二维坐标</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    Descriptor&lt;E&gt; desc;</span><br><span class="line">    Descriptor&lt;E&gt; newd;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        desc = descriptor.get();</span><br><span class="line">        <span class="comment">//预防上一个线程在设置完descriptor后(while语句块), 还没来得及执行最后一句话completeWrite, 预防性的措施</span></span><br><span class="line">        desc.completeWrite();</span><br><span class="line">        <span class="comment">//desc.size   Vector 本身的大小</span></span><br><span class="line">        <span class="comment">//FIRST_BUCKET_SIZE  第一个一位数组的大小</span></span><br><span class="line">        <span class="keyword">int</span> pos = desc.size + FIRST_BUCKET_SIZE;</span><br><span class="line">        <span class="keyword">int</span> zeroNumPos = Integer.numberOfLeadingZeros(pos);  <span class="comment">// 取出pos 的前导零</span></span><br><span class="line">        <span class="comment">//zeroNumFirst  为FIRST_BUCKET_SIZE 的前导零</span></span><br><span class="line">        <span class="keyword">int</span> bucketInd = zeroNumFirst - zeroNumPos;  <span class="comment">//哪个一位数组</span></span><br><span class="line">        <span class="comment">//判断这个一维数组是否已经启用</span></span><br><span class="line">        <span class="keyword">if</span> (buckets.get(bucketInd) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//newLen  一维数组的长度</span></span><br><span class="line">            <span class="keyword">int</span> newLen = <span class="number">2</span> * buckets.get(bucketInd - <span class="number">1</span>).length();</span><br><span class="line">            <span class="keyword">if</span> (debug)</span><br><span class="line">                System.out.println(<span class="string">"New Length is:"</span> + newLen);</span><br><span class="line">            buckets.compareAndSet(bucketInd, <span class="keyword">null</span>,</span><br><span class="line">                    <span class="keyword">new</span> AtomicReferenceArray&lt;E&gt;(newLen));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> idx = (<span class="number">0x80000000</span>&gt;&gt;&gt;zeroNumPos) ^ pos;   <span class="comment">//在这个一位数组中，我在哪个位置</span></span><br><span class="line">        newd = <span class="keyword">new</span> Descriptor&lt;E&gt;(desc.size + <span class="number">1</span>, <span class="keyword">new</span> WriteDescriptor&lt;E&gt;(</span><br><span class="line">                buckets.get(bucketInd), idx, <span class="keyword">null</span>, e));</span><br><span class="line">    &#125; <span class="keyword">while</span> (!descriptor.compareAndSet(desc, newd));</span><br><span class="line">    descriptor.get().completeWrite();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码难点分析:</p><blockquote><ol><li><code>desc.completeWrite()</code>预防上一个线程在设置完descriptor后(while语句块里), 还没来得及执行最后一句话completeWrite(保存真正的值), 所以在do里预先执行一次, 预防出现没保存值的情况</li><li><code>计算第一维索引bucketIndex</code>即计算进位后前导零位数差值来作为bucketIndex; 当第一个组数(长度为8), 则pos = 8+8 = 16, 会导致进位, 通过前导零差值则可计算出第一维的索引下标</li><li><code>计算第二维索引iIndex</code><code>(0x80000000&gt;&gt;&gt;zeroNumPos) ^ pos</code>;<font color="orange">这个比较难理解, 我们看如下分析:</font></li></ol></blockquote>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">0x80000000 32位如下:</span><br><span class="line">1000 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">无符号右移动zeroNumPos位(pos的前导零个数)</span><br><span class="line">比如pos=17,代表第二个数组的第一位,坐标为(1,0)</span><br><span class="line">17已进位,则前导零个数为27,无符号右移27位,高位补27个零:</span><br><span class="line">0000 0000 0000 0000 0000 0000 0001 0000</span><br><span class="line">^异或pos (相等为0, 不等为1):</span><br><span class="line">0000 0000 0000 0000 0000 0000 0001 0001</span><br><span class="line">结果为:</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line">表明可以存入的索引为1 (注意索引从0开始, 即第二位)</span><br><span class="line">=======================================</span><br><span class="line">比如pos=13, 代表第一个数组第五位, 坐标为(0,4)</span><br><span class="line">前导零个数为28,无符号右移28位,高位补28个零:</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 1000</span><br><span class="line">^异或pos</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 1101</span><br><span class="line">结果为:</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0101</span><br><span class="line">表明可以存入的索引为5 (注意索引从0开始, 即第六位)</span><br><span class="line">=======================================</span><br><span class="line">比如pos=15, 代表第一个数组第七位, 坐标为(0,6)</span><br><span class="line">前导零个数为28,无符号右移28位,高位补28个零:</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 1000</span><br><span class="line">^异或pos</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 1111</span><br><span class="line">结果为:</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0111</span><br><span class="line">表明可以存入的索引为7 (注意索引从0开始, 即第八位)</span><br></pre></td></tr></table></figure><p><font color="red">为何这样设计? 这个需要对二进制数据结构比较敏感, 可能10进制已经固化到思维, 二进制反而很不直观, 采用二进制进位和前导零的关系, 可以直接映射坐标</font></p><blockquote><ol start="4"><li>每次会判断数组是否存在, 不存在表示前一个数组已满, 需要<code>扩容(创建后一个新数组)</code>, 长度为前一个的2倍</li></ol></blockquote><ul><li><code>ABA问题</code>CAS无法解决ABA问题, 即A线程讲i改为2, 然后又恢复原值, 造成B线程无法得知其中的过程;如果是值类型可能没有问题, 但是某些业务可能出现问题, 比如充值, 所以提出了<code>带时间戳的CAS</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReferenceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; money =</span><br><span class="line">            <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">19</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 3个充值线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> timestamp = money.getStamp();</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    Integer m = money.getReference();</span><br><span class="line">                    <span class="keyword">if</span> (m &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (money.compareAndSet(m, m + <span class="number">20</span>, timestamp, timestamp + <span class="number">1</span>)) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"余额小于20元,充值成功,余额:"</span> + money.getReference() + <span class="string">"元"</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"余额大于20,无需充值"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1个模拟消费线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> timestap = money.getStamp();</span><br><span class="line">                        Integer m = money.getReference();</span><br><span class="line">                        <span class="keyword">if</span> (m &gt; <span class="number">10</span>) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"金额大于10元"</span>);</span><br><span class="line">                            <span class="keyword">if</span> (money.compareAndSet(m, m - <span class="number">10</span>, timestap, timestap + <span class="number">1</span>)) &#123;</span><br><span class="line">                                System.out.println(<span class="string">"成功消费10元,余额:"</span> + money.getReference() + <span class="string">"元"</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">"没有足够的金额"</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>AtomicMarkableReference</code>适合只修改一次, 因为它的stamp是boolean布尔, 所以只有「未标记」/「已标记」两种状态</li></ul><h2 id="concurrent并发包">Concurrent并发包</h2><ul><li><p><code>ReentrantLock</code><font color="orange">这里重点讲一下锁的可重入：ReentrantLock和synchronized都是可重入的, 意思是同一个获得锁的线程, 不管进入临界区几次, 都是允许进入的；可重入机制: 每一个锁(monitor)关联一个线程持有者和计数器，当计数器为 0 时表示该锁没有被任何线程持有，那么任何线程都可能获得该锁而调用相应的方法；当某一线程请求成功后，JVM会记下锁的持有线程，并且将计数器置为 1；此时其它线程请求该锁，则必须等待；而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增；当线程退出同步代码块时，计数器会递减，如果计数器为 0，则释放该锁。</font></p><p>我们来模拟不可重入锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 不可重入锁 (使用CAS实现)</span><br><span class="line"> * 同一线程, 当两次调用lock, 而不调用unlock时, 会产生死锁</span><br><span class="line"> * 原因是第二次lock会永远更新不成功, 则永远在死循环</span><br><span class="line"> */</span><br><span class="line">public class UnreentrantLockByCAS &#123;</span><br><span class="line">      private AtomicReference&lt;Thread&gt; owner = new AtomicReference&lt;&gt;();</span><br><span class="line">      //AtomicInteger</span><br><span class="line"></span><br><span class="line">      public void lock() &#123;</span><br><span class="line">          Thread current = Thread.currentThread();</span><br><span class="line">          //这句是很经典的“自旋”语法</span><br><span class="line">          for (; ; ) &#123;</span><br><span class="line">              if (owner.compareAndSet(null, current)) &#123;</span><br><span class="line">                  return;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public void unlock() &#123;</span><br><span class="line">          Thread current = Thread.currentThread();</span><br><span class="line">          owner.compareAndSet(current, null);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不可重入锁 (使用CAS实现)</span></span><br><span class="line"><span class="comment"> * 同一线程, 当两次调用lock, 而不调用unlock时, 会产生死锁</span></span><br><span class="line"><span class="comment"> * 原因是第二次lock会永远更新不成功, 则永远在死循环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnreentrantLockByCAS</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> AtomicReference&lt;Thread&gt; owner = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">        <span class="comment">//AtomicInteger</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="comment">//这句是很经典的“自旋”语法</span></span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (owner.compareAndSet(<span class="keyword">null</span>, current)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            owner.compareAndSet(current, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然我们改动一下, 增加Thread判断, 同时增加计数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可重入 (synchronized实现)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockBySync</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</span><br><span class="line">      Thread lockedBy = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">int</span> lockedCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">          Thread thread = Thread.currentThread();</span><br><span class="line">          <span class="keyword">while</span> (isLocked &amp;&amp; lockedBy != thread) &#123;</span><br><span class="line">              wait();</span><br><span class="line">          &#125;</span><br><span class="line">          isLocked = <span class="keyword">true</span>;</span><br><span class="line">          lockedCount++;</span><br><span class="line">          lockedBy = thread;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (Thread.currentThread() == <span class="keyword">this</span>.lockedBy) &#123;</span><br><span class="line">              lockedCount--;</span><br><span class="line">              <span class="keyword">if</span> (lockedCount == <span class="number">0</span>) &#123;</span><br><span class="line">                  isLocked = <span class="keyword">false</span>;</span><br><span class="line">                  notify();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可重入 (使用CAS实现)</span></span><br><span class="line"><span class="comment"> * 两要素: 若是当前线程, 重入时state计数器加1, 释放时减1</span></span><br><span class="line"><span class="comment"> *  1.持有当前线程</span></span><br><span class="line"><span class="comment"> *  2.计数器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockByCAS</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> AtomicReference&lt;Thread&gt; owner = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">if</span> (current == owner.get()) &#123;</span><br><span class="line">                state++;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这句是很经典的“自旋”语法</span></span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (owner.compareAndSet(<span class="keyword">null</span>, current)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">if</span> (current == owner.get()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (state != <span class="number">0</span>) &#123;</span><br><span class="line">                    state--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    owner.compareAndSet(current, <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>总结:</p></li></ul><blockquote><p><code>可重入</code>:同一线程, 加几次锁, 就要释放几次<code>可中断</code>:<code>lock.lockInterruptibly();</code>只有声明为可中断加锁, 则线程是可以发起中断<code>thread.interrupt()</code><code>可限时</code>:意思是超时后若还未获得锁(monitor),则放弃锁竞争<code>lock.tryLock(5, TimeUnit.SECONDS)</code><code>公平锁</code>:<code>new ReentrantLock(true)</code>默认是非公平锁, 所谓公平即先来则先获得锁; 但是公平锁会维持队列, 且没有优先级的概念,非公平锁具有更高的吞吐量</p></blockquote><ul><li><code>Condition</code></li></ul><p><font color="red">Condition(await/singnal/singnalAll)和ReentrantLock的关系</font>就好比<font color="red">Object(wait/notify/notifyAll)与synchonized的关系</font>它提供了一个<code>awaitUninterruptibly</code>, 和wait一样, 但是不会响应中断, 即会一直等待signal唤醒具体就不细说,看一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock(); <span class="comment">// 类似synchronized</span></span><br><span class="line">            condition.await(); <span class="comment">// 类似obj.wait(); 注意await和object.wait一样是会释放锁的</span></span><br><span class="line">            <span class="comment">// 注意如果唤醒的是多个线程, 这里也会如同notifyAll一样, 出现锁竞争</span></span><br><span class="line">            System.out.println(<span class="string">"thread is going on"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ConditionTest r = <span class="keyword">new</span> ConditionTest();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line"></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始唤醒await的线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">"begin signal thread"</span>);</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Semaphore信号量</code></li></ul><p>[ˈseməfɔ:®] 信号量, 也可以称呼为共享锁它可以允许多个线程进入临界区, 但是一旦许可耗尽, 则其他线程也需要等待许可的释放,即退化为Lock锁;Semaphore和Lock的区别:</p><blockquote><ol><li>锁只允许一个线程进入临界区, 信号量允许多个线程进入临界区, 类似广义的独享锁</li><li>信号量会指定许可permission的数量, 一旦许可耗尽则退化为独享锁</li><li>一般一个线程只会持有一个permission许可, 但也可以一个线程持有多个许可</li></ol></blockquote><p>我们来看一个例子:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 获取一个permission许可(可以多个, 但消费一个则少一个)</span></span><br><span class="line">              semaphore.acquire();</span><br><span class="line"></span><br><span class="line">              <span class="comment">//模拟2s耗时操作</span></span><br><span class="line">              Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">              System.out.println(<span class="string">"Thread_"</span> + Thread.currentThread().getId() + <span class="string">" done!"</span>);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">              semaphore.release();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 创建容量固定为20的线程池</span></span><br><span class="line">          ExecutorService excutorService = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">final</span> SemaphoreTest semaphoreTask = <span class="keyword">new</span> SemaphoreTest();</span><br><span class="line"></span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">           * 20个线程任务立马提交完毕, 但是任务里有2s耗时操作, 所以一次最多允许执行5个线程, 2s后再执行5个线程, 依次之</span></span><br><span class="line"><span class="comment">           * 注意: execute 和 submit 区别</span></span><br><span class="line"><span class="comment">           *      1. submit有三个重载</span></span><br><span class="line"><span class="comment">           *         &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</span></span><br><span class="line"><span class="comment">           *         &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)</span></span><br><span class="line"><span class="comment">           *         Future&lt;?&gt; submit(Runnable task)</span></span><br><span class="line"><span class="comment">           *      2. submit有返回值, 但execute没有</span></span><br><span class="line"><span class="comment">           *      3. submit可以处理Exception异常, 捕获Future.get()即可</span></span><br><span class="line"><span class="comment">           *</span></span><br><span class="line"><span class="comment">           *</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)&#123;</span><br><span class="line">              excutorService.<span class="comment">/*execute*/</span>submit(semaphoreTask);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><code>ReentrantReadWriteLock读写锁</code></li></ul><p>它要解决的是<code>synchronized</code>在「读读」互斥串行的情况</p><blockquote><ol><li>读写锁是可重入的</li><li><code>读-读</code>: 不互斥, 是共享锁, 内部使用了AQS<code>写-写</code>: 互斥, 类似Lock<code>读-写</code>: 互斥, 同上; 即不支持<code>锁升级</code><code>写-读</code>: 互斥, 但是支持<code>锁降级</code>, 即线程获取写锁, 在不释放写锁的情况下, <strong>当前线程</strong>还可以获取读锁; 然后释放写锁后, 此时还剩下读锁, 则称为<code>锁降级</code></li><li>内部有<code>WriteLock</code>和<code>ReadLock</code>, 采用了<code>AQS(实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架)</code></li></ol></blockquote><p>来看一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读写互斥 (测试锁降级)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结论: ReentrantReadWriteLock支持锁降级, 但不支持锁升级</span></span><br><span class="line"><span class="comment"> *    1. 写锁降级为读锁, 但是不会释放当前线程获得的写锁; 仍需要手动释放写锁, 否则其他线程永远无法获得写锁</span></span><br><span class="line"><span class="comment"> *    2. 首先读写锁是互斥的;</span></span><br><span class="line"><span class="comment"> *       2.1 获取读锁 -&gt; 获取写锁</span></span><br><span class="line"><span class="comment"> *           发现无法获取写锁了, 这表明读写锁互斥, 且不支持锁升级 (即读锁升级为写锁)</span></span><br><span class="line"><span class="comment"> *       2.2 获取写锁 -&gt; 获取读锁</span></span><br><span class="line"><span class="comment"> *           发现写锁加锁后还能获取读锁, 这表明互斥情况下, 支持锁降级 (写锁降级为读锁)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *       2.3 当有读锁时，写锁就不能获得；而当有写锁时，除了获得写锁的这个线程可以获得读锁外，其他线程不能获得读锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockDownTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ReentrantReadWriteLock rwLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 先获取写锁, 在不释放写锁的前提下, 再获取读锁, 发现可以成功; 表明支持锁降级</span></span><br><span class="line"><span class="comment">         * 先获取读锁, 发现不能再获取写锁, 证明不支持锁升级</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rwLock.writeLock().lock();</span><br><span class="line">        System.out.println(<span class="string">"Thread_"</span> + Thread.currentThread().getId() +<span class="string">" get writeLock"</span>);</span><br><span class="line"></span><br><span class="line">        rwLock.readLock().lock();</span><br><span class="line">        System.out.println(<span class="string">"Thread_"</span> + Thread.currentThread().getId() +<span class="string">" get readLock"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放写锁, 完成锁降级为读锁</span></span><br><span class="line">        rwLock.writeLock().unlock();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后释放降级的读锁</span></span><br><span class="line">        rwLock.readLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        LockDownTest r = <span class="keyword">new</span> LockDownTest();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"FINISH"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>CountDownLatch</code> 倒数计时器(闭锁)闭锁, 类似一个门最初是关闭的, 比如等到10人(线程)到齐了才会开门, 所有人(线程)才可通过, 但是门打开之后就不能再关上, 所以不能重复利用</li></ul><blockquote><ol><li>它允许一个或多个线程一直等待, 直到其他线程的操作执行完后再执行, 类似join的功能</li><li>和Semaphore信号量一样, 提供一个count计数, 且只能初始化一次,不能修改; 当计数为0则唤醒阻塞的线程</li><li>CountDownLatch 和 join的区别其实两者的功能完成一样,都是阻塞线程等待其他线程执行完毕,然后继续执行; 但是join只能等待其他线程任务整体完成, 而CountDownLatch则是通过计数器count来作为标准, 所以粒度更细, 所以控制力更强</li><li>总结在需要等待的线程里调用<code>countDownLatch.countDown();</code>在受控主线程调用<code>countDownLatch.await();</code>直到内部count耗尽为0, 则会继续执行受控主线程</li><li>适用场景一般用于启动服务/任务前, 等待其他预检测线程反馈OK, 然后再继续启动很适合做Master/Worker, MapReduce等架构模式</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟随机耗时任务</span></span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>) * <span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">"Thread_"</span> + Thread.currentThread().getId() + <span class="string">" complete."</span>);</span><br><span class="line">            <span class="comment">// 每次都会count-1,直到为零,就会notify/signal唤醒主线程</span></span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        CountDownLatchTest1 test = <span class="keyword">new</span> CountDownLatchTest1();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            service.submit(test);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意不是调用Object的wait(), 这里很容易手误</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">"Main Thread Finish."</span>);</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>CyclicBarrier</code> 循环屏障(闭锁)</li></ul><p>它可以实现让一组线程等待至某个状态之后再全部同时执行</p><blockquote><ol><li>getNumberWaiting() 有几个线程已经到达屏障点getParties()取得parties个数reset() 将屏障重置为其初始状态isBroken() 查询此屏障是否处于损坏状态, 即查询阻塞的线程是否被中断</li><li>和CountDownlatch区别CountDownlatch是使用countDown进行count-1操作, 再使用await阻塞主线程, 直到count为零再唤醒继续执行;CyclicBarrier是利用await进行count+1, 当count==parties时则表明都到达屏障点</li><li>特点3.1如果在线程处于等待状态时barrier被reset()或者在调用await()时 barrier 被损坏，将抛出BrokenBarrierException异常3.2如果当前线程在进入此方法时已经设置了该线程的中断状态或者在等待时被中断，将抛出InterruptedException，并且清除当前线程的已中断状态3.3如果任何线程在等待时被中断，则其他所有等待线程都将抛出 BrokenBarrierException 异常，并将 barrier 置于损坏状态。3.4如果当前线程是最后一个将要到达的线程，并且构造方法中提供了一个非空的屏障操作(barrierAction), 那么在允许其他线程继续运行之前，当前线程将运行该操作。如果在执行屏障操作过程中发生异常，则该异常将传播到当前线程中, 并将 barrier 置于损坏状态(即Commander发生了异常, 则会将barrier置于损坏状态, 同时将异常抛出到主线程)</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Commander</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是集合还是完成任务</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag;</span><br><span class="line">        <span class="comment">// 人数</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Commander</span><span class="params">(<span class="keyword">boolean</span> flag, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.flag = flag;</span><br><span class="line">            <span class="keyword">this</span>.count = count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                System.out.println(<span class="string">"指挥官接到消息:[士兵"</span> + count + <span class="string">"个, 任务完成!]"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"指挥官接到消息:[士兵"</span> + count + <span class="string">"个, 集合完毕!]"</span>);</span><br><span class="line">                System.out.println(<span class="string">"指挥官发布执行任务命令... ..."</span>);</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Soldier</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String soldier;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier barrier;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Soldier</span><span class="params">(String soldier, CyclicBarrier barrier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.soldier = soldier;</span><br><span class="line">            <span class="keyword">this</span>.barrier = barrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// ------------ 等待所有士兵集合 ------------</span></span><br><span class="line">                <span class="keyword">int</span> waitCount = barrier.getParties() - barrier.getNumberWaiting() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (waitCount == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(soldier + <span class="string">", 所有士兵已集合完毕, 开始通知指挥官..."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                barrier.await();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// ------------ 集合完毕后开始各自执行任务 ------------</span></span><br><span class="line">                doWork();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// ------------ 等待所有士兵完成任务 ------------</span></span><br><span class="line">                waitCount = barrier.getParties() - barrier.getNumberWaiting() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (waitCount == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(soldier + <span class="string">"已完成, 所有士兵已完成任务, 开始通知指挥官..."</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    System.out.println(soldier + <span class="string">"已完成, 开始等待其他"</span> + waitCount + <span class="string">"人完成任务"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                barrier.await();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//Math.abs(new Random().nextInt() % 10000);</span></span><br><span class="line">                Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">        Thread[] solders = <span class="keyword">new</span> Thread[count];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(count, <span class="keyword">new</span> Commander(flag, count));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"队伍开始集合!"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"士兵"</span> + i + <span class="string">"报到"</span>);</span><br><span class="line">            solders[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Soldier(<span class="string">"士兵"</span> + i, barrier));</span><br><span class="line">            solders[i].start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">5</span>)&#123;</span><br><span class="line">                <span class="comment">//solders[0].interrupt();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>LockSupport</code> 锁支持源语</li></ul><p>之前讲过, suspend/resume已经被淘汰, 因为可能导致死锁wait/notify(notifyAll)则比前者更进一步, 解决了死锁问题, 但还是有一个问题存留, <code>先notify, 后wait</code>,虽然不会导致死锁, 但是会导致wait的线程一直hang在那</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">这里再备注一下suspend/resume的缺陷</span></span><br><span class="line"><span class="string">suspend和sleep很像,</span> <span class="string">也和wait很像,</span> <span class="string">但也有不同:</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> <span class="string">suspend也会持有监视器(锁),</span> <span class="string">和sleep很像,</span> <span class="string">但是sleep可以被中断,</span> <span class="string">也可以过期策略,</span> <span class="string">所以不会死锁</span></span><br><span class="line"><span class="number">2.</span> <span class="string">suspend也可以通过resume唤醒,</span> <span class="string">和wait/notify很像,</span> <span class="string">但是wait是释放了监视器(锁)的,</span> <span class="string">只是需要等待唤醒而已,</span> <span class="string">所以不会死锁</span></span><br><span class="line"><span class="number">3.</span> <span class="string">suspend一没有释放锁,</span> <span class="string">二没有中断机制,</span> <span class="string">三没有过期策略,</span> <span class="string">所以只能被resume唤醒</span></span><br><span class="line">   <span class="string">如果resume被先调用,</span> <span class="string">suspend后执行,</span> <span class="string">则会导致锁一直不被释放,</span> <span class="string">从而死锁</span></span><br></pre></td></tr></table></figure><blockquote><ol><li><code>LockSupport可以解决两大问题</code>1.1 解决suspend/resume的死锁问题1.2 解决wait/notify(notifyAll)的线程悬挂阻塞问题(虽然不会导致死锁了)</li><li><code>LockSupport两大优势</code>2.1 LockSupport不需要在同步代码块里;所以线程间也不需要维护一个共享的同步对象了，实现了线程间的解耦2.2 unpark函数可以先于park调用，所以不需要担心线程间的执行的先后顺序<strong>unpark将许可permit置为1, park将permit置为0</strong><strong>unpark-&gt;park; 会导致线程不会被阻塞</strong><strong>park-&gt;unpark; 线程阻塞后被唤醒</strong><strong>多次调用unpark, 由于只是重置为1,所以不影响</strong><strong>多次调用park, 由于LockSuport是不可重入锁, 所以会死锁</strong></li><li><code>广泛的应用</code><code>ThreadPoolExecutor内部使用LockSupport</code><code>阻塞</code>:典型的 future.get() 同步阻塞等待线程池的执行结果; submit提交Callable任务后会返回FutureTask, 此方法会有get方法, 继而调用awaitDone进行阻塞, 内部实则调用了LockSupport.park()<code>唤醒</code>:Callable被包装成了FutureTask, 内部会c.call()执行任务, 继而调用set方法, 内部调用finishCompletion, 而finishCompletion会通过CAS取出所有等待的线程, 循环唤醒 LockSupport.unpark(t)</li><li><code>注意事项</code></li></ol></blockquote><ul><li>ThreadLocal</li></ul><p>线程本地变量</p><blockquote><ol><li>ThreadLocal不是用来解决对象共享访问问题的; 反其道而行, 解决某个对象需要一直跟随某线程(同生共死), 从而解决对象如何传递的问题</li><li>典型的<code>Session会话管理</code>,多线程需要避免Session的调用混乱2.1 首先不加锁, 铁定出现多线程问题(openSession多次/正在写入数据库却被其他线程关闭close)2.2 加独享锁, 显然问题能解决, 但是一个操作正在进行,则其他操作必须等待, 性能有问题3.3 在DAO层做如下操作:<code>openSession() -&gt; 数据库操作 -&gt; close()</code>也能解决问题, 但是session频繁的打开关闭这也是性能问题</li><li>ThreadLocal正好利用线程的生命周期, 将需要使用的副本对象附加其上, 这样session对象的调用就不会错乱</li><li>ThreadLocalMap总结:4.1 ThreadLocalMap解决hash采用了线性探测(开发地址法), 如果冲突则加1; 这种算法比起链地址法效率低很多, 所以建议一个线程只保存一个变量(即一个ThreadLocal)4.2 ThreadLocalMap的key是弱引用, 而Value是强引用; 这导致ThreadLocal在没有外部对象强引用时，发生GC时弱引用Key会被回收, 而Value不会回收; 如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露; 但线程结束时总会释放掉;但如果线程是使用的线程池, 由于线程池里的线程结束是不会销毁的, 这时候就发生了真正意义上的内存泄漏</li></ol></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/7432604-ad2ff581127ba8cc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/806/format/webp" alt="ThreadLocal示意图"></p><p>ThreadLocal使用场景为 用来解决 数据库连接、Session管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal &lt; Connection &gt; connectionHolder = <span class="keyword">new</span> ThreadLocal &lt; Connection &gt; () &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(DB_URL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> connectionHolder.get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal threadSession = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException </span>&#123;</span><br><span class="line">    Session s = (Session) threadSession.get();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">            s = getSessionFactory().openSession();</span><br><span class="line">            threadSession.set(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (HibernateException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InfrastructureException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20181209234109898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Y2NDEzODU3MTI=,size_16,color_FFFFFF,t_70" alt></p><ul><li>ForkJoin</li></ul><p>JDK原生的单机版的MapReduce归并计算, Amino里也有类似的MasterWorker模式的实现</p><p><strong>主要思想:</strong><img src="http://dl.iteye.com/upload/attachment/234119/4f7cd1b0-9f58-306f-9590-87499929861d.jpg" alt></p><p><strong>对比MapReduce1.0原理</strong><img src="https://upload-images.jianshu.io/upload_images/14019352-0c530b046636edd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt></p><blockquote><ol><li></li></ol></blockquote><p><strong>类图:</strong><img src="http://dl.iteye.com/upload/attachment/234124/8703a34a-9f05-37a5-bb08-c135bb5bffc8.jpg" alt></p><blockquote><p><strong>一 特性:</strong></p><ol><li>计算资源共享</li><li>高性能队列</li><li>避免伪共享 (Disruptor也有类似的实现, 采用补位对齐缓存行)它的实现是使用了<code>@sun.misc.Contended</code>jdk8的注解</li><li>工作窃取机制 (特有)<strong>二 对比ThreadPoolExecutor</strong></li><li>线程池ThreadPoolExecutor公用任务队列, ForkJoinPool则每个线程单独一个任务队列</li><li>线程池支持Runnable/Callable两种类型的任务, 同理ForkJoinPool也支持带返回值/不带返回值的任务<code>RecursiveTask(带返回值) / RecursiveAction(不带返回值)</code><strong>三 对应关系</strong></li><li><code>ThreadPoolExecutor --&gt; Thread --&gt; Runnable/Callable</code></li><li><code>ForkJoinPool --&gt; ForkJoinWorkerThread --&gt; RecursiveAction/RecursiveTask</code>注意不是为了替代ExecutorService, 而仅仅作为补充, 比如补充了<code>work-stealing</code>逻辑<strong>四 工作窃取(work stealing)</strong><font color="red">1. 因为任务队列是进行了拆分 (拆到什么粒度需要我们指定拆分的临界值), 即线程会各自独享一个子任务队列;</font></li></ol></blockquote><ol start="2"><li>当其中线程A先执行完毕, 线程B还未执行完, 则A会从B偷取一个任务;</li><li>如何偷? 拆分的线程子任务队列是一个线程安全的双端队列, 被窃取线程永远从头部取, 窃取线程永远从队尾取, 避免并发导致的竞争, 但是只有一个任务的极端情况还是无法避免竞争</li></ol><blockquote><p><strong>五 优缺点</strong>优点: 类似单机版本的MapReduce归并计算, 比线程池更加充分利用CPU资源缺点: 编码复杂, 而且需要大量队列, 线程…的创建与销毁, 导致效率无法明显的提升, 貌似Netty5.0就是基于此原因之一放弃发布<strong>六 注意事项</strong><font color="red">1. ForkJoinPool 也有submit, execute, 同时多了一个invoke<strong>非阻塞:</strong>execute不带返回值, submit带返回值, 这和ThreadPoolExecutor类似submit返回了Future的子类ForkJoinTask, 调用task.get()才会阻塞<strong>阻塞:</strong>invoke会阻塞调用线程 (主线程), 直到有结果并返回</font></p></blockquote><ol start="2"><li>fork是分配任务<code>leftTask.fork(); rightTask.fork();</code>替换为<code>invokeAll(leftTask, rightTask);</code>使用fork, 假如程数量固定, 当前线程会将leftTask/rightTask分配下去,自身并不会做任何事情, 会浪费一个线程</li></ol><p>示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinCalcTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long start;<span class="comment">//起始值</span></span><br><span class="line">    <span class="keyword">private</span> Long end;<span class="comment">//结束值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Long critical = <span class="number">100000L</span>;<span class="comment">//临界值10w (即划分的区间段大小)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinCalcTask</span><span class="params">(Long start, Long end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否是拆分完毕</span></span><br><span class="line">        Long lenth = end - start;</span><br><span class="line">        <span class="keyword">if</span> (lenth &lt;= critical) &#123;</span><br><span class="line">            <span class="comment">//如果拆分完毕就相加</span></span><br><span class="line">            Long sum = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span> (Long i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//没有拆分完毕就开始拆分 (递归拆分的意思)</span></span><br><span class="line">            Long middle = (end + start) / <span class="number">2</span>;<span class="comment">//计算的两个值的中间值</span></span><br><span class="line">            ForkJoinCalcTask leftTask = <span class="keyword">new</span> ForkJoinCalcTask(start, middle);</span><br><span class="line">            ForkJoinCalcTask rightTask = <span class="keyword">new</span> ForkJoinCalcTask(middle + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 方式1</span></span><br><span class="line">            <span class="comment">//right.fork();//拆分，压入线程队列</span></span><br><span class="line">            <span class="comment">//left.fork();//拆分，压入线程队列</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 方式2 更好的做法</span></span><br><span class="line">            <span class="comment">// 方式1的缺点是: 假如程数量固定, 当前线程会将leftTask/rightTask分配下去,</span></span><br><span class="line">            <span class="comment">// 自身并不会做任何事情, 会浪费一个线程</span></span><br><span class="line">            invokeAll(leftTask, rightTask);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待任务执行结束合并其结果</span></span><br><span class="line">            <span class="keyword">return</span> leftTask.join() + rightTask.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ForkJoin实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();<span class="comment">//实现ForkJoin 就必须有ForkJoinPool的支持</span></span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> ForkJoinCalcTask(<span class="number">0L</span>, <span class="number">10000000000L</span>);<span class="comment">//参数为起始值与结束值 (100亿)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意invoke是阻塞方法</span></span><br><span class="line">        <span class="comment">// submit和execute是非阻塞方法, submit是异步的, 返回了ForkJoinTask(继承了Future),</span></span><br><span class="line">        <span class="comment">// 通过Future接口的get可以阻塞获取结果</span></span><br><span class="line">        Long invoke = forkJoinPool.invoke(task); <span class="comment">//压入线程队列</span></span><br><span class="line">        <span class="keyword">long</span> l1 = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"invoke = "</span> + invoke + <span class="string">"  time: "</span> + (l1 - l));</span><br><span class="line">        <span class="comment">//invoke = -5340232216128654848  time: 4661</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通线程实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Long x = <span class="number">0L</span>;</span><br><span class="line">        Long y = <span class="number">10000000000L</span>;</span><br><span class="line">        <span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line">        Long i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0L</span>; i &lt;= y; i++) &#123;</span><br><span class="line">            x += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> l1 = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"invoke = "</span> + x + <span class="string">"  time: "</span> + (l1 - l));</span><br><span class="line">        <span class="comment">//invoke = -5340232216128654848  time: 75901</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Java 8 并行流的实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> reduce = LongStream.rangeClosed(<span class="number">0</span>, <span class="number">10000000000L</span>).parallel().reduce(<span class="number">0</span>, Long::sum);</span><br><span class="line">        <span class="keyword">long</span> l1 = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"invoke = "</span> + reduce + <span class="string">"  time: "</span> + (l1 - l));</span><br><span class="line">        <span class="comment">//invoke = -5340232216128654848  time: 4366</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//test1();</span></span><br><span class="line">        <span class="comment">//test2();</span></span><br><span class="line">        test3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>源码分析</strong>待续…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;知识要点&quot;&gt;知识要点&lt;/h2&gt;
&lt;p&gt;写此篇只记录一些自己觉得比较重要的知识点, 其余查阅之前的篇幅&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;分类&lt;/th&gt;
&lt;th style=&quot;text-al
      
    
    </summary>
    
      <category term="concurrent" scheme="https://doooyo.github.io/categories/concurrent/"/>
    
    
      <category term="锁" scheme="https://doooyo.github.io/tags/%E9%94%81/"/>
    
      <category term="队列" scheme="https://doooyo.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="线程池" scheme="https://doooyo.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
</feed>
